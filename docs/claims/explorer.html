<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>REE Claims Explorer</title>
  <style>
    :root {
      --bg: #f5f1e8;
      --bg-2: #efe6d9;
      --ink: #1f2328;
      --muted: #5b5f66;
      --accent: #2b6f72;
      --accent-2: #b45a2a;
      --card: #ffffff;
      --border: #d8d0c3;
      --shadow: rgba(31,35,40,0.08);
      --error: #8c2f2f;
      --error-bg: #fbecec;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Avenir Next", "Gill Sans", "Segoe UI", sans-serif;
      color: var(--ink);
      background: radial-gradient(1200px 800px at 20% 0%, var(--bg), var(--bg-2));
    }

    header {
      padding: 28px 24px 12px 24px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.5));
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 5;
    }

    h1 {
      margin: 0 0 6px 0;
      font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
      letter-spacing: 0.4px;
      font-size: 28px;
    }

    .subtitle {
      color: var(--muted);
      font-size: 14px;
    }

    .stats {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    .stat-card {
      background: var(--card);
      border: 1px solid var(--border);
      padding: 8px 12px;
      border-radius: 10px;
      box-shadow: 0 2px 8px var(--shadow);
      font-size: 13px;
    }

    main {
      padding: 18px 24px 32px 24px;
    }

    .error-banner {
      display: none;
      background: var(--error-bg);
      color: var(--error);
      border: 1px solid var(--error);
      border-radius: 10px;
      padding: 10px 12px;
      margin-bottom: 12px;
      font-size: 13px;
    }
    .error-banner pre {
      margin: 6px 0 10px 0;
      padding: 8px;
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: auto;
      font-size: 12px;
    }
    .error-banner code {
      background: #fff;
      border: 1px solid var(--border);
      padding: 1px 4px;
      border-radius: 4px;
    }

    .controls {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 2px 8px var(--shadow);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      align-items: end;
    }

    .controls label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 4px;
    }

    input, select, textarea {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
      color: var(--ink);
      font-size: 14px;
    }

    .buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      border: 1px solid var(--border);
      background: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
    }

    button.primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    button.ghost {
      background: transparent;
    }

    .layout {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 16px;
      margin-top: 16px;
    }

    .layout > * {
      min-width: 0;
    }

    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 2px 8px var(--shadow);
      padding: 12px;
      overflow: hidden;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    th, td {
      text-align: left;
      padding: 8px 6px;
      border-bottom: 1px solid #eee;
      vertical-align: top;
    }

    th {
      font-size: 12px;
      color: var(--muted);
    }

    tr:hover {
      background: #faf7f1;
      cursor: pointer;
    }

    tr.selected {
      background: #f0f7f6;
    }

    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid var(--border);
    }

    .type-invariant { background: #f7ecd0; border-color: #dfc17a; }
    .type-architectural_commitment { background: #e5efff; border-color: #9bb6e8; }
    .type-mechanism_hypothesis { background: #e3f2ee; border-color: #92c9b7; }
    .type-implementation_note { background: #efeff2; border-color: #c0c4ce; }
    .type-open_question { background: #fdebd8; border-color: #e5b37d; }

    .status-stable { border-left: 4px solid #2f6f3e; padding-left: 6px; }
    .status-provisional { border-left: 4px dashed #b67923; padding-left: 6px; }
    .status-candidate { border-left: 4px dotted #7a4e2e; padding-left: 6px; }
    .status-legacy { border-left: 4px solid #8c2f2f; padding-left: 6px; }
    .status-active { border-left: 4px solid #2f6f3e; padding-left: 6px; }

    .conflict { color: #8c2f2f; font-weight: 600; }

    .detail h2 {
      margin: 0 0 8px 0;
      font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
      font-size: 20px;
    }

    .detail .meta {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 10px;
    }

    .detail ul {
      list-style: none;
      padding: 0;
      margin: 0 0 8px 0;
    }

    .detail li {
      margin-bottom: 4px;
    }

    .panel.detail {
      position: sticky;
      top: 120px;
      align-self: start;
      max-height: calc(100vh - 160px);
      overflow: auto;
    }

    .panel.table-panel {
      max-height: calc(100vh - 160px);
      overflow: auto;
    }

    .selected-summary {
      position: sticky;
      top: 0;
      background: var(--card);
      padding-bottom: 8px;
      margin-bottom: 10px;
      border-bottom: 1px dashed var(--border);
      z-index: 1;
    }

    .selected-group {
      margin-bottom: 8px;
    }

    .selected-label {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #f0f7f6;
      font-size: 11px;
      cursor: pointer;
    }

    .chip.empty {
      background: #fff;
      color: var(--muted);
      cursor: default;
    }

    .excerpt {
      background: #fbfaf6;
      border: 1px solid var(--border);
      padding: 8px;
      border-radius: 8px;
      max-height: 320px;
      overflow: auto;
      font-size: 12px;
    }

    details summary {
      cursor: pointer;
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }

    #leftWrap {
      display: block;
      min-width: 0;
    }

    #graphWrap {
      display: none;
      min-width: 0;
    }

    .graph-panel-wrap {
      max-height: calc(100vh - 160px);
      overflow: hidden;
      position: relative;
      min-width: 0;
    }

    .graph-panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px;
      overflow: auto;
      max-height: 520px;
      position: relative;
      min-height: 260px;
      max-width: 100%;
    }

    .graph-panel svg {
      display: block;
    }

    .graph-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 8px 0 10px 0;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
      color: var(--ink);
    }

    .control-group.inactive {
      opacity: 0.6;
    }

    .control-label {
      font-size: 11px;
      color: var(--muted);
    }

    .graph-controls label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--ink);
    }

    .graph-controls input {
      width: auto;
    }

    .docs-wrap {
      max-height: calc(100vh - 160px);
      overflow: auto;
      display: none;
      min-width: 0;
    }

    .governance-wrap {
      display: none;
      max-height: calc(100vh - 160px);
      overflow: auto;
      min-width: 0;
    }

    .governance-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }

    .gov-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      padding: 10px;
      box-shadow: 0 2px 8px var(--shadow);
    }

    .gov-card .label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .gov-card .value {
      font-size: 20px;
      font-weight: 600;
      line-height: 1;
    }

    .gov-meta {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 10px;
    }

    .gov-staleness {
      display: inline-block;
      margin-left: 6px;
      padding: 2px 8px;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 11px;
      vertical-align: middle;
    }

    .gov-staleness.fresh { background: #e7f5eb; border-color: #8fc4a0; color: #24583a; }
    .gov-staleness.stale { background: #fff5de; border-color: #d8b36d; color: #7c5a1f; }
    .gov-staleness.old { background: #fbecec; border-color: #c98f8f; color: #8c2f2f; }

    .gov-toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .gov-toolbar label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--ink);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 10px;
      background: #f8f5ef;
    }

    .gov-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      border: 1px solid var(--border);
      background: #f8f5ef;
      margin-left: 6px;
    }

    .gov-pill.human {
      background: #fbecec;
      border-color: #c98f8f;
      color: #8c2f2f;
    }

    .gov-pill.creative {
      background: #e9f1fb;
      border-color: #93afcf;
      color: #24466b;
    }

    .gov-sections {
      display: grid;
      gap: 12px;
    }

    .gov-section {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      background: #fff;
    }

    .gov-section h3 {
      margin: 0 0 8px 0;
      font-size: 15px;
      font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
    }

    .gov-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .gov-table th,
    .gov-table td {
      border-bottom: 1px solid #eee;
      padding: 6px 5px;
      text-align: left;
      vertical-align: top;
    }

    .gov-table th {
      color: var(--muted);
      font-size: 11px;
      white-space: nowrap;
    }

    .gov-empty {
      color: var(--muted);
      font-size: 12px;
      padding: 6px 0;
    }

    .gov-context-links {
      margin: 4px 0 10px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .gov-link-chip {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #f7f2e9;
      font-size: 11px;
      text-decoration: none;
      color: var(--ink);
    }

    .gov-claim-cell {
      display: grid;
      gap: 2px;
      min-width: 200px;
    }

    .gov-claim-meta {
      color: var(--muted);
      font-size: 11px;
    }

    .command-list {
      display: grid;
      gap: 8px;
    }

    .command-row {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      background: #f8f5ef;
    }

    .command-row code {
      display: block;
      white-space: pre-wrap;
      word-break: break-all;
      font-size: 12px;
      margin: 4px 0 8px 0;
    }

    .map-wrap {
      display: none;
      max-height: calc(100vh - 160px);
      overflow: auto;
      min-width: 0;
    }

    .map-toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .map-toolbar label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--ink);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 10px;
      background: #f8f5ef;
    }

    .map-summary {
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 8px 0;
    }

    .map-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
    }

    .map-card {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      background: #fff;
      box-shadow: 0 2px 8px var(--shadow);
    }

    .map-card.heat-low {
      border-color: #9ab6d6;
      background: linear-gradient(180deg, #f7fbff 0%, #ffffff 100%);
    }

    .map-card.heat-medium {
      border-color: #d8b36d;
      background: linear-gradient(180deg, #fffaf0 0%, #ffffff 100%);
    }

    .map-card.heat-high {
      border-color: #c98f8f;
      background: linear-gradient(180deg, #fff5f5 0%, #ffffff 100%);
    }

    .map-card h3 {
      margin: 0 0 6px 0;
      font-size: 15px;
      font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
    }

    .map-meta {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .map-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .map-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #f7f2e9;
      font-size: 11px;
      cursor: pointer;
    }

    .map-chip.signal-decision {
      border-color: #c98f8f;
      background: #fbecec;
    }

    .map-chip.signal-creative {
      border-color: #93afcf;
      background: #e9f1fb;
    }

    .map-chip.signal-conflict {
      border-color: #d8b36d;
      background: #fff5de;
    }

    .map-chip.stale-only {
      opacity: 0.65;
    }

    .map-chip.selected {
      border-color: var(--accent);
      background: #e7f1f1;
    }

    .map-badges {
      display: inline-flex;
      gap: 3px;
      align-items: center;
    }

    .map-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      font-size: 9px;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--muted);
      font-weight: 600;
    }

    .map-badge.decision {
      border-color: #c98f8f;
      color: #8c2f2f;
      background: #fbecec;
    }

    .map-badge.creative {
      border-color: #93afcf;
      color: #24466b;
      background: #e9f1fb;
    }

    .map-badge.conflict {
      border-color: #d8b36d;
      color: #7c5a1f;
      background: #fff5de;
    }

    .docs-toolbar {
      display: grid;
      grid-template-columns: minmax(200px, 1fr) minmax(180px, 240px);
      gap: 12px;
      align-items: end;
      margin-bottom: 8px;
    }

    .doc-meta {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .doc-content {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      background: #fff;
      max-height: calc(100vh - 280px);
      overflow: auto;
      font-size: 13px;
      line-height: 1.5;
    }

    .doc-content h1,
    .doc-content h2,
    .doc-content h3,
    .doc-content h4 {
      font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
    }

    .doc-content h1 { font-size: 22px; margin: 16px 0 8px; }
    .doc-content h2 { font-size: 18px; margin: 14px 0 6px; }
    .doc-content h3 { font-size: 16px; margin: 12px 0 6px; }
    .doc-content h4 { font-size: 14px; margin: 10px 0 6px; }

    .doc-content p { margin: 8px 0; }
    .doc-content ul,
    .doc-content ol { padding-left: 20px; margin: 8px 0; }
    .doc-content li { margin-bottom: 4px; }
    .doc-content pre {
      background: #f7f5f0;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      overflow: auto;
      font-size: 12px;
    }
    .doc-content code {
      background: #f7f5f0;
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 1px 4px;
      font-size: 12px;
    }
    .doc-content a {
      color: var(--accent);
      text-decoration: none;
    }
    .doc-content a:hover {
      text-decoration: underline;
    }
    .doc-content blockquote {
      border-left: 3px solid var(--border);
      padding-left: 10px;
      color: var(--muted);
      margin: 8px 0;
    }

    .doc-open {
      margin-left: 6px;
      padding: 2px 6px;
      font-size: 11px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #fff;
      cursor: pointer;
    }

    svg text {
      font-size: 11px;
    }

    .node {
      cursor: pointer;
    }

    .node:hover rect {
      stroke-width: 2;
    }

    .node.selected rect {
      stroke: var(--accent-2);
      stroke-width: 2;
    }

    .node.dim {
      opacity: 0.2;
    }

    .node.upstream rect {
      stroke: var(--accent-2);
      stroke-width: 1.5;
      stroke-dasharray: 4 3;
    }

    .node.downstream rect {
      stroke: var(--accent);
      stroke-width: 1.8;
    }

    .edge {
      stroke: #777;
      stroke-width: 1.4;
    }

    .edge.dim {
      stroke: #cfc6b8;
      stroke-width: 1;
      opacity: 0.35;
    }

    .edge.upstream {
      stroke: var(--accent-2);
      stroke-width: 1.4;
      stroke-dasharray: 4 3;
    }

    .edge.downstream {
      stroke: var(--accent);
      stroke-width: 2;
    }

    .graph-tooltip {
      position: absolute;
      z-index: 2;
      display: none;
      max-width: 280px;
      background: #fff;
      border: 1px solid var(--border);
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      color: var(--ink);
      pointer-events: none;
    }

    .graph-tooltip .title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .graph-tooltip .meta {
      font-size: 11px;
      color: var(--muted);
    }

    .claim-toggles {
      display: flex;
      gap: 12px;
      align-items: center;
      margin: 8px 0;
      font-size: 12px;
      color: var(--muted);
    }

    .claim-toggles input {
      width: auto;
      margin-right: 4px;
    }

    .drafts {
      margin-top: 20px;
    }

    .draft-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .draft-tab {
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      background: #fff;
      font-size: 13px;
    }

    .draft-tab.active {
      background: var(--accent-2);
      color: #fff;
      border-color: var(--accent-2);
    }

    .draft-pane {
      display: none;
    }

    .draft-pane.active {
      display: block;
    }

    .draft-output {
      min-height: 180px;
      font-family: "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: 12px;
    }

    .picker {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      max-height: 160px;
      overflow: auto;
      background: #fff;
      font-size: 12px;
    }

    .picker-item {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      margin-bottom: 6px;
    }

    .picker-item:last-child {
      margin-bottom: 0;
    }

    .footer {
      margin-top: 24px;
      color: var(--muted);
      font-size: 12px;
    }

    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <h1>REE Claims Explorer</h1>
    <div class="subtitle">Browse claims, dependencies, and conflicts. Generate intake and resolution drafts.</div>
    <div class="subtitle" style="margin-top:6px;">Auto-updates require a local server (not file://). Run: <code>python3 -m http.server</code> from repo root.</div>
    <div class="subtitle" id="refreshStatus" style="margin-top:6px;">Last refreshed: --</div>
    <div id="stats" class="stats"></div>
  </header>

  <main>
    <div id="errorBanner" class="error-banner"></div>

    <section class="controls">
      <div>
        <label for="search">Search</label>
        <input id="search" type="text" placeholder="ID, subject, type..." />
      </div>
      <div>
        <label for="typeFilter">Type</label>
        <select id="typeFilter"></select>
      </div>
      <div>
        <label for="statusFilter">Status</label>
        <select id="statusFilter"></select>
      </div>
      <div>
        <label for="subjectFilter">Subject (contains)</label>
        <input id="subjectFilter" type="text" list="subjectList" placeholder="ethics.persistence" />
        <datalist id="subjectList"></datalist>
      </div>
      <div>
        <label for="viewToggle">View</label>
        <div class="buttons">
          <button id="listViewBtn" class="primary">List</button>
          <button id="graphViewBtn">Graph</button>
          <button id="docsViewBtn">Docs</button>
          <button id="mapViewBtn">Map</button>
          <button id="governanceViewBtn">Governance</button>
        </div>
      </div>
      <div>
        <label for="includeDeps">Graph Options</label>
        <div class="buttons">
          <label style="display:flex;align-items:center;gap:6px;font-size:12px;">
            <input id="includeDeps" type="checkbox" checked />
            Include dependencies
          </label>
        </div>
      </div>
      <div>
        <label>Actions</label>
        <div class="buttons">
          <button id="clearFilters" class="ghost">Clear Filters</button>
        </div>
      </div>
    </section>

    <section id="viewWrap" class="layout">
      <div id="leftWrap">
        <div id="listWrap" class="panel table-panel">
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>Type</th>
                <th>Status</th>
                <th>Subject</th>
                <th>Depends On</th>
                <th>Conflicts</th>
                <th>Thought</th>
                <th>Conflict</th>
              </tr>
            </thead>
            <tbody id="claimsTable"></tbody>
          </table>
        </div>
        <div id="graphWrap" class="panel graph-panel-wrap">
        <div class="meta" id="graphMeta">Dependency graph (filtered set)</div>
        <div class="graph-controls">
          <div class="control-group">
            <div class="control-label">Graph focus</div>
            <div class="buttons">
              <label title="Focus on a single selected claim.">
                <input type="radio" name="graphFocus" value="anchor" checked />
                Anchor
              </label>
              <label title="Focus on the selected workset claims.">
                <input type="radio" name="graphFocus" value="workset" />
                Workset
              </label>
            </div>
          </div>
          <div class="control-group workset-only">
            <div class="control-label">Workset scope</div>
            <div class="buttons">
              <label title="Show anything connected to any selected claim; broad context.">
                <input type="radio" name="worksetScope" value="union" checked />
                Union
              </label>
              <label title="Show only nodes connected to all selected claims; shared core.">
                <input type="radio" name="worksetScope" value="intersection" />
                Intersection
              </label>
              <label title="Show selected claims plus minimal dependency paths between them.">
                <input type="radio" name="worksetScope" value="connect" />
                Connect
              </label>
            </div>
          </div>
          <div class="control-group workset-only">
            <div class="control-label">Workset source</div>
            <div class="buttons">
              <label title="Use Thought selections from the list.">
                <input type="checkbox" id="worksetThought" checked />
                Thought
              </label>
              <label title="Use Conflict selections from the list.">
                <input type="checkbox" id="worksetConflict" checked />
                Conflict
              </label>
            </div>
          </div>
        </div>
          <div class="graph-panel" id="graphPanel"></div>
          <div class="graph-tooltip" id="graphTooltip"></div>
        </div>
        <div id="docsWrap" class="panel docs-wrap">
          <div class="docs-toolbar">
            <div>
              <label for="docSelect">Document</label>
              <select id="docSelect"></select>
            </div>
            <div>
              <label for="docSearch">Filter</label>
              <input id="docSearch" type="text" placeholder="Filter docs..." />
            </div>
          </div>
          <div id="docMeta" class="doc-meta"></div>
          <div id="docContent" class="doc-content"></div>
        </div>
        <div id="mapWrap" class="panel map-wrap">
          <div class="meta">Subsystem map (filtered set)</div>
          <div class="map-toolbar">
            <label title="Choose map interpretation lens.">
              Lens
              <select id="mapLens">
                <option value="atlas" selected>Subsystem Atlas</option>
                <option value="governance_heat">Governance Heat</option>
              </select>
            </label>
            <label title="Hide claims with zero applicable evidence in the current architecture epoch.">
              <input type="checkbox" id="mapEpochOnly" checked />
              Current Epoch Only
            </label>
            <label title="Show only claims currently touched by governance queues (conflict/decision/structure).">
              <input type="checkbox" id="mapGovernanceOnly" />
              Governance-Signaled Only
            </label>
          </div>
          <div id="mapMeta" class="map-summary"></div>
          <div id="mapGrid" class="map-grid"></div>
        </div>
        <div id="governanceWrap" class="panel governance-wrap">
          <div class="meta" id="governanceMeta">Governance cycle dashboard</div>
          <div class="gov-toolbar">
            <label title="Filter claim-centric governance tables to claims with current-epoch applicable evidence.">
              <input type="checkbox" id="govEpochOnly" checked />
              Current Epoch Claims Only
            </label>
          </div>
          <div id="governanceContent" class="gov-empty">Loading governance agenda...</div>
        </div>
      </div>
      <div class="panel detail" id="detailPanel">
        <div id="selectedSummary" class="selected-summary">
          <div class="selected-group">
            <div class="selected-label">Thought claims</div>
            <div id="selectedThought" class="chips"></div>
          </div>
          <div class="selected-group">
            <div class="selected-label">Conflict claims</div>
            <div id="selectedConflict" class="chips"></div>
          </div>
          <div class="selected-group">
            <div class="selected-label">Conflict files</div>
            <div id="selectedConflictFiles" class="chips"></div>
          </div>
        </div>
        <div id="detailContent" class="detail-content">
          <div class="meta">Select a claim to see details.</div>
        </div>
      </div>
    </section>

    <section class="drafts">
      <div class="panel">
        <h2 style="margin-top:0; font-family: Iowan Old Style, Palatino, serif;">Draft Generator</h2>
        <div class="draft-tabs">
          <div class="draft-tab active" data-tab="thought">Thought Intake</div>
          <div class="draft-tab" data-tab="conflict">Conflict Resolution</div>
        </div>

        <div class="draft-pane active" id="thoughtPane">
          <label for="thoughtInput">Thought (free text)</label>
          <textarea id="thoughtInput" rows="6" placeholder="Paste your thought here..."></textarea>
          <div class="meta" style="margin-top:6px;">Uses Thought selections from the claims list above.</div>
          <div class="buttons" style="margin-top:8px;">
            <button id="generateThought" class="primary">Generate Draft</button>
            <button id="copyThought">Copy</button>
            <button id="downloadThought">Download .md</button>
          </div>
          <label for="thoughtOutput" style="margin-top:10px; display:block;">Draft Output</label>
          <textarea id="thoughtOutput" class="draft-output" rows="10" readonly></textarea>
        </div>

        <div class="draft-pane" id="conflictPane">
          <label for="conflictRefs">Conflict reference(s)</label>
          <input id="conflictRefs" type="text" placeholder="docs/conflicts/foo.md, INV-001" />
          <label for="conflictFileList" style="margin-top:8px; display:block;">Select conflict files (optional)</label>
          <div id="conflictFileList" class="picker"></div>
          <div class="meta" style="margin-top:6px;">Uses Conflict selections from the claims list above.</div>
          <label for="conflictDecision" style="margin-top:8px; display:block;">Resolution decision</label>
          <textarea id="conflictDecision" rows="6" placeholder="Describe the resolution..."></textarea>
          <div class="buttons" style="margin-top:8px;">
            <button id="generateConflict" class="primary">Generate Draft</button>
            <button id="copyConflict">Copy</button>
            <button id="downloadConflict">Download .md</button>
          </div>
          <label for="conflictOutput" style="margin-top:10px; display:block;">Draft Output</label>
          <textarea id="conflictOutput" class="draft-output" rows="12" readonly></textarea>
        </div>
      </div>
    </section>

    <div class="footer">Data source: docs/claims/claims.yaml and docs/conflicts/*.md</div>
  </main>

  <script>
    const CLAIMS_URL = './claims.yaml';
    const CONFLICT_INDEX_URL = '../conflicts/README.md';
    const README_URL = '../README.md';
    const GOVERNANCE_AGENDA_URL = '../../evidence/planning/governance_agenda.v1.json';
    const GOVERNANCE_BACKLOG_URL = '../../evidence/planning/evidence_backlog.v1.json';
    const GOVERNANCE_PROPOSALS_URL = '../../evidence/planning/experiment_proposals.v1.json';
    const REFRESH_MS = 60000;

    const CMD_RUN_GOVERNANCE = 'python3 /Users/dgolden/Documents/GitHub/REE_assembly/evidence/planning/scripts/run_governance_cycle.py';
    const CMD_RUN_GOVERNANCE_STRICT = 'python3 /Users/dgolden/Documents/GitHub/REE_assembly/evidence/planning/scripts/run_governance_cycle.py --strict-thoughts';
    const CMD_RECORD_DECISION_TEMPLATE = 'python3 /Users/dgolden/Documents/GitHub/REE_assembly/evidence/experiments/scripts/record_decision.py --claim-id <CLAIM_ID> --recommendation <RECOMMENDATION> --decision-needed \"<DECISION_NEEDED>\" --decision-status approved --selected-option \"<OPTION>\" --rationale \"<RATIONALE>\" --actor dgolden';
    const REPO_ABS_PREFIX = '/Users/dgolden/Documents/GitHub/REE_assembly/';
    const GOVERNANCE_CONTEXT_DOCS = {
      thought_intake: [
        'docs/thoughts/SWEEP_REPORT.md',
        'docs/thoughts/thought_sweep.v1.json',
      ],
      conflict_resolution: [
        'evidence/experiments/conflicts.md',
        'evidence/planning/ARCHITECTURE_GAP_REGISTER.md',
      ],
      architecture_epoch_applicability: [
        'evidence/planning/architecture_epoch_applicability.v1.json',
        'evidence/planning/planning_criteria.v1.yaml',
      ],
      governance_decisions: [
        'evidence/experiments/promotion_demotion_recommendations.md',
        'evidence/decisions/decision_log.v1.jsonl',
      ],
      manual_carryover: [
        'evidence/planning/manual_carryover_items.v1.json',
        'evidence/planning/task_inbox.md',
      ],
      architecture_structure: [
        'evidence/planning/ARCHITECTURE_GAP_REGISTER.md',
        'evidence/planning/structure_review/latest/ACTIVE_INDEX.md',
        'evidence/planning/structure_review/latest/ARCHIVE_INDEX.md',
      ],
      structure_review_dossiers: [
        'evidence/planning/structure_review/latest/ACTIVE_INDEX.md',
        'evidence/planning/structure_review/latest/ARCHIVE_INDEX.md',
      ],
      connectome_literature_pull: [
        'evidence/planning/CONNECTOME_LITERATURE_PULL.md',
        'evidence/planning/connectome_pull_state.v1.json',
      ],
      model_adjudication: [
        'evidence/planning/planning_criteria.v1.yaml',
        'evidence/planning/ARCHITECTURE_GAP_REGISTER.md',
      ],
      adjudication_cascade: [
        'evidence/planning/ADJUDICATION_CASCADE_PATCH_QUEUE.md',
        'evidence/decisions/adjudication_cascade_state.v1.json',
      ],
      evidence_dispatch: [
        'evidence/planning/experiment_proposals.v1.json',
      ],
      maintenance: [
        'evidence/experiments/claim_evidence.v1.json',
        'evidence/experiments/TODOs.md',
      ],
    };

    const FALLBACK_THOUGHT_PROMPT = `You are the AI agent maintaining the REE repository (Codex in this session). I am going to describe a thought, concern, or new understanding about REE in free text.

Your job is to:
1) Infer the scope and affected components.
2) Determine whether this introduces or modifies:
   - an invariant,
   - an architectural commitment,
   - a mechanism hypothesis,
   - or an open question.
3) Update the canonical REE docs incrementally (do NOT refactor the whole repo).
4) Preserve all prior formulations; do not delete or overwrite history.
5) If this thought conflicts with existing claims:
   - represent the conflict explicitly in docs/conflicts/
   - do NOT resolve it.
6) Update the claim registry, glossary (if needed), and changelog.
7) Run an implicit consistency check and surface any new tensions created.

I will now write the thought in natural language.

BEGIN THOUGHT:
<PASTE YOUR THOUGHT HERE>
END THOUGHT`;

    const FALLBACK_CONFLICT_PROMPT = `You are the AI agent maintaining the REE repository (Codex in this session). I am resolving an explicitly documented conflict or fork in the REE documentation.

Your job is to:
1) Locate and read the referenced conflict file(s) in docs/conflicts/.
2) Identify the conflicting claim IDs, their types, scopes, and dependencies.
3) Apply my resolution decision carefully and minimally.
4) Update the canonical documentation, claim registry, and dependency graph to reflect the resolution.
5) Preserve historical record:
   - Do NOT delete superseded claims.
   - Mark them as legacy or deprecated with clear rationale.
6) Ensure the repo is internally consistent after resolution.
7) Surface any new tensions created by this change.
8) Update docs/changelog.md with a clear record of what was resolved and why.

BEGIN CONFLICT RESOLUTION:

Conflict reference(s):
- <PASTE docs/conflicts/*.md PATHS OR CLAIM IDs>

Resolution decision (free text):
<DESCRIBE THE RESOLUTION IN YOUR OWN WORDS>

END CONFLICT RESOLUTION`;

    const DOC_GROUPS = [
      {
        label: 'Architecture',
        docs: [
          { title: 'Overview', path: '../architecture/overview.md' },
          { title: 'E1', path: '../architecture/e1.md' },
          { title: 'E2', path: '../architecture/e2.md' },
          { title: 'E3', path: '../architecture/e3.md' },
          { title: 'L-space', path: '../architecture/l_space.md' },
          { title: 'Control Plane', path: '../architecture/control_plane.md' },
          { title: 'Control Plane Signal Map', path: '../architecture/control_plane_signal_map.md' },
          { title: 'Default Mode', path: '../architecture/default_mode.md' },
          { title: 'Hippocampal Systems', path: '../architecture/hippocampal_systems.md' },
          { title: 'Hippocampal Braid (legacy)', path: '../architecture/hippocampal_braid.md' },
          { title: 'Residue Geometry', path: '../architecture/residue_geometry.md' },
          { title: 'Sensory Stream Tags', path: '../architecture/sensory_stream_tags.md' },
          { title: 'Temporal Dynamics', path: '../architecture/temporal_dynamics.md' },
          { title: 'Mode Manager', path: '../architecture/mode_manager.md' },
          { title: 'Modes of Cognition', path: '../architecture/modes_of_cognition.md' },
          { title: 'Agency Responsibility Flow', path: '../architecture/agency_responsibility_flow.md' },
          { title: 'Trajectory Selection', path: '../architecture/trajectory_selection.md' },
          { title: 'Entities and Binding', path: '../architecture/entities_and_binding.md' },
          { title: 'Precision Control', path: '../architecture/precision_control.md' },
          { title: 'Precision Scoping', path: '../architecture/precision_scoping.md' },
          { title: 'Path Authority and Interrupts', path: '../architecture/path_authority_and_interrupts.md' },
          { title: 'Astrocyte Regulatory Stack', path: '../architecture/astrocyte_regulatory_stack.md' },
          { title: 'Serotonin', path: '../architecture/serotonin.md' },
          { title: 'Language (overview)', path: '../architecture/language.md' },
          { title: 'Sleep (overview)', path: '../architecture/sleep.md' },
          { title: 'Social', path: '../architecture/social.md' },
          { title: 'Why Attention Must Be Fragmented', path: '../architecture/why_attention_must_be_fragmented.md' },
        ],
      },
      {
        label: 'Architecture / Language',
        docs: [
          { title: 'Emergence and Bootstrapping', path: '../architecture/language/emergence_and_bootstrapping.md' },
          { title: 'Language and Learning', path: '../architecture/language/language_and_learning.md' },
          { title: 'Language and Institutions', path: '../architecture/language/language_and_institutions.md' },
          { title: 'Language Failure Modes', path: '../architecture/language/language_failure_modes.md' },
          { title: 'Minimal Signalling Channel', path: '../architecture/language/minimal_signalling_channel.md' },
          { title: 'Trust and Deception', path: '../architecture/language/trust_and_deception.md' },
        ],
      },
      {
        label: 'Architecture / Sleep',
        docs: [
          { title: 'Precision Recalibration', path: '../architecture/sleep/precision_recalibration.md' },
          { title: 'Reality Consolidation', path: '../architecture/sleep/reality_consolidation.md' },
          { title: 'Residue Integration', path: '../architecture/sleep/residue_integration.md' },
        ],
      },
      {
        label: 'Core Docs',
        docs: [
          { title: 'Invariants', path: '../invariants.md' },
          { title: 'Glossary', path: '../glossary.md' },
          { title: 'REE Minimum Spec', path: '../REE_MIN_SPEC.md' },
          { title: 'REE Overview', path: '../REE_overview.md' },
          { title: 'REE Failure Modes', path: '../REE_failure_modes.md' },
        ],
      },
      {
        label: 'Governance / Planning',
        docs: [
          { title: 'Governance Agenda', path: '../../evidence/planning/GOVERNANCE_AGENDA.md' },
          { title: 'Architecture Gap Register', path: '../../evidence/planning/ARCHITECTURE_GAP_REGISTER.md' },
          { title: 'Connectome Literature Pull', path: '../../evidence/planning/CONNECTOME_LITERATURE_PULL.md' },
          { title: 'Planning README', path: '../../evidence/planning/README.md' },
          { title: 'Task Inbox', path: '../../evidence/planning/task_inbox.md' },
          { title: 'Manual Carryover Items', path: '../../evidence/planning/manual_carryover_items.v1.json' },
          { title: 'Planning Criteria', path: '../../evidence/planning/planning_criteria.v1.yaml' },
          { title: 'Structure Review (Active)', path: '../../evidence/planning/structure_review/latest/ACTIVE_INDEX.md' },
          { title: 'Structure Review (Archive)', path: '../../evidence/planning/structure_review/latest/ARCHIVE_INDEX.md' },
          { title: 'Connectome Pull State', path: '../../evidence/planning/connectome_pull_state.v1.json' },
          { title: 'Experiment Proposals', path: '../../evidence/planning/experiment_proposals.v1.json' },
        ],
      },
    ];

    const SUBSYSTEM_MAP_URL = './subsystem_map.yaml';
    let subsystemRules = [];
    const ATLAS_ORDER = [
      'INV',
      'REP',
      'CTL',
      'TRJ',
      'COM',
      'AUT',
      'SOC',
      'LAN',
      'SLP',
      'IMP',
      'META',
      'UNMAPPED',
    ];
    const ATLAS_LABEL = {
      INV: 'INV Foundations',
      REP: 'REP Representation',
      CTL: 'CTL Control Plane',
      TRJ: 'TRJ Trajectory & Residue',
      COM: 'COM Commitment & Responsibility',
      AUT: 'AUT Authority & Verifier',
      SOC: 'SOC Social',
      LAN: 'LAN Language',
      SLP: 'SLP Sleep & Consolidation',
      IMP: 'IMP Implementation & Interfaces',
      META: 'META Docs & Governance',
      UNMAPPED: 'UNMAPPED',
    };
    const SUBJECT_PREFIX_TO_ATLAS = {
      e1: 'REP',
      e2: 'REP',
      e3: 'COM',
      l_space: 'REP',
      latent_predictive_models: 'REP',
      jepa_substrate: 'REP',
      control_plane: 'CTL',
      precision: 'CTL',
      astrocyte: 'CTL',
      attention: 'CTL',
      cognitive_modes: 'CTL',
      temporal: 'CTL',
      default_mode: 'CTL',
      sensory_stream_tags: 'CTL',
      hippocampus: 'TRJ',
      hippocampal: 'TRJ',
      residue: 'TRJ',
      trajectory: 'TRJ',
      commitment: 'COM',
      agency: 'COM',
      responsibility: 'COM',
      agentic_extension: 'COM',
      affect: 'COM',
      provenance: 'AUT',
      entities: 'AUT',
      social: 'SOC',
      emotion: 'SOC',
      care_weights_override_other_harm_veto: 'SOC',
      valence_vs_mu_kappa_overlays: 'SOC',
      selfhood_personality_ethics: 'SOC',
      language: 'LAN',
      terminology: 'LAN',
      sleep: 'SLP',
      interfaces: 'IMP',
      integration: 'IMP',
      roadmap: 'IMP',
      spec: 'IMP',
      invariance: 'INV',
      ethics: 'INV',
      consequence: 'INV',
      coherence: 'INV',
      architecture: 'INV',
      meta: 'META',
      docs: 'META',
      repo: 'META',
      claims: 'META',
      conflicts: 'META',
      failure: 'META',
      failure_modes: 'META',
      examples: 'META',
      migration: 'META',
      overview: 'META',
      refactor: 'META',
      design: 'META',
      developmental: 'META',
      developmental_ordering: 'META',
      wiring: 'META',
      diagrams: 'META',
    };
    const LOCATION_RULES_TO_ATLAS = [
      ['docs/architecture/language/', 'LAN'],
      ['docs/architecture/language.md', 'LAN'],
      ['docs/architecture/social', 'SOC'],
      ['docs/architecture/sleep', 'SLP'],
      ['docs/architecture/agency_responsibility_flow', 'COM'],
      ['docs/architecture/e3', 'COM'],
      ['docs/architecture/path_authority', 'AUT'],
      ['docs/architecture/entities_and_binding', 'AUT'],
      ['docs/architecture/papez_circuit', 'AUT'],
      ['docs/architecture/control_plane', 'CTL'],
      ['docs/architecture/precision', 'CTL'],
      ['docs/architecture/astrocyte', 'CTL'],
      ['docs/architecture/serotonin', 'CTL'],
      ['docs/architecture/temporal', 'CTL'],
      ['docs/architecture/mode', 'CTL'],
      ['docs/architecture/hippocampal', 'TRJ'],
      ['docs/architecture/residue', 'TRJ'],
      ['docs/architecture/trajectory', 'TRJ'],
      ['docs/architecture/e1', 'REP'],
      ['docs/architecture/e2', 'REP'],
      ['docs/architecture/l_space', 'REP'],
      ['docs/architecture/jepa', 'REP'],
      ['docs/architecture/hook_surface', 'IMP'],
      ['docs/invariants', 'INV'],
      ['docs/REE_MIN_SPEC', 'INV'],
      ['docs/claims/', 'META'],
      ['docs/changelog', 'META'],
      ['docs/roadmap', 'META'],
      ['docs/README', 'META'],
    ];

    const els = {
      search: document.getElementById('search'),
      typeFilter: document.getElementById('typeFilter'),
      statusFilter: document.getElementById('statusFilter'),
      subjectFilter: document.getElementById('subjectFilter'),
      subjectList: document.getElementById('subjectList'),
      claimsTable: document.getElementById('claimsTable'),
      listWrap: document.getElementById('listWrap'),
      graphWrap: document.getElementById('graphWrap'),
      docsWrap: document.getElementById('docsWrap'),
      mapWrap: document.getElementById('mapWrap'),
      mapMeta: document.getElementById('mapMeta'),
      mapLens: document.getElementById('mapLens'),
      graphPanel: document.getElementById('graphPanel'),
      graphMeta: document.getElementById('graphMeta'),
      graphTooltip: document.getElementById('graphTooltip'),
      graphFocusRadios: document.querySelectorAll('input[name="graphFocus"]'),
      worksetScopeRadios: document.querySelectorAll('input[name="worksetScope"]'),
      worksetThought: document.getElementById('worksetThought'),
      worksetConflict: document.getElementById('worksetConflict'),
      worksetGroups: document.querySelectorAll('.workset-only'),
      listViewBtn: document.getElementById('listViewBtn'),
      graphViewBtn: document.getElementById('graphViewBtn'),
      docsViewBtn: document.getElementById('docsViewBtn'),
      mapViewBtn: document.getElementById('mapViewBtn'),
      governanceViewBtn: document.getElementById('governanceViewBtn'),
      mapEpochOnly: document.getElementById('mapEpochOnly'),
      mapGovernanceOnly: document.getElementById('mapGovernanceOnly'),
      govEpochOnly: document.getElementById('govEpochOnly'),
      includeDeps: document.getElementById('includeDeps'),
      clearFilters: document.getElementById('clearFilters'),
      stats: document.getElementById('stats'),
      errorBanner: document.getElementById('errorBanner'),
      refreshStatus: document.getElementById('refreshStatus'),
      selectedThought: document.getElementById('selectedThought'),
      selectedConflict: document.getElementById('selectedConflict'),
      selectedConflictFiles: document.getElementById('selectedConflictFiles'),
      detailContent: document.getElementById('detailContent'),
      thoughtInput: document.getElementById('thoughtInput'),
      thoughtOutput: document.getElementById('thoughtOutput'),
      generateThought: document.getElementById('generateThought'),
      copyThought: document.getElementById('copyThought'),
      downloadThought: document.getElementById('downloadThought'),
      conflictRefs: document.getElementById('conflictRefs'),
      conflictFileList: document.getElementById('conflictFileList'),
      conflictDecision: document.getElementById('conflictDecision'),
      conflictOutput: document.getElementById('conflictOutput'),
      generateConflict: document.getElementById('generateConflict'),
      copyConflict: document.getElementById('copyConflict'),
      downloadConflict: document.getElementById('downloadConflict'),
      docSelect: document.getElementById('docSelect'),
      docSearch: document.getElementById('docSearch'),
      docMeta: document.getElementById('docMeta'),
      docContent: document.getElementById('docContent'),
      mapGrid: document.getElementById('mapGrid'),
      governanceWrap: document.getElementById('governanceWrap'),
      governanceMeta: document.getElementById('governanceMeta'),
      governanceContent: document.getElementById('governanceContent'),
    };

    const typeOrder = [
      'invariant',
      'architectural_commitment',
      'mechanism_hypothesis',
      'open_question',
      'implementation_note',
    ];

    let allClaims = [];
    let claimMap = new Map();
    let conflictsMap = {};
    const claimTextCache = new Map();
    const fileCache = new Map();
    let initialized = false;
    let refreshTimer = null;
    let conflictFiles = [];
    const thoughtSelected = new Set();
    const conflictSelectedClaims = new Set();
    const conflictSelectedFiles = new Set();
    let hoverId = null;
    let hoverPoint = null;
    let docsInitialized = false;
    let currentDocUrl = null;
    let docIndex = [];
    let docIndexMap = new Map();
    let governanceAgenda = null;
    let governanceBacklog = null;
    let governanceProposals = null;
    let governanceError = '';
    let governanceLoadedAt = '';
    let governanceLoading = false;

    function showError(message) {
      els.errorBanner.textContent = message;
      els.errorBanner.style.display = 'block';
    }

    function showErrorHtml(html) {
      els.errorBanner.innerHTML = html;
      els.errorBanner.style.display = 'block';
    }

    function hideError() {
      els.errorBanner.style.display = 'none';
    }

    async function fetchText(url) {
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) {
        throw new Error(`Failed to fetch ${url} (${res.status})`);
      }
      return res.text();
    }

    function parseClaimsYaml(text) {
      const normalized = text
        .replace(/\uFEFF/g, '')
        .replace(/\u200B/g, '')
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n');
      const lines = normalized.split('\n');
      const claims = [];
      let cur = null;
      let mode = null;
      const depPattern = /\b(INV|ARC|MECH|IMPL|Q)-\d{3}\b/;

      function pushCur() {
        if (!cur) return;
        if (!cur.depends_on) cur.depends_on = [];
        claims.push(cur);
      }

      function normalizeDep(item) {
        if (!item) return '';
        const stripped = item.replace(/#.*/, '').replace(/[,\]]+$/, '').trim();
        const match = stripped.match(depPattern);
        return match ? match[0] : stripped;
      }

      for (const rawLine of lines) {
        const line = rawLine.replace(/\t/g, '  ');
        const idIndex = line.indexOf('id:');
        const idMatch = line.match(/id:\s*([A-Z]{1,6}-\d{3})/i);
        if (idMatch && idIndex > -1 && idIndex <= 10) {
          pushCur();
          cur = { id: idMatch[1].trim() };
          mode = null;
          continue;
        }
        if (!cur) continue;

        const keyMatch = line.match(/^\s{2,}([a-z_]+):\s*(.*)$/);
        if (keyMatch) {
          const key = keyMatch[1];
          const val = keyMatch[2] || '';
          if (key === 'depends_on') {
            cur.depends_on = [];
            mode = 'depends_on';
            if (val.trim()) {
              const inline = val.replace(/^\[/, '').replace(/\]$/, '');
              inline.split(',').map(s => s.trim()).filter(Boolean).forEach(item => {
                const norm = normalizeDep(item);
                if (norm) cur.depends_on.push(norm);
              });
              mode = null;
            }
            continue;
          }
          if (key === 'source') {
            mode = 'source';
            continue;
          }
          mode = null;
          if (['claim_type', 'subject', 'polarity', 'status', 'location'].includes(key)) {
            cur[key] = val.trim();
          }
          continue;
        }

        const listMatch = line.match(/^\s*-\s*(.+)$/);
        if (listMatch && mode === 'depends_on') {
          const norm = normalizeDep(listMatch[1]);
          if (norm) cur.depends_on.push(norm);
        }
      }

      pushCur();
      if (claims.length) return claims;

      const blocks = normalized.split(/(?=^\s*.*id:\s*[A-Z]{1,6}-\d{3})/mi);
      const fallback = [];
      blocks.forEach(block => {
        const idMatch = block.match(/id:\s*([A-Z]{1,6}-\d{3})/i);
        if (!idMatch) return;
        const c = { id: idMatch[1].trim(), depends_on: [] };
        ['claim_type', 'subject', 'polarity', 'status', 'location'].forEach(key => {
          const km = block.match(new RegExp(`^\\s*${key}:\\s*(.+)$`, 'm'));
          if (km) c[key] = km[1].trim();
        });
        const depLine = block.match(/^\s*depends_on:\s*(.*)$/m);
        if (depLine) {
          const rest = depLine[1].trim();
          if (rest && rest !== '[]') {
            const inline = rest.replace(/^\[/, '').replace(/\]$/, '');
            inline.split(',').map(s => s.trim()).filter(Boolean).forEach(item => {
              const norm = normalizeDep(item);
              if (norm) c.depends_on.push(norm);
            });
          } else if (rest === '') {
            const depItems = block.split('\n');
            let inDeps = false;
            for (const line of depItems) {
              if (/^\s*depends_on:\s*$/.test(line)) { inDeps = true; continue; }
              if (inDeps) {
                if (/^\s{2,}[a-z_]+:/.test(line)) break;
                const m = line.match(/^\s*-\s*(.+)$/);
                if (m) {
                  const norm = normalizeDep(m[1]);
                  if (norm) c.depends_on.push(norm);
                }
              }
            }
          }
        }
        fallback.push(c);
      });
      return fallback;
    }

    function normalizeClaim(c) {
      return {
        id: c.id,
        type: c.claim_type || 'unknown',
        status: c.status || 'unknown',
        subject: c.subject || '',
        polarity: c.polarity || '',
        depends_on: c.depends_on || [],
        location: c.location || '',
      };
    }

    function renderInlineMarkdown(text) {
      const parts = text.split(/(`[^`]+`)/g);
      return parts.map(part => {
        if (part.startsWith('`') && part.endsWith('`')) {
          return `<code>${escapeHtml(part.slice(1, -1))}</code>`;
        }
        let out = escapeHtml(part);
        out = out.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, label, url) => {
          const safeUrl = url.replace(/"/g, '%22');
          return `<a href="${safeUrl}">${label}</a>`;
        });
        out = out.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        out = out.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        return out;
      }).join('');
    }

    function renderMarkdown(text) {
      const normalized = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      const lines = normalized.split('\n');
      const html = [];
      let inCode = false;
      let codeLang = '';
      let codeBuffer = [];
      let listType = null;
      let paragraph = [];
      let inBlockquote = false;
      let blockLines = [];

      function flushParagraph() {
        if (!paragraph.length) return;
        html.push(`<p>${renderInlineMarkdown(paragraph.join(' '))}</p>`);
        paragraph = [];
      }

      function closeList() {
        if (!listType) return;
        html.push(`</${listType}>`);
        listType = null;
      }

      function flushBlockquote() {
        if (!inBlockquote) return;
        html.push(`<blockquote>${renderInlineMarkdown(blockLines.join(' '))}</blockquote>`);
        blockLines = [];
        inBlockquote = false;
      }

      for (const rawLine of lines) {
        const trimmed = rawLine.trim();

        if (trimmed.startsWith('```')) {
          if (inCode) {
            const langClass = codeLang ? ` class="lang-${escapeHtml(codeLang)}"` : '';
            html.push(`<pre><code${langClass}>${escapeHtml(codeBuffer.join('\n'))}</code></pre>`);
            codeBuffer = [];
            codeLang = '';
            inCode = false;
          } else {
            flushParagraph();
            closeList();
            flushBlockquote();
            inCode = true;
            codeLang = trimmed.slice(3).trim();
          }
          continue;
        }

        if (inCode) {
          codeBuffer.push(rawLine);
          continue;
        }

        if (!trimmed) {
          flushParagraph();
          closeList();
          flushBlockquote();
          continue;
        }

        if (trimmed.startsWith('<a id=')) {
          flushParagraph();
          closeList();
          flushBlockquote();
          html.push(trimmed);
          continue;
        }

        const headingMatch = trimmed.match(/^(#{1,6})\s+(.*)$/);
        if (headingMatch) {
          flushParagraph();
          closeList();
          flushBlockquote();
          const level = headingMatch[1].length;
          const textContent = headingMatch[2];
          html.push(`<h${level}>${renderInlineMarkdown(textContent)}</h${level}>`);
          continue;
        }

        if (/^---+$/.test(trimmed)) {
          flushParagraph();
          closeList();
          flushBlockquote();
          html.push('<hr />');
          continue;
        }

        if (trimmed.startsWith('>')) {
          flushParagraph();
          closeList();
          inBlockquote = true;
          blockLines.push(trimmed.replace(/^>\s?/, ''));
          continue;
        } else if (inBlockquote) {
          flushBlockquote();
        }

        const listMatch = trimmed.match(/^(\d+\.|[-*+])\s+(.*)$/);
        if (listMatch) {
          flushParagraph();
          flushBlockquote();
          const type = /^\d+\./.test(listMatch[1]) ? 'ol' : 'ul';
          if (listType && listType !== type) {
            closeList();
          }
          if (!listType) {
            listType = type;
            html.push(`<${type}>`);
          }
          html.push(`<li>${renderInlineMarkdown(listMatch[2])}</li>`);
          continue;
        }

        paragraph.push(trimmed);
      }

      if (inCode) {
        const langClass = codeLang ? ` class="lang-${escapeHtml(codeLang)}"` : '';
        html.push(`<pre><code${langClass}>${escapeHtml(codeBuffer.join('\n'))}</code></pre>`);
      }

      flushParagraph();
      closeList();
      flushBlockquote();
      return html.join('\n');
    }

    function escapeHtml(text) {
      if (!text) return '';
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function updateRefreshStatus() {
      if (!els.refreshStatus) return;
      const now = new Date();
      els.refreshStatus.textContent = `Last refreshed: ${now.toLocaleTimeString()}`;
    }

    function buildDocIndex() {
      docIndex = [];
      docIndexMap = new Map();
      DOC_GROUPS.forEach(group => {
        group.docs.forEach(doc => {
          const url = doc.path.match(/^https?:\/\//)
            ? doc.path
            : new URL(doc.path, window.location.href).toString();
          const entry = {
            group: group.label,
            title: doc.title,
            path: doc.path,
            url,
          };
          docIndex.push(entry);
          docIndexMap.set(url, entry);
        });
      });
    }

    function escapeRegex(text) {
      return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function compileSubsystemRules(entries) {
      const rules = [];
      (entries || []).forEach(entry => {
        if (!entry || !entry.key || !entry.patterns) return;
        const patterns = entry.patterns.map(p => String(p)).filter(Boolean);
        const regexes = patterns.map(pattern => {
          if (pattern.endsWith('/')) {
            const base = escapeRegex(pattern).replace(/\/$/, '');
            return new RegExp(`^${base}`);
          }
          return new RegExp(`^${escapeRegex(pattern)}$`);
        });
        rules.push({ key: entry.key, patterns, regexes });
      });
      return rules;
    }

    function parseSubsystemMap(text) {
      const normalized = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      const lines = normalized.split('\n');
      const entries = [];
      let cur = null;
      let inPatterns = false;
      lines.forEach(raw => {
        const trimmed = raw.trim();
        if (!trimmed || trimmed.startsWith('#')) return;
        if (trimmed.startsWith('- key:')) {
          if (cur) entries.push(cur);
          cur = { patterns: [] };
          inPatterns = false;
          const keyMatch = trimmed.match(/^-\\s+key:\\s*(.+)$/);
          if (keyMatch) cur.key = keyMatch[1].trim();
          return;
        }
        if (!cur) return;
        if (trimmed.startsWith('key:')) {
          cur.key = trimmed.split(':', 2)[1].trim();
          return;
        }
        if (trimmed.startsWith('patterns:')) {
          cur.patterns = [];
          inPatterns = true;
          return;
        }
        if (inPatterns) {
          const patMatch = trimmed.match(/^-\\s+(.+)$/);
          if (patMatch) {
            cur.patterns.push(patMatch[1].trim());
          }
        }
      });
      if (cur) entries.push(cur);
      return entries;
    }

    async function loadSubsystemMap() {
      try {
        const text = await fetchText(SUBSYSTEM_MAP_URL);
        const parsed = parseSubsystemMap(text);
        subsystemRules = compileSubsystemRules(parsed);
      } catch (_) {
        subsystemRules = [];
      }
    }

    function getSubsystemKey(claim) {
      if (!claim || !claim.location) return 'Unmapped';
      const path = claim.location.split('#')[0];
      const rules = subsystemRules || [];
      for (const rule of rules) {
        const regexes = rule.regexes || [];
        for (const re of regexes) {
          if (re.test(path)) return rule.key;
        }
      }
      return 'Unmapped';
    }

    function atlasKeyFromSubject(claim) {
      const subject = String((claim && claim.subject) || '').trim().toLowerCase();
      if (!subject) return '';
      const prefix = subject.split('.')[0] || '';
      return SUBJECT_PREFIX_TO_ATLAS[prefix] || '';
    }

    function atlasKeyFromLocation(claim) {
      const path = String((claim && claim.location) || '').split('#')[0].toLowerCase();
      if (!path) return '';
      for (const [needle, key] of LOCATION_RULES_TO_ATLAS) {
        if (path.includes(String(needle).toLowerCase())) return key;
      }
      return '';
    }

    function atlasGroupForClaim(claim) {
      if (!claim) return { key: 'UNMAPPED', label: ATLAS_LABEL.UNMAPPED, reason: 'missing_claim' };
      const bySubject = atlasKeyFromSubject(claim);
      if (bySubject) {
        return { key: bySubject, label: ATLAS_LABEL[bySubject] || bySubject, reason: `subject:${claim.subject}` };
      }
      const byLocation = atlasKeyFromLocation(claim);
      if (byLocation) {
        return { key: byLocation, label: ATLAS_LABEL[byLocation] || byLocation, reason: `location:${claim.location}` };
      }
      const mapped = getSubsystemKey(claim);
      if (mapped && mapped !== 'Unmapped') {
        const token = String(mapped).toLowerCase();
        const fallback = (
          token.includes('language') ? 'LAN'
          : token.includes('social') ? 'SOC'
          : token.includes('sleep') ? 'SLP'
          : token.includes('hippocamp') || token.includes('residue') || token.includes('trajectory') ? 'TRJ'
          : token.includes('agency') || token === 'e3' ? 'COM'
          : token.includes('authority') || token.includes('entities') || token.includes('papez') ? 'AUT'
          : token.includes('control') || token.includes('precision') || token.includes('serotonin') || token.includes('mode') ? 'CTL'
          : token === 'e1' || token === 'e2' || token.includes('l-space') || token.includes('jepa') ? 'REP'
          : token.includes('invariant') ? 'INV'
          : token.includes('hook') ? 'IMP'
          : 'META'
        );
        return { key: fallback, label: ATLAS_LABEL[fallback] || fallback, reason: `fallback:${mapped}` };
      }
      if (claim.type === 'invariant') {
        return { key: 'INV', label: ATLAS_LABEL.INV, reason: 'claim_type:invariant' };
      }
      if (claim.type === 'implementation_note') {
        return { key: 'IMP', label: ATLAS_LABEL.IMP, reason: 'claim_type:implementation_note' };
      }
      return { key: 'UNMAPPED', label: ATLAS_LABEL.UNMAPPED, reason: 'no_subject_or_location_rule' };
    }

    function buildConflictRatioMap(checkpoints) {
      const ratios = new Map();
      const rows = checkpoints && checkpoints.conflict_resolution && Array.isArray(checkpoints.conflict_resolution.items)
        ? checkpoints.conflict_resolution.items
        : [];
      rows.forEach(row => {
        const claimId = extractClaimIdFromItem(row);
        if (!claimId) return;
        const ratio = Number(row.conflict_ratio || 0);
        if (!Number.isNaN(ratio)) ratios.set(claimId, ratio);
      });
      return ratios;
    }

    function governancePressureScore(claimId, signals, epochMap, conflictRatios) {
      let score = 0;
      if (signals.decisionClaims.has(claimId)) score += 2.0;
      if (signals.creativeClaims.has(claimId)) score += 1.6;
      if (signals.conflictClaims.has(claimId)) score += 1.4;
      const ratio = Number(conflictRatios.get(claimId) || 0);
      if (ratio > 0) score += Math.min(1.5, ratio * 1.5);
      const epochSlot = epochMap.get(claimId);
      if (epochSlot) {
        const staleRatio = Number(epochSlot.stale_ratio || 0);
        if (staleRatio > 0.4) score += 0.6;
      }
      return score;
    }

    function statusSummary(claims) {
      const counts = {};
      claims.forEach(c => {
        const status = c.status || 'unknown';
        counts[status] = (counts[status] || 0) + 1;
      });
      const order = ['stable', 'active', 'provisional', 'candidate', 'legacy', 'unknown'];
      return order.filter(k => counts[k]).map(k => `${k} ${counts[k]}`).join(' \u2022 ');
    }

    function renderMap() {
      if (!els.mapGrid) return;
      const checkpoints = governanceAgenda && governanceAgenda.checkpoints
        ? governanceAgenda.checkpoints
        : {};
      const epochMap = buildEpochApplicabilityMap(checkpoints);
      const signals = buildGovernanceClaimSignals(checkpoints);
      const conflictRatios = buildConflictRatioMap(checkpoints);
      const lens = els.mapLens ? String(els.mapLens.value || 'atlas') : 'atlas';
      const epochOnly = els.mapEpochOnly ? !!els.mapEpochOnly.checked : true;
      const governanceOnly = els.mapGovernanceOnly ? !!els.mapGovernanceOnly.checked : false;

      let filtered = applyFilters();
      if (epochOnly) {
        filtered = filtered.filter(c => isCurrentEpochClaim(c.id, epochMap));
      }
      if (governanceOnly) {
        filtered = filtered.filter(c => {
          return signals.decisionClaims.has(c.id)
            || signals.conflictClaims.has(c.id)
            || signals.creativeClaims.has(c.id);
        });
      }

      const groups = new Map();
      filtered.forEach(c => {
        const atlas = atlasGroupForClaim(c);
        const key = atlas.key;
        if (!groups.has(key)) {
          groups.set(key, {
            key,
            label: atlas.label || ATLAS_LABEL[key] || key,
            claims: [],
            decision: 0,
            conflict: 0,
            creative: 0,
            pressure_total: 0,
          });
        }
        const hasDecision = signals.decisionClaims.has(c.id);
        const hasConflict = signals.conflictClaims.has(c.id);
        const hasCreative = signals.creativeClaims.has(c.id);
        const pressure = governancePressureScore(c.id, signals, epochMap, conflictRatios);
        const slot = groups.get(key);
        slot.claims.push({
          claim: c,
          atlas,
          hasDecision,
          hasConflict,
          hasCreative,
          pressure,
          staleOnly: !isCurrentEpochClaim(c.id, epochMap),
        });
        if (hasDecision) slot.decision += 1;
        if (hasConflict) slot.conflict += 1;
        if (hasCreative) slot.creative += 1;
        slot.pressure_total += pressure;
      });
      const keys = Array.from(groups.keys()).sort((a, b) => {
        if (lens === 'governance_heat') {
          const as = groups.get(a);
          const bs = groups.get(b);
          const av = as && as.claims.length ? as.pressure_total / as.claims.length : 0;
          const bv = bs && bs.claims.length ? bs.pressure_total / bs.claims.length : 0;
          if (bv !== av) return bv - av;
        }
        const ai = ATLAS_ORDER.indexOf(a);
        const bi = ATLAS_ORDER.indexOf(b);
        if (ai === -1 && bi === -1) return String(a).localeCompare(String(b));
        if (ai === -1) return 1;
        if (bi === -1) return -1;
        return ai - bi;
      });

      els.mapGrid.innerHTML = '';
      let decisionCount = 0;
      let conflictCount = 0;
      let creativeCount = 0;
      keys.forEach(key => {
        const group = groups.get(key);
        if (!group || !group.claims.length) return;
        const claims = group.claims.slice();
        if (lens === 'governance_heat') {
          claims.sort((a, b) => {
            if (b.pressure !== a.pressure) return b.pressure - a.pressure;
            return a.claim.id.localeCompare(b.claim.id);
          });
        } else {
          claims.sort((a, b) => a.claim.id.localeCompare(b.claim.id));
        }

        const avgPressure = group.claims.length
          ? group.pressure_total / group.claims.length
          : 0;
        const card = document.createElement('div');
        card.className = 'map-card';
        if (lens === 'governance_heat') {
          if (avgPressure >= 3.2) card.classList.add('heat-high');
          else if (avgPressure >= 1.8) card.classList.add('heat-medium');
          else card.classList.add('heat-low');
        }
        const title = document.createElement('h3');
        title.textContent = group.label;
        const meta = document.createElement('div');
        meta.className = 'map-meta';
        const statusText = statusSummary(claims.map(entry => entry.claim));
        const signalText = `D ${group.decision}  C ${group.conflict}  I ${group.creative}`;
        if (lens === 'governance_heat') {
          meta.textContent = `Total ${claims.length}  Heat ${avgPressure.toFixed(2)}  ${signalText}` + (statusText ? `  ${statusText}` : '');
        } else {
          meta.textContent = `Total ${claims.length}` + (statusText ? `  ${statusText}` : '') + `  ${signalText}`;
        }
        const chips = document.createElement('div');
        chips.className = 'map-chips';
        claims.forEach(entry => {
          const c = entry.claim;
          const hasDecision = entry.hasDecision;
          const hasConflict = entry.hasConflict;
          const hasCreative = entry.hasCreative;
          if (hasDecision) decisionCount += 1;
          if (hasConflict) conflictCount += 1;
          if (hasCreative) creativeCount += 1;

          const chip = document.createElement('span');
          chip.className = 'map-chip';
          if (hasDecision) chip.classList.add('signal-decision');
          if (hasConflict) chip.classList.add('signal-conflict');
          if (hasCreative) chip.classList.add('signal-creative');
          if (entry.staleOnly) chip.classList.add('stale-only');
          if (selectedId === c.id) chip.classList.add('selected');
          const flags = [];
          if (hasDecision) flags.push('decision_queue');
          if (hasConflict) flags.push('conflict_queue');
          if (hasCreative) flags.push('creative_structure_review');
          if (entry.staleOnly) flags.push('stale_only');
          flags.push(entry.atlas.reason);
          chip.title = flags.length ? `${c.id}: ${flags.join(', ')}` : c.id;

          const label = document.createElement('span');
          label.textContent = c.id;
          chip.appendChild(label);

          const badges = document.createElement('span');
          badges.className = 'map-badges';
          if (hasDecision) {
            const b = document.createElement('span');
            b.className = 'map-badge decision';
            b.textContent = 'D';
            b.title = 'Human decision queue';
            badges.appendChild(b);
          }
          if (hasCreative) {
            const b = document.createElement('span');
            b.className = 'map-badge creative';
            b.textContent = 'I';
            b.title = 'Human inspiration / generative design input';
            badges.appendChild(b);
          }
          if (hasConflict) {
            const b = document.createElement('span');
            b.className = 'map-badge conflict';
            b.textContent = 'C';
            b.title = 'Conflict queue';
            badges.appendChild(b);
          }
          if (lens === 'governance_heat') {
            const b = document.createElement('span');
            b.className = 'map-badge';
            b.textContent = `${Math.round(entry.pressure)}`;
            b.title = `Governance pressure score: ${entry.pressure.toFixed(2)}`;
            badges.appendChild(b);
          }
          if (badges.childNodes.length) chip.appendChild(badges);

          chip.addEventListener('click', () => selectClaim(c.id));
          chips.appendChild(chip);
        });
        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(chips);
        els.mapGrid.appendChild(card);
      });

      if (els.mapMeta) {
        const tokens = [
          `Lens: ${lens === 'governance_heat' ? 'Governance Heat' : 'Subsystem Atlas'}`,
          `Claims shown: ${filtered.length}`,
          `Subsystems shown: ${keys.length}`,
          `Decision-signaled: ${decisionCount}`,
          `Creative-signaled: ${creativeCount}`,
          `Conflict-signaled: ${conflictCount}`,
        ];
        if (epochOnly) tokens.push('Epoch filter: ON');
        if (governanceOnly) tokens.push('Governance filter: ON');
        els.mapMeta.textContent = tokens.join(' | ');
      }
    }

    async function fetchJson(url) {
      const text = await fetchText(url);
      return JSON.parse(text);
    }

    function stripTicks(value) {
      if (value === null || value === undefined) return '';
      return String(value).replace(/`/g, '');
    }

    function toCellText(value) {
      if (Array.isArray(value)) return value.map(v => stripTicks(v)).join(', ');
      if (value === null || value === undefined) return '';
      if (typeof value === 'object') return JSON.stringify(value);
      return stripTicks(value);
    }

    function normalizeClaimId(value) {
      if (value === null || value === undefined) return '';
      const match = stripTicks(value).match(/\b(INV|ARC|MECH|IMPL|Q)-\d{3}\b/);
      return match ? match[0] : '';
    }

    function repoRelativePath(location) {
      if (!location) return '';
      let path = stripTicks(location).trim();
      if (!path) return '';
      if (path.match(/^https?:\/\//)) return path;
      if (path.startsWith(REPO_ABS_PREFIX)) {
        path = path.slice(REPO_ABS_PREFIX.length);
      } else {
        const marker = '/REE_assembly/';
        const markerIdx = path.indexOf(marker);
        if (markerIdx !== -1) path = path.slice(markerIdx + marker.length);
      }
      if (path.startsWith('./') || path.startsWith('../') || path.startsWith('#')) return path;
      if (path.startsWith('/')) path = path.slice(1);
      if (path.startsWith('docs/')) return '../' + path.slice(5);
      return '../../' + path;
    }

    function checkpointLabel(key) {
      if (!key) return '';
      return key.replace(/_/g, ' ');
    }

    function collectCheckpointContextDocs(checkpointKey, checkpointData) {
      const docs = new Set((GOVERNANCE_CONTEXT_DOCS[checkpointKey] || []).map(stripTicks));
      const pathFields = ['queue_path', 'patch_queue_path', 'report_path', 'index_path', 'active_index_path', 'archive_index_path', 'source_path'];
      pathFields.forEach(field => {
        const value = checkpointData && checkpointData[field];
        if (value) docs.add(stripTicks(value));
      });
      const itemPathFields = ['dossier_md_path'];
      const items = checkpointData && Array.isArray(checkpointData.items) ? checkpointData.items : [];
      items.slice(0, 10).forEach(item => {
        itemPathFields.forEach(field => {
          if (item && item[field]) docs.add(stripTicks(item[field]));
        });
      });
      return Array.from(docs);
    }

    function renderContextLinks(paths) {
      if (!paths || !paths.length) return '';
      return `<div class="gov-context-links">${paths.map(path => {
        const href = repoRelativePath(path);
        const label = stripTicks(path).replace(REPO_ABS_PREFIX, '');
        return `<a class="gov-link-chip" href="${escapeHtml(href)}" target="_blank" rel="noopener">${escapeHtml(label)}</a>`;
      }).join('')}</div>`;
    }

    function renderCheckpointMeta(checkpointKey, checkpointData) {
      const prompt = checkpointData && checkpointData.prompt
        ? `<div class="gov-meta">${escapeHtml(checkpointData.prompt)}</div>`
        : '';
      const contextDocs = collectCheckpointContextDocs(checkpointKey, checkpointData);
      const contextLinks = renderContextLinks(contextDocs);
      return `${prompt}${contextLinks}`;
    }

    function renderClaimCell(rawClaimId) {
      const claimId = normalizeClaimId(rawClaimId);
      if (!claimId) return escapeHtml(toCellText(rawClaimId)) || '-';
      const claim = claimMap.get(claimId);
      if (!claim) return `<code>${escapeHtml(claimId)}</code>`;
      const subject = claim.subject ? escapeHtml(claim.subject) : '';
      const type = claim.type ? escapeHtml(claim.type.replace(/_/g, ' ')) : '';
      const loc = claim.location ? repoRelativePath(claim.location) : '';
      const locHtml = loc
        ? `<div class="gov-claim-meta"><a href="${escapeHtml(loc)}" target="_blank" rel="noopener">spec anchor</a></div>`
        : '';
      return `
        <div class="gov-claim-cell">
          <div><code>${escapeHtml(claimId)}</code></div>
          ${subject ? `<div>${subject}</div>` : ''}
          ${type ? `<div class="gov-claim-meta">${type}</div>` : ''}
          ${locHtml}
        </div>
      `;
    }

    function extractClaimIdFromItem(item) {
      if (!item || typeof item !== 'object') return '';
      return normalizeClaimId(item.claim_id || item.id || item.claim || '');
    }

    function buildEpochApplicabilityMap(checkpoints) {
      const out = new Map();
      const epoch = checkpoints && checkpoints.architecture_epoch_applicability
        ? checkpoints.architecture_epoch_applicability
        : {};
      const rows = Array.isArray(epoch.claims_with_stale_entries)
        ? epoch.claims_with_stale_entries
        : [];
      rows.forEach(row => {
        const claimId = normalizeClaimId(row.claim_id);
        if (!claimId) return;
        const applicable = Number(row.applicable_entries || 0);
        const stale = Number(row.stale_entries || 0);
        out.set(claimId, {
          applicable_entries: applicable,
          stale_entries: stale,
          stale_ratio: Number(row.stale_ratio || 0),
          current_epoch_only: applicable > 0,
        });
      });
      return out;
    }

    function isCurrentEpochClaim(claimId, epochMap) {
      const normalized = normalizeClaimId(claimId);
      if (!normalized) return true;
      if (!epochMap || !epochMap.size) return true;
      const slot = epochMap.get(normalized);
      if (!slot) return true;
      return Number(slot.applicable_entries || 0) > 0;
    }

    function filterRowsByCurrentEpoch(rows, epochMap, enabled) {
      if (!enabled) return rows || [];
      const list = Array.isArray(rows) ? rows : [];
      return list.filter(row => isCurrentEpochClaim(extractClaimIdFromItem(row), epochMap));
    }

    function buildGovernanceClaimSignals(checkpoints) {
      const decisionClaims = new Set();
      const conflictClaims = new Set();
      const creativeClaims = new Set();

      const decisionItems = checkpoints && checkpoints.governance_decisions && Array.isArray(checkpoints.governance_decisions.items)
        ? checkpoints.governance_decisions.items
        : [];
      decisionItems.forEach(item => {
        const claimId = extractClaimIdFromItem(item);
        if (claimId) decisionClaims.add(claimId);
      });

      const conflictItems = checkpoints && checkpoints.conflict_resolution && Array.isArray(checkpoints.conflict_resolution.items)
        ? checkpoints.conflict_resolution.items
        : [];
      conflictItems.forEach(item => {
        const claimId = extractClaimIdFromItem(item);
        if (claimId) conflictClaims.add(claimId);
      });

      const structureItems = checkpoints && checkpoints.architecture_structure && Array.isArray(checkpoints.architecture_structure.consider_new_structure)
        ? checkpoints.architecture_structure.consider_new_structure
        : [];
      structureItems.forEach(item => {
        const claimId = extractClaimIdFromItem(item);
        if (claimId) creativeClaims.add(claimId);
      });

      return { decisionClaims, conflictClaims, creativeClaims };
    }

    function stalenessBadge(generatedAtUtc) {
      if (!generatedAtUtc) return { label: 'unknown', cls: 'old' };
      const then = new Date(generatedAtUtc);
      if (Number.isNaN(then.getTime())) return { label: 'unknown', cls: 'old' };
      const ageMin = (Date.now() - then.getTime()) / 60000;
      if (ageMin <= 120) return { label: `fresh (${Math.round(ageMin)}m)`, cls: 'fresh' };
      if (ageMin <= 1440) return { label: `stale (${Math.round(ageMin / 60)}h)`, cls: 'stale' };
      return { label: `old (${Math.round(ageMin / 1440)}d)`, cls: 'old' };
    }

    function renderGovTable(rows, columns, emptyText) {
      if (!rows || !rows.length) {
        return `<div class="gov-empty">${escapeHtml(emptyText || 'No items')}</div>`;
      }
      const head = columns.map(col => `<th>${escapeHtml(col.label)}</th>`).join('');
      const body = rows.map(row => {
        const cells = columns.map(col => {
          if (col.render) {
            const rendered = col.render(row[col.key], row);
            return `<td>${rendered || '-'}</td>`;
          }
          const raw = col.format ? col.format(row[col.key], row) : row[col.key];
          return `<td>${escapeHtml(toCellText(raw)) || '-'}</td>`;
        }).join('');
        return `<tr>${cells}</tr>`;
      }).join('');
      return `<table class="gov-table"><thead><tr>${head}</tr></thead><tbody>${body}</tbody></table>`;
    }

    function commandRowsHtml() {
      const rows = [
        { label: 'Run governance cycle', cmd: CMD_RUN_GOVERNANCE },
        { label: 'Run strict governance cycle', cmd: CMD_RUN_GOVERNANCE_STRICT },
        { label: 'Record decision (template)', cmd: CMD_RECORD_DECISION_TEMPLATE },
      ];
      return rows.map((row, idx) => `
        <div class="command-row">
          <div class="meta">${escapeHtml(row.label)}</div>
          <code>${escapeHtml(row.cmd)}</code>
          <button class="ghost" data-copy-cmd="${escapeHtml(row.cmd)}" data-copy-id="cmd-${idx}">Copy Command</button>
        </div>
      `).join('');
    }

    async function copyText(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
        return;
      }
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      ta.remove();
    }

    function wireGovernanceCommandButtons() {
      if (!els.governanceContent) return;
      els.governanceContent.querySelectorAll('button[data-copy-cmd]').forEach(btn => {
        btn.addEventListener('click', async () => {
          const cmd = btn.getAttribute('data-copy-cmd') || '';
          if (!cmd) return;
          const status = els.governanceContent.querySelector('#governanceCopyStatus');
          try {
            await copyText(cmd);
            if (status) status.textContent = 'Command copied to clipboard.';
          } catch (_) {
            if (status) status.textContent = 'Copy failed. Select command text manually.';
          }
        });
      });
    }

    async function refreshGovernanceData() {
      governanceLoading = true;
      governanceError = '';
      try {
        governanceAgenda = await fetchJson(GOVERNANCE_AGENDA_URL);
      } catch (err) {
        governanceAgenda = null;
        governanceError = String(err);
      }

      try {
        governanceBacklog = await fetchJson(GOVERNANCE_BACKLOG_URL);
      } catch (_) {
        governanceBacklog = null;
      }
      try {
        governanceProposals = await fetchJson(GOVERNANCE_PROPOSALS_URL);
      } catch (_) {
        governanceProposals = null;
      }
      governanceLoadedAt = new Date().toISOString();
      governanceLoading = false;
      if (currentView === 'governance') renderGovernance();
      if (currentView === 'map') renderMap();
    }

    function renderGovernance() {
      if (!els.governanceContent) return;
      if (governanceLoading && !governanceAgenda) {
        els.governanceContent.innerHTML = '<div class="gov-empty">Loading governance agenda...</div>';
        return;
      }

      if (!governanceAgenda) {
        const errorText = governanceError
          ? `Agenda unavailable: ${governanceError}`
          : 'Agenda unavailable. Run the governance cycle and refresh.';
        els.governanceContent.innerHTML = `
          <div class="gov-empty">${escapeHtml(errorText)}</div>
          <div class="gov-section">
            <h3>Manual Commands</h3>
            <div class="command-list">${commandRowsHtml()}</div>
            <div id="governanceCopyStatus" class="gov-meta"></div>
          </div>
        `;
        wireGovernanceCommandButtons();
        return;
      }

      const summary = governanceAgenda.summary || {};
      const checkpoints = governanceAgenda.checkpoints || {};
      const epochMap = buildEpochApplicabilityMap(checkpoints);
      const epochOnly = els.govEpochOnly ? !!els.govEpochOnly.checked : true;
      const thoughtItems = (checkpoints.thought_intake && checkpoints.thought_intake.items) || [];
      const conflictItemsRaw = (checkpoints.conflict_resolution && checkpoints.conflict_resolution.items) || [];
      const decisionItemsRaw = (checkpoints.governance_decisions && checkpoints.governance_decisions.items) || [];
      const conflictItems = filterRowsByCurrentEpoch(conflictItemsRaw, epochMap, epochOnly);
      const decisionItems = filterRowsByCurrentEpoch(decisionItemsRaw, epochMap, epochOnly);
      const structureItemsRaw = (checkpoints.architecture_structure && checkpoints.architecture_structure.consider_new_structure) || [];
      const structureItems = filterRowsByCurrentEpoch(structureItemsRaw, epochMap, epochOnly);
      const autonomyItems = (checkpoints.autonomy_triage && checkpoints.autonomy_triage.items) || [];
      const dispatch = checkpoints.evidence_dispatch || {};
      const highPriorityRaw = dispatch.high_priority_proposals || [];
      const highPriority = filterRowsByCurrentEpoch(highPriorityRaw, epochMap, epochOnly);
      const dispatchByRepo = dispatch.by_target_repo || [];
      const maintenance = checkpoints.maintenance || {};
      const maintenanceRuns = maintenance.unlinked_runs || [];
      const warnings = governanceAgenda.warnings || [];
      const generatedAt = governanceAgenda.generated_at_utc || '';
      const stale = stalenessBadge(generatedAt);

      const backlogItems = governanceBacklog && governanceBacklog.items ? governanceBacklog.items : [];
      const highBacklogRows = backlogItems
        .filter(item => item.priority === 'high')
        .slice(0, 15);
      const highBacklogVisible = filterRowsByCurrentEpoch(highBacklogRows, epochMap, epochOnly);

      const isPendingDecision = (item) => {
        const token = String((item && item.decision_status) || '').toLowerCase().trim();
        return !token || !['applied', 'approved', 'done'].includes(token);
      };
      const claimDecisionRows = decisionItems.filter(isPendingDecision);
      const humanOnlyRows = autonomyItems.filter(item => String(item.tier || '').toUpperCase() === 'HUMAN_ONLY');
      const approvalRows = autonomyItems.filter(item => {
        const tier = String(item.tier || '').toUpperCase();
        const needed = String(item.decision_needed || '').toLowerCase() === 'yes';
        return tier === 'AUTO_WITH_APPROVAL' && needed;
      });
      const humanDecisionRows = [
        ...claimDecisionRows.map(item => ({
          source: 'claim_queue',
          claim_id: item.claim_id || '',
          work_item: item.decision_needed || '',
          recommendation: item.recommendation || '',
          rationale: item.decision_status ? `decision_status=${item.decision_status}` : '',
        })),
        ...humanOnlyRows.map(item => ({
          source: 'autonomy_gate',
          claim_id: '',
          work_item: item.work_item || '',
          recommendation: item.recommendation || '',
          rationale: item.rationale || '',
        })),
        ...approvalRows.map(item => ({
          source: 'approval_gate',
          claim_id: '',
          work_item: item.work_item || '',
          recommendation: item.recommendation || '',
          rationale: item.rationale || '',
        })),
      ];
      const creativeRows = structureItems
        .filter(item => Boolean(item.consider_new_structure) || Boolean(item.escalate_architecture_decision))
        .slice(0, 20);

      const allProposals = governanceProposals && governanceProposals.items ? governanceProposals.items : [];
      const checkpointGuideRows = Object.entries(checkpoints).map(([key, checkpoint]) => ({
        checkpoint: checkpointLabel(key),
        prompt: checkpoint && checkpoint.prompt ? checkpoint.prompt : '',
        context_docs: collectCheckpointContextDocs(key, checkpoint),
      }));

      const generatedLabel = generatedAt ? new Date(generatedAt).toLocaleString() : 'unknown';
      const loadedLabel = governanceLoadedAt ? new Date(governanceLoadedAt).toLocaleTimeString() : 'unknown';
      const epochLabel = epochOnly ? 'current epoch only' : 'all epochs';
      if (els.governanceMeta) {
        els.governanceMeta.innerHTML =
          `Agenda generated: <strong>${escapeHtml(generatedLabel)}</strong>` +
          `<span class="gov-staleness ${escapeHtml(stale.cls)}">${escapeHtml(stale.label)}</span>` +
          ` &nbsp;|&nbsp; dashboard refreshed: ${escapeHtml(loadedLabel)}` +
          ` &nbsp;|&nbsp; scope: ${escapeHtml(epochLabel)}`;
      }

      const cards = `
        <div class="governance-grid">
          <div class="gov-card"><div class="label">Unprocessed Thoughts</div><div class="value">${Number(summary.thought_unprocessed || 0)}</div></div>
          <div class="gov-card"><div class="label">Conflicts (visible)</div><div class="value">${conflictItems.length}</div></div>
          <div class="gov-card"><div class="label">Decision Queue (visible)</div><div class="value">${decisionItems.length}</div></div>
          <div class="gov-card"><div class="label">Human Decisions Needed</div><div class="value">${humanDecisionRows.length}</div></div>
          <div class="gov-card"><div class="label">Inspiration / Generative Needed</div><div class="value">${creativeRows.length}</div></div>
          <div class="gov-card"><div class="label">High Priority Backlog (visible)</div><div class="value">${highBacklogVisible.length}</div></div>
          <div class="gov-card"><div class="label">High Priority Proposals (visible)</div><div class="value">${highPriority.length}</div></div>
          <div class="gov-card"><div class="label">Warnings</div><div class="value">${Number(summary.warnings || 0)}</div></div>
        </div>
      `;

      const checkpointSections = `
        <div class="gov-sections">
          <div class="gov-section">
            <h3>Checkpoint Guide</h3>
            ${renderGovTable(
              checkpointGuideRows,
              [
                { key: 'checkpoint', label: 'checkpoint' },
                { key: 'prompt', label: 'prompt' },
                { key: 'context_docs', label: 'context_docs', render: value => renderContextLinks(value) },
              ],
              'No checkpoints available.'
            )}
          </div>
          <div class="gov-section">
            <h3>Thought Intake</h3>
            ${renderCheckpointMeta('thought_intake', checkpoints.thought_intake)}
            ${renderGovTable(
              thoughtItems,
              [
                { key: 'file', label: 'file' },
                { key: 'status', label: 'status' },
              ],
              'No unprocessed thoughts.'
            )}
          </div>
          <div class="gov-section">
            <h3>Conflict Resolution</h3>
            ${renderCheckpointMeta('conflict_resolution', checkpoints.conflict_resolution)}
            ${renderGovTable(
              conflictItems,
              [
                { key: 'claim_id', label: 'claim', render: value => renderClaimCell(value) },
                { key: 'conflict_types', label: 'conflict_types' },
                { key: 'conflict_ratio', label: 'conflict_ratio' },
                { key: 'latest', label: 'latest' },
              ],
              'No active conflicts.'
            )}
          </div>
          <div class="gov-section">
            <h3>Governance Decisions <span class="gov-pill human">human ${humanDecisionRows.length}</span></h3>
            ${renderCheckpointMeta('governance_decisions', checkpoints.governance_decisions)}
            ${renderGovTable(
              decisionItems,
              [
                { key: 'claim_id', label: 'claim', render: value => renderClaimCell(value) },
                { key: 'decision_needed', label: 'decision_needed' },
                { key: 'recommendation', label: 'recommendation' },
                { key: 'decision_status', label: 'decision_status' },
              ],
              'No decision items.'
            )}
          </div>
          <div class="gov-section">
            <h3>Human Attention Queue <span class="gov-pill human">decide ${humanDecisionRows.length}</span><span class="gov-pill creative">design ${creativeRows.length}</span></h3>
            ${renderContextLinks([
              'evidence/planning/GOVERNANCE_AGENDA.md',
              'evidence/planning/structure_review/latest/ACTIVE_INDEX.md',
            ])}
            <div class="gov-meta">Items in this section require explicit human ownership and cannot be resolved by automated runs alone.</div>
            ${renderGovTable(
              humanDecisionRows,
              [
                { key: 'source', label: 'source' },
                { key: 'claim_id', label: 'claim', render: value => value ? renderClaimCell(value) : '-' },
                { key: 'work_item', label: 'work_item' },
                { key: 'recommendation', label: 'recommendation' },
                { key: 'rationale', label: 'rationale' },
              ],
              'No explicit human-decision items.'
            )}
            <div style="height:8px;"></div>
            ${renderGovTable(
              creativeRows,
              [
                { key: 'claim_id', label: 'claim', render: value => renderClaimCell(value) },
                { key: 'recommendation', label: 'recommendation' },
                { key: 'conflict_ratio', label: 'conflict_ratio' },
                { key: 'trigger_signals', label: 'trigger_signals' },
              ],
              'No explicit human-inspiration items.'
            )}
          </div>
          <div class="gov-section">
            <h3>Backlog (High Priority)</h3>
            ${renderContextLinks([
              'evidence/planning/evidence_backlog.v1.json',
              'evidence/planning/ARCHITECTURE_GAP_REGISTER.md',
            ])}
            ${renderGovTable(
              highBacklogVisible,
              [
                { key: 'backlog_id', label: 'backlog_id' },
                { key: 'claim_id', label: 'claim', render: value => renderClaimCell(value) },
                { key: 'evidence_needed', label: 'evidence_needed' },
                { key: 'reasons', label: 'reasons' },
              ],
              'No high-priority backlog items.'
            )}
          </div>
          <div class="gov-section">
            <h3>Evidence Dispatch by Repo</h3>
            ${renderCheckpointMeta('evidence_dispatch', checkpoints.evidence_dispatch)}
            ${renderGovTable(
              dispatchByRepo,
              [
                { key: 'target_repo', label: 'target_repo' },
                { key: 'total', label: 'total' },
                { key: 'experimental', label: 'experimental' },
                { key: 'literature_review', label: 'literature_review' },
              ],
              'No dispatch items.'
            )}
          </div>
          <div class="gov-section">
            <h3>High Priority Proposals</h3>
            ${renderCheckpointMeta('evidence_dispatch', checkpoints.evidence_dispatch)}
            ${renderGovTable(
              highPriority,
              [
                { key: 'proposal_id', label: 'proposal_id' },
                { key: 'claim_id', label: 'claim', render: value => renderClaimCell(value) },
                { key: 'proposal_type', label: 'type' },
                { key: 'target_repo', label: 'target_repo' },
                { key: 'status', label: 'status' },
              ],
              'No high-priority proposals.'
            )}
            <div class="gov-meta" style="margin-top:8px;">
              Total proposals in file: ${allProposals.length} | visible under scope: ${highPriority.length}
            </div>
          </div>
          <div class="gov-section">
            <h3>Maintenance Flags</h3>
            ${renderCheckpointMeta('maintenance', checkpoints.maintenance)}
            ${renderGovTable(
              maintenanceRuns,
              [
                { key: 'source_type', label: 'source_type' },
                { key: 'experiment_type', label: 'experiment_type' },
                { key: 'run_id', label: 'run_id' },
                { key: 'status', label: 'status' },
              ],
              'No unlinked evidence runs.'
            )}
            ${warnings.length ? `<div class="gov-meta" style="margin-top:8px;">Warnings: ${escapeHtml(warnings.join(' | '))}</div>` : '<div class="gov-meta" style="margin-top:8px;">Warnings: none</div>'}
          </div>
        </div>
      `;

      els.governanceContent.innerHTML = `
        ${cards}
        <div class="gov-section">
          <h3>Manual Commands</h3>
          <div class="command-list">${commandRowsHtml()}</div>
          <div id="governanceCopyStatus" class="gov-meta"></div>
        </div>
        ${checkpointSections}
      `;
      wireGovernanceCommandButtons();
    }

    function populateDocSelect(filterText) {
      if (!els.docSelect) return;
      const term = (filterText || '').trim().toLowerCase();
      const current = els.docSelect.value;
      els.docSelect.innerHTML = '';
      DOC_GROUPS.forEach(group => {
        const opts = group.docs.filter(doc => {
          if (!term) return true;
          return doc.title.toLowerCase().includes(term) || doc.path.toLowerCase().includes(term);
        });
        if (!opts.length) return;
        const optgroup = document.createElement('optgroup');
        optgroup.label = group.label;
        opts.forEach(doc => {
          const url = doc.path.match(/^https?:\/\//)
            ? doc.path
            : new URL(doc.path, window.location.href).toString();
          const opt = document.createElement('option');
          opt.value = url;
          opt.textContent = doc.title;
          optgroup.appendChild(opt);
        });
        els.docSelect.appendChild(optgroup);
      });
      if (current) {
        const exists = Array.from(els.docSelect.options).some(o => o.value === current);
        if (exists) els.docSelect.value = current;
      }
    }

    function updateDocMeta(entry) {
      if (!els.docMeta) return;
      if (!entry) {
        els.docMeta.textContent = '';
        return;
      }
      els.docMeta.textContent = `${entry.title}  ${entry.path}`;
    }

    function wireDocLinks(baseUrl) {
      if (!els.docContent) return;
      els.docContent.querySelectorAll('a[href]').forEach(link => {
        const href = link.getAttribute('href');
        if (!href) return;
        if (href.startsWith('#')) {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const target = els.docContent.querySelector(href);
            if (target) target.scrollIntoView({ block: 'start' });
          });
          return;
        }
        if (href.includes('.md')) {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const url = new URL(href, baseUrl).toString();
            const [pathOnly, anchor] = url.split('#', 2);
            openDoc(pathOnly, anchor);
          });
          return;
        }
        link.setAttribute('target', '_blank');
      });
    }

    async function openDoc(path, anchor) {
      if (!path) return;
      const url = path.match(/^https?:\/\//)
        ? path
        : new URL(path, window.location.href).toString();
      currentDocUrl = url;
      const entry = docIndexMap.get(url);
      if (entry && els.docSelect) {
        els.docSelect.value = url;
        updateDocMeta(entry);
      } else if (els.docMeta) {
        const displayPath = path.replace(new URL(window.location.href).origin, '');
        els.docMeta.textContent = displayPath;
      }
      try {
        const text = await fetchText(url);
        if (els.docContent) {
          els.docContent.innerHTML = renderMarkdown(text);
          wireDocLinks(url);
          if (anchor) {
            const target = els.docContent.querySelector(`#${anchor}`);
            if (target) target.scrollIntoView({ block: 'start' });
          }
        }
      } catch (err) {
        if (els.docContent) {
          els.docContent.innerHTML = `<div class="meta">Failed to load document: ${escapeHtml(String(err))}</div>`;
        }
      }
    }

    function openDocFromLocation(location) {
      if (!location) return;
      const rel = relativeLink(location);
      const parts = rel.split('#');
      const path = parts[0];
      const anchor = parts.length > 1 ? parts[1] : null;
      setView('docs');
      openDoc(path, anchor);
    }

    function initDocs() {
      if (docsInitialized) return;
      buildDocIndex();
      populateDocSelect('');
      if (els.docSelect && els.docSelect.value) {
        openDoc(els.docSelect.value);
      }
      docsInitialized = true;
    }

    function readFilterState() {
      return {
        search: els.search.value,
        type: els.typeFilter.value,
        status: els.statusFilter.value,
        subject: els.subjectFilter.value,
      };
    }

    function restoreFilterState(state) {
      if (!state) return;
      if (typeof state.search === 'string') els.search.value = state.search;
      if (state.type && Array.from(els.typeFilter.options).some(o => o.value === state.type)) {
        els.typeFilter.value = state.type;
      }
      if (state.status && Array.from(els.statusFilter.options).some(o => o.value === state.status)) {
        els.statusFilter.value = state.status;
      }
      if (typeof state.subject === 'string') els.subjectFilter.value = state.subject;
    }

    function renderConflictFilePicker() {
      if (!els.conflictFileList) return;
      els.conflictFileList.innerHTML = '';
      const files = (conflictFiles || []).slice().sort();
      if (!files.length) {
        const empty = document.createElement('div');
        empty.className = 'meta';
        empty.textContent = 'No conflicts found.';
        els.conflictFileList.appendChild(empty);
        return;
      }
      files.forEach(file => {
        const row = document.createElement('label');
        row.className = 'picker-item';
        const box = document.createElement('input');
        box.type = 'checkbox';
        box.value = file;
        box.checked = conflictSelectedFiles.has(file);
        box.addEventListener('change', () => {
          if (box.checked) conflictSelectedFiles.add(file);
          else conflictSelectedFiles.delete(file);
          renderSelectedSummary();
        });
        const text = document.createElement('span');
        text.textContent = file;
        row.appendChild(box);
        row.appendChild(text);
        els.conflictFileList.appendChild(row);
      });
    }

    function renderChips(container, items, clickable) {
      if (!container) return;
      container.innerHTML = '';
      if (!items.length) {
        const empty = document.createElement('span');
        empty.className = 'chip empty';
        empty.textContent = 'None';
        container.appendChild(empty);
        return;
      }
      items.forEach(item => {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.textContent = item;
        if (clickable) {
          chip.addEventListener('click', () => selectClaim(item));
        }
        container.appendChild(chip);
      });
    }

    function renderSelectedSummary() {
      renderChips(els.selectedThought, Array.from(thoughtSelected).sort(), true);
      renderChips(els.selectedConflict, Array.from(conflictSelectedClaims).sort(), true);
      renderChips(els.selectedConflictFiles, Array.from(conflictSelectedFiles).sort(), false);
    }

    function getFocusMode() {
      const checked = document.querySelector('input[name="graphFocus"]:checked');
      return checked ? checked.value : 'anchor';
    }

    function getWorksetScope() {
      const checked = document.querySelector('input[name="worksetScope"]:checked');
      return checked ? checked.value : 'union';
    }

    function getWorksetIds() {
      const ids = new Set();
      if (els.worksetThought && els.worksetThought.checked) {
        thoughtSelected.forEach(id => ids.add(id));
      }
      if (els.worksetConflict && els.worksetConflict.checked) {
        conflictSelectedClaims.forEach(id => ids.add(id));
      }
      return Array.from(ids);
    }

    function updateWorksetUI() {
      const active = getFocusMode() === 'workset';
      els.worksetGroups.forEach(group => {
        if (active) group.classList.remove('inactive');
        else group.classList.add('inactive');
      });
    }

    function renderPickers() {
      renderConflictFilePicker();
      renderSelectedSummary();
    }

    function statCard(text) {
      const div = document.createElement('div');
      div.className = 'stat-card';
      div.textContent = text;
      return div;
    }

    function buildStats() {
      const byType = {};
      const byStatus = {};
      allClaims.forEach(c => {
        byType[c.type] = (byType[c.type] || 0) + 1;
        byStatus[c.status] = (byStatus[c.status] || 0) + 1;
      });
      els.stats.innerHTML = '';
      const total = allClaims.length;
      els.stats.appendChild(statCard(`Total claims: ${total}`));
      Object.keys(byType).sort((a,b) => typeOrder.indexOf(a) - typeOrder.indexOf(b)).forEach(t => {
        els.stats.appendChild(statCard(`${t}: ${byType[t]}`));
      });
      Object.keys(byStatus).sort().forEach(s => {
        els.stats.appendChild(statCard(`status ${s}: ${byStatus[s]}`));
      });
    }

    function populateFilters() {
      const types = Array.from(new Set(allClaims.map(c => c.type))).sort((a,b) => typeOrder.indexOf(a) - typeOrder.indexOf(b));
      const statuses = Array.from(new Set(allClaims.map(c => c.status))).sort();
      const subjects = Array.from(new Set(allClaims.map(c => c.subject).filter(Boolean))).sort();

      els.typeFilter.innerHTML = '<option value="">All types</option>' + types.map(t => `<option value="${t}">${t}</option>`).join('');
      els.statusFilter.innerHTML = '<option value="">All statuses</option>' + statuses.map(s => `<option value="${s}">${s}</option>`).join('');
      els.subjectList.innerHTML = subjects.map(s => `<option value="${s}"></option>`).join('');
    }

    function applyFilters() {
      const term = (els.search.value || '').trim().toLowerCase();
      const type = els.typeFilter.value;
      const status = els.statusFilter.value;
      const subjectTerm = (els.subjectFilter.value || '').trim().toLowerCase();

      return allClaims.filter(c => {
        if (type && c.type !== type) return false;
        if (status && c.status !== status) return false;
        if (subjectTerm && !c.subject.toLowerCase().includes(subjectTerm)) return false;
        if (term) {
          const hay = `${c.id} ${c.subject} ${c.type} ${c.status}`.toLowerCase();
          if (!hay.includes(term)) return false;
        }
        return true;
      });
    }

    function dependsTitle(depends) {
      if (!depends || depends.length === 0) return '-';
      return depends.join(', ');
    }

    let selectedId = null;
    let currentView = 'list';

    function renderTable() {
      const filtered = applyFilters();
      els.claimsTable.innerHTML = '';
      filtered.forEach(c => {
        const tr = document.createElement('tr');
        tr.dataset.id = c.id;
        if (selectedId === c.id) tr.classList.add('selected');
        const conflicts = conflictsMap[c.id] || [];
        tr.innerHTML = `
          <td class="status-${c.status}"><span class="badge">${c.id}</span></td>
          <td><span class="badge type-${c.type}">${c.type}</span></td>
          <td>${c.status}</td>
          <td>${c.subject || '-'}</td>
          <td title="${dependsTitle(c.depends_on)}">${c.depends_on.length || '-'}</td>
          <td>${conflicts.length ? `<span class="conflict">${conflicts.length} conflict</span>` : '-'}</td>
          <td><input type="checkbox" data-role="thought" /></td>
          <td><input type="checkbox" data-role="conflict" /></td>
        `;
        tr.addEventListener('click', () => selectClaim(c.id));
        const thoughtBox = tr.querySelector('input[data-role="thought"]');
        const conflictBox = tr.querySelector('input[data-role="conflict"]');
        if (thoughtBox) {
          thoughtBox.checked = thoughtSelected.has(c.id);
          thoughtBox.addEventListener('click', (e) => e.stopPropagation());
          thoughtBox.addEventListener('change', () => {
            if (thoughtBox.checked) thoughtSelected.add(c.id);
            else thoughtSelected.delete(c.id);
            renderSelectedSummary();
            renderGraph();
          });
        }
        if (conflictBox) {
          conflictBox.checked = conflictSelectedClaims.has(c.id);
          conflictBox.addEventListener('click', (e) => e.stopPropagation());
          conflictBox.addEventListener('change', () => {
            if (conflictBox.checked) conflictSelectedClaims.add(c.id);
            else conflictSelectedClaims.delete(c.id);
            renderSelectedSummary();
            renderGraph();
          });
        }
        els.claimsTable.appendChild(tr);
      });
    }

    function syncRowCheckboxes(id) {
      const row = els.claimsTable.querySelector(`tr[data-id="${id}"]`);
      if (!row) return;
      const thoughtBox = row.querySelector('input[data-role="thought"]');
      const conflictBox = row.querySelector('input[data-role="conflict"]');
      if (thoughtBox) thoughtBox.checked = thoughtSelected.has(id);
      if (conflictBox) conflictBox.checked = conflictSelectedClaims.has(id);
    }

    function relativeLink(location) {
      return repoRelativePath(location);
    }

    const metaPrefixes = [
      '**Subject:**', '**Polarity:**', '**Claim:**', '**Source:**', '**Violation:**',
      'Source:', 'Sources:', 'Related Claims', 'Open Questions', 'References / Source Fragments'
    ];

    const idPattern = /\b(INV|ARC|MECH|IMPL|Q)-\d{3}\b/;

    function cleanClaimLine(line, anchorLine) {
      if (!line) return '';
      let s = line.replace(anchorLine, '').trim();
      s = s.replace(/`([^`]+)`/g, '$1');
      s = s.replace(/\*\*([^*]+)\*\*/g, '$1');
      s = s.replace(/\[(.*?)\]\([^)]*\)/g, '$1');
      if (s.toLowerCase().startsWith('claim:')) s = s.split(':', 2)[1].trim();
      if (s.startsWith('### ')) s = s.slice(4).trim();
      if (s.startsWith('## ')) s = s.slice(3).trim();
      return s;
    }

    function extractSection(text, anchorId) {
      const lines = text.split(/\r?\n/);
      const anchorLine = `<a id="${anchorId}"></a>`;
      let start = -1;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes(anchorLine)) { start = i; break; }
      }
      if (start === -1) return { claimLine: '', excerpt: '' };

      let end = lines.length;
      for (let j = start + 1; j < lines.length; j++) {
        if (lines[j].includes('<a id="')) { end = j; break; }
      }

      let section = lines.slice(start, end);
      while (section.length && section[0].trim() === '') section.shift();
      while (section.length && section[section.length - 1].trim() === '') section.pop();
      const excerpt = section.join('\\n');

      let claimLine = '';
      for (const l of section) {
        if (l.includes('**Claim:**')) { claimLine = l; break; }
      }
      if (!claimLine) {
        for (const l of section) {
          const t = l.trim();
          if (!t.startsWith('#')) continue;
          if (t.startsWith('### Q-') || idPattern.test(t) || t.includes('(MECH-') || t.includes('(ARC-') || t.includes('(INV-')) {
            claimLine = l; break;
          }
        }
      }
      if (!claimLine) {
        for (const l of section) {
          const t = l.trim();
          if (!t) continue;
          if (t.startsWith('<a id=')) continue;
          if (t.startsWith('#')) continue;
          if (t.startsWith('---')) continue;
          if (t.startsWith('>')) continue;
          if (metaPrefixes.some(p => t.startsWith(p))) continue;
          claimLine = l; break;
        }
      }

      return { claimLine: cleanClaimLine(claimLine, anchorLine), excerpt };
    }

    async function loadClaimText(claim) {
      if (claimTextCache.has(claim.id)) return claimTextCache.get(claim.id);
      if (!claim.location || !claim.location.includes('#')) {
        const res = { claimLine: '', excerpt: '' };
        claimTextCache.set(claim.id, res);
        return res;
      }

      const [filePath, anchor] = claim.location.split('#', 2);
      const relPath = relativeLink(filePath);

      let text = fileCache.get(relPath);
      if (!text) {
        text = await fetchText(relPath);
        fileCache.set(relPath, text);
      }
      const extracted = extractSection(text, anchor);
      claimTextCache.set(claim.id, extracted);
      return extracted;
    }

    function wireDetailToggles(id) {
      const thoughtToggle = els.detailContent.querySelector('#toggleThought');
      const conflictToggle = els.detailContent.querySelector('#toggleConflict');
      if (thoughtToggle) {
        thoughtToggle.addEventListener('change', () => {
          if (thoughtToggle.checked) thoughtSelected.add(id);
          else thoughtSelected.delete(id);
          renderSelectedSummary();
          syncRowCheckboxes(id);
          renderGraph();
        });
      }
      if (conflictToggle) {
        conflictToggle.addEventListener('change', () => {
          if (conflictToggle.checked) conflictSelectedClaims.add(id);
          else conflictSelectedClaims.delete(id);
          renderSelectedSummary();
          syncRowCheckboxes(id);
          renderGraph();
        });
      }
    }

    async function selectClaim(id) {
      selectedId = id;
      renderTable();
      const c = claimMap.get(id);
      if (!c) return;

      const conflicts = conflictsMap[c.id] || [];
      const dependents = allClaims.filter(x => (x.depends_on || []).includes(c.id)).map(x => x.id);
      const loc = relativeLink(c.location);
      const thoughtChecked = thoughtSelected.has(c.id) ? 'checked' : '';
      const conflictChecked = conflictSelectedClaims.has(c.id) ? 'checked' : '';
      const toggleBlock = `
        <div class="claim-toggles">
          <label><input type="checkbox" id="toggleThought" ${thoughtChecked} /> Use in Thought</label>
          <label><input type="checkbox" id="toggleConflict" ${conflictChecked} /> Use in Conflict</label>
        </div>
      `;

      els.detailContent.innerHTML = `
        <h2>${c.id}</h2>
        <div class="meta">${c.type} | ${c.status}</div>
        <div class="meta">Loading claim text...</div>
        ${toggleBlock}
        <ul>
          <li><strong>Subject:</strong> ${c.subject || '-'}</li>
          <li><strong>Polarity:</strong> ${c.polarity || '-'}</li>
          <li><strong>Location:</strong> ${loc ? `<a href="${loc}" target="_blank">${loc}</a> <button class="doc-open" data-doc="${loc}">Open in Docs</button>` : '-'}</li>
          <li><strong>Depends On:</strong> ${c.depends_on.length ? c.depends_on.map(d => `<a href="#" data-id="${d}">${d}</a>`).join(', ') : '-'}</li>
          <li><strong>Dependents:</strong> ${dependents.length ? dependents.map(d => `<a href="#" data-id="${d}">${d}</a>`).join(', ') : '-'}</li>
          <li><strong>Conflicts:</strong> ${conflicts.length ? conflicts.map(f => {
            const link = relativeLink(f);
            return `<a href="${link}" target="_blank">${f}</a>`;
          }).join(', ') : '-'}</li>
        </ul>
      `;
      els.detailContent.querySelectorAll('a[data-id]').forEach(a => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          selectClaim(a.getAttribute('data-id'));
        });
      });
      els.detailContent.querySelectorAll('button[data-doc]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          openDocFromLocation(btn.getAttribute('data-doc'));
        });
      });
      wireDetailToggles(c.id);

      try {
        const { claimLine, excerpt } = await loadClaimText(c);
        if (selectedId !== id) return;
        const claimLineText = claimLine ? escapeHtml(claimLine) : '-';
        const excerptText = excerpt ? escapeHtml(excerpt) : '';
        const excerptBlock = excerptText ? `
          <details>
            <summary>Show section excerpt</summary>
            <pre class="excerpt">${excerptText}</pre>
          </details>
        ` : '<div class="meta">No excerpt found.</div>';

        els.detailContent.innerHTML = `
          <h2>${c.id}</h2>
          <div class="meta">${c.type} | ${c.status}</div>
          ${toggleBlock}
          <ul>
            <li><strong>Claim:</strong> ${claimLineText}</li>
            <li><strong>Subject:</strong> ${c.subject || '-'}</li>
            <li><strong>Polarity:</strong> ${c.polarity || '-'}</li>
          <li><strong>Location:</strong> ${loc ? `<a href="${loc}" target="_blank">${loc}</a> <button class="doc-open" data-doc="${loc}">Open in Docs</button>` : '-'}</li>
            <li><strong>Depends On:</strong> ${c.depends_on.length ? c.depends_on.map(d => `<a href="#" data-id="${d}">${d}</a>`).join(', ') : '-'}</li>
            <li><strong>Dependents:</strong> ${dependents.length ? dependents.map(d => `<a href="#" data-id="${d}">${d}</a>`).join(', ') : '-'}</li>
            <li><strong>Conflicts:</strong> ${conflicts.length ? conflicts.map(f => {
              const link = relativeLink(f);
              return `<a href="${link}" target="_blank">${f}</a>`;
            }).join(', ') : '-'}</li>
          </ul>
          ${excerptBlock}
        `;
        els.detailContent.querySelectorAll('a[data-id]').forEach(a => {
          a.addEventListener('click', (e) => {
            e.preventDefault();
            selectClaim(a.getAttribute('data-id'));
          });
        });
        els.detailContent.querySelectorAll('button[data-doc]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            openDocFromLocation(btn.getAttribute('data-doc'));
          });
        });
        wireDetailToggles(c.id);
      } catch (err) {
        if (selectedId !== id) return;
        els.detailContent.innerHTML += `<div class="meta">Failed to load claim text: ${escapeHtml(String(err))}</div>`;
      }

      renderGraph();
    }

    function updateHoverPoint(evt) {
      hoverPoint = { x: evt.clientX, y: evt.clientY };
    }

    function positionGraphTooltip() {
      if (!els.graphTooltip || !els.graphPanel || !hoverPoint) return;
      const panelRect = els.graphPanel.getBoundingClientRect();
      const tip = els.graphTooltip;
      const pad = 12;
      let x = hoverPoint.x - panelRect.left + pad;
      let y = hoverPoint.y - panelRect.top + pad;
      const maxX = panelRect.width - tip.offsetWidth - pad;
      const maxY = panelRect.height - tip.offsetHeight - pad;
      if (!Number.isNaN(maxX)) x = Math.min(x, maxX);
      if (!Number.isNaN(maxY)) y = Math.min(y, maxY);
      x = Math.max(pad, x);
      y = Math.max(pad, y);
      tip.style.left = `${x}px`;
      tip.style.top = `${y}px`;
    }

    function showGraphTooltip(evt, id) {
      const tip = els.graphTooltip;
      const c = claimMap.get(id);
      if (!tip || !c) return;
      hoverId = id;
      updateHoverPoint(evt);
      const cached = claimTextCache.get(id);
      const claimLine = cached && cached.claimLine ? cached.claimLine : '';
      tip.innerHTML = `
        <div class="title">${c.id}</div>
        <div class="meta">${c.type} | ${c.status}</div>
        <div class="meta">Subject: ${escapeHtml(c.subject || '-')}</div>
        ${claimLine ? `<div>${escapeHtml(claimLine)}</div>` : '<div class="meta">Loading claim...</div>'}
      `;
      tip.style.display = 'block';
      positionGraphTooltip();

      if (!claimLine) {
        loadClaimText(c).then(res => {
          if (hoverId !== id) return;
          const line = res.claimLine ? escapeHtml(res.claimLine) : '-';
          tip.innerHTML = `
            <div class="title">${c.id}</div>
            <div class="meta">${c.type} | ${c.status}</div>
            <div class="meta">Subject: ${escapeHtml(c.subject || '-')}</div>
            <div>${line}</div>
          `;
          positionGraphTooltip();
        }).catch(() => {});
      }
    }

    function moveGraphTooltip(evt) {
      if (!hoverId) return;
      updateHoverPoint(evt);
      positionGraphTooltip();
    }

    function hideGraphTooltip() {
      hoverId = null;
      hoverPoint = null;
      if (els.graphTooltip) els.graphTooltip.style.display = 'none';
    }

    function renderGraph() {
      const filtered = applyFilters();
      const includeDeps = els.includeDeps.checked;
      const nodes = new Map(filtered.map(c => [c.id, {...c, ghost: false}]));
      const focusMode = getFocusMode();
      const worksetScope = getWorksetScope();

      if (includeDeps) {
        filtered.forEach(c => {
          c.depends_on.forEach(dep => {
            if (!nodes.has(dep) && claimMap.has(dep)) {
              nodes.set(dep, {...claimMap.get(dep), ghost: true});
            }
          });
        });
      }

      const nodeList = Array.from(nodes.values());
      const nodeMap = new Map(nodeList.map(n => [n.id, n]));
      const forward = new Map();
      nodeList.forEach(n => {
        (n.depends_on || []).forEach(dep => {
          if (!nodeMap.has(dep)) return;
          if (!forward.has(dep)) forward.set(dep, []);
          forward.get(dep).push(n.id);
        });
      });
      const upstream = new Set();
      const downstream = new Set();
      let selected = null;
      let focusSet = null;
      let worksetIds = [];
      const selectedWorkset = new Set();

      function collectUpstream(id) {
        const stack = [id];
        const seen = new Set([id]);
        const out = new Set();
        while (stack.length) {
          const cur = stack.pop();
          const n = nodeMap.get(cur);
          if (!n) continue;
          (n.depends_on || []).forEach(dep => {
            if (!nodeMap.has(dep) || seen.has(dep)) return;
            seen.add(dep);
            out.add(dep);
            stack.push(dep);
          });
        }
        return out;
      }

      function collectDownstream(id) {
        const stack = [id];
        const seen = new Set([id]);
        const out = new Set();
        while (stack.length) {
          const cur = stack.pop();
          const children = forward.get(cur) || [];
          children.forEach(child => {
            if (seen.has(child)) return;
            seen.add(child);
            out.add(child);
            stack.push(child);
          });
        }
        return out;
      }

      function neighborhood(id) {
        const up = collectUpstream(id);
        const down = collectDownstream(id);
        const set = new Set([id]);
        up.forEach(x => set.add(x));
        down.forEach(x => set.add(x));
        return set;
      }

      function intersectSets(a, b) {
        const out = new Set();
        a.forEach(x => { if (b.has(x)) out.add(x); });
        return out;
      }

      function buildAdjacency() {
        const adj = new Map();
        nodeList.forEach(n => {
          if (!adj.has(n.id)) adj.set(n.id, new Set());
          (n.depends_on || []).forEach(dep => {
            if (!nodeMap.has(dep)) return;
            if (!adj.has(dep)) adj.set(dep, new Set());
            adj.get(n.id).add(dep);
            adj.get(dep).add(n.id);
          });
        });
        return adj;
      }

      function shortestPath(adj, start, goal) {
        if (start === goal) return [start];
        const queue = [start];
        const prev = new Map();
        const seen = new Set([start]);
        while (queue.length) {
          const cur = queue.shift();
          const neighbors = adj.get(cur) || [];
          for (const next of neighbors) {
            if (seen.has(next)) continue;
            seen.add(next);
            prev.set(next, cur);
            if (next === goal) {
              const path = [goal];
              let p = goal;
              while (prev.has(p)) {
                p = prev.get(p);
                path.push(p);
              }
              return path.reverse();
            }
            queue.push(next);
          }
        }
        return [];
      }

      selected = selectedId && nodeMap.has(selectedId) ? selectedId : null;
      if (focusMode === 'anchor' && selected) {
        const up = collectUpstream(selected);
        const down = collectDownstream(selected);
        up.forEach(x => upstream.add(x));
        down.forEach(x => downstream.add(x));
        focusSet = new Set([selected, ...upstream, ...downstream]);
      }

      if (focusMode === 'workset') {
        worksetIds = getWorksetIds().filter(id => nodeMap.has(id));
        worksetIds.forEach(id => selectedWorkset.add(id));
        if (selectedWorkset.size) {
          if (worksetScope === 'intersection') {
            let acc = null;
            worksetIds.forEach(id => {
              const set = neighborhood(id);
              acc = acc ? intersectSets(acc, set) : set;
            });
            focusSet = acc || new Set();
          } else if (worksetScope === 'connect') {
            if (selectedWorkset.size === 1) {
              focusSet = neighborhood(worksetIds[0]);
            } else {
              const adj = buildAdjacency();
              focusSet = new Set(worksetIds);
              for (let i = 0; i < worksetIds.length; i++) {
                for (let j = i + 1; j < worksetIds.length; j++) {
                  const path = shortestPath(adj, worksetIds[i], worksetIds[j]);
                  path.forEach(p => focusSet.add(p));
                }
              }
            }
          } else {
            focusSet = new Set();
            worksetIds.forEach(id => {
              neighborhood(id).forEach(x => focusSet.add(x));
            });
          }
        }
      }

      const depthMemo = new Map();
      const visiting = new Set();

      function depth(id) {
        if (depthMemo.has(id)) return depthMemo.get(id);
        if (visiting.has(id)) return 0;
        visiting.add(id);
        const n = nodeMap.get(id);
        if (!n || !n.depends_on || n.depends_on.length === 0) {
          depthMemo.set(id, 0);
          visiting.delete(id);
          return 0;
        }
        let d = 0;
        n.depends_on.forEach(dep => {
          if (nodeMap.has(dep)) d = Math.max(d, depth(dep) + 1);
        });
        depthMemo.set(id, d);
        visiting.delete(id);
        return d;
      }

      nodeList.forEach(n => depth(n.id));

      const groups = {};
      nodeList.forEach(n => {
        const d = depthMemo.get(n.id) || 0;
        groups[d] = groups[d] || [];
        groups[d].push(n);
      });

      Object.values(groups).forEach(g => g.sort((a,b) => a.id.localeCompare(b.id)));

      const maxDepth = Math.max(...Object.keys(groups).map(n => parseInt(n,10)), 0);
      const colWidth = 240;
      const rowHeight = 64;
      const margin = 20;

      const width = (maxDepth + 1) * colWidth + margin * 2;
      const maxRows = Math.max(...Object.values(groups).map(g => g.length), 1);
      const height = maxRows * rowHeight + margin * 2;

      const positions = {};
      Object.entries(groups).forEach(([d, arr]) => {
        arr.forEach((n, idx) => {
          positions[n.id] = {
            x: margin + parseInt(d,10) * colWidth,
            y: margin + idx * rowHeight,
          };
        });
      });

      const edges = [];
      nodeList.forEach(n => {
        n.depends_on.forEach(dep => {
          if (nodeMap.has(dep)) edges.push([dep, n.id]);
        });
      });
      const focus = focusSet;

      if (els.graphMeta) {
        let focusLabel = 'focus: none';
        if (focusMode === 'anchor') {
          focusLabel = selected ? `focus: ${selected}` : 'focus: anchor (none)';
        } else if (focusMode === 'workset') {
          focusLabel = selectedWorkset.size ? `focus: workset ${selectedWorkset.size} (${worksetScope})` : 'focus: workset (none)';
        }
        els.graphMeta.textContent = `Dependency graph (filtered set)  nodes: ${nodeList.length}, edges: ${edges.length}  ${focusLabel}`;
      }

      const svgParts = [];
      svgParts.push(`<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`);
      svgParts.push(`
        <defs>
          <marker id="arrow" markerWidth="8" markerHeight="8" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L6,3 L0,6 Z" fill="#777" />
          </marker>
        </defs>
      `);

      edges.forEach(([from, to]) => {
        const p1 = positions[from];
        const p2 = positions[to];
        if (!p1 || !p2) return;
        const x1 = p1.x + 180;
        const y1 = p1.y + 16;
        const x2 = p2.x;
        const y2 = p2.y + 16;
        let edgeClass = 'edge';
        if (focusMode === 'anchor' && selected) {
          if (!(focus && focus.has(from) && focus.has(to))) {
            edgeClass = 'edge dim';
          } else if ((from === selected || downstream.has(from)) && (downstream.has(to) || to === selected)) {
            edgeClass = 'edge downstream';
          } else if ((upstream.has(from) || from === selected) && (upstream.has(to) || to === selected)) {
            edgeClass = 'edge upstream';
          }
        } else if (focusMode === 'workset' && focus) {
          if (!(focus.has(from) && focus.has(to))) edgeClass = 'edge dim';
        }
        svgParts.push(`<line class="${edgeClass}" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" marker-end="url(#arrow)" />`);
      });

      nodeList.forEach(n => {
        const p = positions[n.id];
        if (!p) return;
        const fill = getTypeColor(n.type);
        const stroke = getTypeStroke(n.type);
        const dash = getStatusDash(n.status);
        const opacity = n.ghost ? 0.5 : 1;
        const conflict = (conflictsMap[n.id] || []).length > 0;
        let nodeClass = '';
        if (focusMode === 'anchor' && selected) {
          if (n.id === selected) nodeClass = ' selected';
          else if (downstream.has(n.id)) nodeClass = ' downstream';
          else if (upstream.has(n.id)) nodeClass = ' upstream';
          else nodeClass = ' dim';
        } else if (focusMode === 'workset' && focus) {
          if (selectedWorkset.has(n.id)) nodeClass = ' selected';
          else if (!focus.has(n.id)) nodeClass = ' dim';
        }
        svgParts.push(`
          <g class="node${nodeClass}" data-id="${n.id}" opacity="${opacity}">
            <rect x="${p.x}" y="${p.y}" rx="8" ry="8" width="180" height="32" fill="${fill}" stroke="${stroke}" stroke-width="1" stroke-dasharray="${dash}"></rect>
            <text x="${p.x + 8}" y="${p.y + 20}" fill="#1f2328">${n.id}${conflict ? ' *' : ''}</text>
          </g>
        `);
      });

      svgParts.push('</svg>');
      hideGraphTooltip();
      const tooltipNode = els.graphTooltip;
      els.graphPanel.innerHTML = '';
      if (tooltipNode) {
        tooltipNode.style.display = 'none';
        els.graphPanel.appendChild(tooltipNode);
      }
      els.graphPanel.insertAdjacentHTML('beforeend', svgParts.join('\\n'));

      els.graphPanel.querySelectorAll('.node').forEach(node => {
        node.addEventListener('click', () => {
          const id = node.getAttribute('data-id');
          if (id) selectClaim(id);
        });
        node.addEventListener('mouseenter', (e) => {
          const id = node.getAttribute('data-id');
          if (id) showGraphTooltip(e, id);
        });
        node.addEventListener('mousemove', (e) => moveGraphTooltip(e));
        node.addEventListener('mouseleave', () => hideGraphTooltip());
      });
    }

    function getTypeColor(type) {
      switch (type) {
        case 'invariant': return '#f7ecd0';
        case 'architectural_commitment': return '#e5efff';
        case 'mechanism_hypothesis': return '#e3f2ee';
        case 'open_question': return '#fdebd8';
        case 'implementation_note': return '#efeff2';
        default: return '#ffffff';
      }
    }

    function getTypeStroke(type) {
      switch (type) {
        case 'invariant': return '#dfc17a';
        case 'architectural_commitment': return '#9bb6e8';
        case 'mechanism_hypothesis': return '#92c9b7';
        case 'open_question': return '#e5b37d';
        case 'implementation_note': return '#c0c4ce';
        default: return '#c0c4ce';
      }
    }

    function getStatusDash(status) {
      switch (status) {
        case 'stable': return '0';
        case 'active': return '0';
        case 'provisional': return '6 4';
        case 'candidate': return '2 3';
        case 'legacy': return '4 2';
        default: return '0';
      }
    }

    function setView(view) {
      currentView = view;
      if (view === 'graph') {
        els.listWrap.style.display = 'none';
        els.graphWrap.style.display = 'block';
        els.docsWrap.style.display = 'none';
        els.mapWrap.style.display = 'none';
        els.governanceWrap.style.display = 'none';
        els.graphViewBtn.classList.add('primary');
        els.listViewBtn.classList.remove('primary');
        els.docsViewBtn.classList.remove('primary');
        els.mapViewBtn.classList.remove('primary');
        els.governanceViewBtn.classList.remove('primary');
        renderGraph();
      } else if (view === 'docs') {
        els.listWrap.style.display = 'none';
        els.graphWrap.style.display = 'none';
        els.docsWrap.style.display = 'block';
        els.mapWrap.style.display = 'none';
        els.governanceWrap.style.display = 'none';
        els.docsViewBtn.classList.add('primary');
        els.listViewBtn.classList.remove('primary');
        els.graphViewBtn.classList.remove('primary');
        els.mapViewBtn.classList.remove('primary');
        els.governanceViewBtn.classList.remove('primary');
        initDocs();
      } else if (view === 'map') {
        els.listWrap.style.display = 'none';
        els.graphWrap.style.display = 'none';
        els.docsWrap.style.display = 'none';
        els.mapWrap.style.display = 'block';
        els.governanceWrap.style.display = 'none';
        els.mapViewBtn.classList.add('primary');
        els.listViewBtn.classList.remove('primary');
        els.graphViewBtn.classList.remove('primary');
        els.docsViewBtn.classList.remove('primary');
        els.governanceViewBtn.classList.remove('primary');
        renderMap();
      } else if (view === 'governance') {
        els.listWrap.style.display = 'none';
        els.graphWrap.style.display = 'none';
        els.docsWrap.style.display = 'none';
        els.mapWrap.style.display = 'none';
        els.governanceWrap.style.display = 'block';
        els.governanceViewBtn.classList.add('primary');
        els.listViewBtn.classList.remove('primary');
        els.graphViewBtn.classList.remove('primary');
        els.docsViewBtn.classList.remove('primary');
        els.mapViewBtn.classList.remove('primary');
        renderGovernance();
        refreshGovernanceData();
      } else {
        els.listWrap.style.display = 'block';
        els.graphWrap.style.display = 'none';
        els.docsWrap.style.display = 'none';
        els.mapWrap.style.display = 'none';
        els.governanceWrap.style.display = 'none';
        els.listViewBtn.classList.add('primary');
        els.graphViewBtn.classList.remove('primary');
        els.docsViewBtn.classList.remove('primary');
        els.mapViewBtn.classList.remove('primary');
        els.governanceViewBtn.classList.remove('primary');
      }
    }

    function initDraftTabs() {
      const tabs = document.querySelectorAll('.draft-tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          const id = tab.getAttribute('data-tab');
          document.querySelectorAll('.draft-pane').forEach(p => p.classList.remove('active'));
          if (id === 'thought') document.getElementById('thoughtPane').classList.add('active');
          if (id === 'conflict') document.getElementById('conflictPane').classList.add('active');
        });
      });
    }

    let thoughtPrompt = FALLBACK_THOUGHT_PROMPT;
    let conflictPrompt = FALLBACK_CONFLICT_PROMPT;

    async function loadPrompts() {
      try {
        const readme = await fetchText(README_URL);
        const thought = extractPrompt(readme, 'THOUGHT INTAKE PROMPT');
        const conflict = extractPrompt(readme, 'CONFLICT RESOLUTION PROMPT');
        if (thought) thoughtPrompt = thought;
        if (conflict) conflictPrompt = conflict;
      } catch (_) {
        // fallback to embedded prompts
      }
    }

    function extractPrompt(text, heading) {
      const idx = text.indexOf(`## ${heading}`);
      if (idx < 0) return null;
      const slice = text.slice(idx);
      const match = slice.match(/```text\n([\s\S]*?)```/);
      return match ? match[1].trim() : null;
    }

    function buildThoughtDraft(text) {
      const related = Array.from(thoughtSelected).sort();
      const prefix = related.length ? `Related claims: ${related.join(', ')}\\n\\n` : '';
      return thoughtPrompt.replace('<PASTE YOUR THOUGHT HERE>', prefix + (text || ''));
    }

    function buildConflictDraft(refs, decision) {
      const refSet = new Set();
      if (refs) {
        refs.split(/[\\n,]/).map(r => r.trim()).filter(Boolean).forEach(r => refSet.add(r));
      }
      conflictSelectedFiles.forEach(f => refSet.add(f));
      conflictSelectedClaims.forEach(c => refSet.add(c));
      const refText = Array.from(refSet).join(', ');
      return conflictPrompt
        .replace('- <PASTE docs/conflicts/*.md PATHS OR CLAIM IDs>', `- ${refText}`)
        .replace('<DESCRIBE THE RESOLUTION IN YOUR OWN WORDS>', decision || '');
    }

    function setupDraftActions() {
      els.generateThought.addEventListener('click', () => {
        els.thoughtOutput.value = buildThoughtDraft(els.thoughtInput.value.trim());
      });
      els.copyThought.addEventListener('click', () => {
        els.thoughtOutput.select();
        document.execCommand('copy');
      });
      els.downloadThought.addEventListener('click', () => {
        downloadFile('thought_intake.md', els.thoughtOutput.value || buildThoughtDraft(els.thoughtInput.value.trim()));
      });

      els.generateConflict.addEventListener('click', () => {
        els.conflictOutput.value = buildConflictDraft(els.conflictRefs.value.trim(), els.conflictDecision.value.trim());
      });
      els.copyConflict.addEventListener('click', () => {
        els.conflictOutput.select();
        document.execCommand('copy');
      });
      els.downloadConflict.addEventListener('click', () => {
        downloadFile('conflict_resolution.md', els.conflictOutput.value || buildConflictDraft(els.conflictRefs.value.trim(), els.conflictDecision.value.trim()));
      });
    }

    function downloadFile(name, content) {
      const blob = new Blob([content], {type: 'text/markdown'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function wireEvents() {
      ['input', 'change'].forEach(evt => {
        els.search.addEventListener(evt, () => { renderTable(); renderGraph(); renderMap(); });
        els.typeFilter.addEventListener(evt, () => { renderTable(); renderGraph(); renderMap(); });
        els.statusFilter.addEventListener(evt, () => { renderTable(); renderGraph(); renderMap(); });
        els.subjectFilter.addEventListener(evt, () => { renderTable(); renderGraph(); renderMap(); });
        els.includeDeps.addEventListener(evt, () => renderGraph());
      });


      els.clearFilters.addEventListener('click', () => {
        els.search.value = '';
        els.typeFilter.value = '';
        els.statusFilter.value = '';
        els.subjectFilter.value = '';
        renderTable();
        renderGraph();
        renderMap();
      });

      els.listViewBtn.addEventListener('click', () => setView('list'));
      els.graphViewBtn.addEventListener('click', () => setView('graph'));
      if (els.docsViewBtn) {
        els.docsViewBtn.addEventListener('click', () => setView('docs'));
      }
      if (els.mapViewBtn) {
        els.mapViewBtn.addEventListener('click', () => setView('map'));
      }
      if (els.governanceViewBtn) {
        els.governanceViewBtn.addEventListener('click', () => setView('governance'));
      }
      if (els.mapEpochOnly) {
        els.mapEpochOnly.addEventListener('change', () => renderMap());
      }
      if (els.mapGovernanceOnly) {
        els.mapGovernanceOnly.addEventListener('change', () => renderMap());
      }
      if (els.mapLens) {
        els.mapLens.addEventListener('change', () => renderMap());
      }
      if (els.govEpochOnly) {
        els.govEpochOnly.addEventListener('change', () => {
          renderGovernance();
          renderMap();
        });
      }

      els.graphFocusRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          updateWorksetUI();
          renderGraph();
        });
      });
      els.worksetScopeRadios.forEach(radio => {
        radio.addEventListener('change', () => renderGraph());
      });
      if (els.worksetThought) {
        els.worksetThought.addEventListener('change', () => renderGraph());
      }
      if (els.worksetConflict) {
        els.worksetConflict.addEventListener('change', () => renderGraph());
      }

      if (els.docSelect) {
        els.docSelect.addEventListener('change', () => {
          if (els.docSelect.value) openDoc(els.docSelect.value);
        });
      }
      if (els.docSearch) {
        els.docSearch.addEventListener('input', () => {
          populateDocSelect(els.docSearch.value);
        });
      }
    }

    async function loadConflicts() {
      const conflicts = {};
      conflictFiles = [];
      try {
        const indexText = await fetchText(CONFLICT_INDEX_URL);
        const fileMatches = Array.from(indexText.matchAll(/docs\/conflicts\/[^\s`]+\.md/g));
        const files = Array.from(new Set(fileMatches.map(m => m[0])));
        conflictFiles = files;
        for (const file of files) {
          const rel = relativeLink(file);
          try {
            const content = await fetchText(rel);
            const ids = content.match(/\b[A-Z]{2,5}-\d{3}\b/g) || [];
            ids.forEach(id => {
              if (!conflicts[id]) conflicts[id] = [];
              conflicts[id].push(file);
            });
          } catch (_) {
            // skip unreadable conflict file
          }
        }
      } catch (_) {
        // no conflicts index or fetch failed
      }
      return conflicts;
    }

    async function refreshData() {
      const filterState = readFilterState();
      const previousView = currentView;
      const previousSelection = selectedId;

      const claimsText = await fetchText(CLAIMS_URL);
      const normalizedClaims = claimsText
        .replace(/\uFEFF/g, '')
        .replace(/\u200B/g, '')
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n');
      if (/^\s*</.test(normalizedClaims)) {
        throw new Error('claims.yaml returned HTML (not YAML). Start the server from repo root and reload.');
      }
      if (!/id:\s*(INV|ARC|MECH|IMPL|Q)-\d{3}/i.test(normalizedClaims)) {
        throw new Error('claims.yaml did not include any "id:" entries. Check the claims.yaml URL in your browser.');
      }
      await loadSubsystemMap();
      const parsed = parseClaimsYaml(normalizedClaims);
      if (!parsed.length) {
        const lines = normalizedClaims.split('\n');
        const preview = lines.slice(0, 6).join(' | ').slice(0, 300);
        throw new Error(`Parsed 0 claims from claims.yaml (lines: ${lines.length}). Preview: ${preview}`);
      }
      allClaims = parsed.map(normalizeClaim);
      claimMap = new Map(allClaims.map(c => [c.id, c]));
      conflictsMap = await loadConflicts();
      claimTextCache.clear();
      fileCache.clear();
      for (const id of Array.from(thoughtSelected)) {
        if (!claimMap.has(id)) thoughtSelected.delete(id);
      }
      for (const id of Array.from(conflictSelectedClaims)) {
        if (!claimMap.has(id)) conflictSelectedClaims.delete(id);
      }
      for (const file of Array.from(conflictSelectedFiles)) {
        if (!conflictFiles.includes(file)) conflictSelectedFiles.delete(file);
      }

      buildStats();
      populateFilters();
      renderPickers();
      restoreFilterState(filterState);
      renderTable();
      setView(previousView || 'list');
      renderMap();

      if (previousSelection && claimMap.has(previousSelection)) {
        selectClaim(previousSelection);
      } else if (previousSelection) {
        selectedId = null;
        if (els.detailContent) {
          els.detailContent.innerHTML = '<div class="meta">Select a claim to see details.</div>';
        }
      }

      await loadPrompts();
      await refreshGovernanceData();
      updateRefreshStatus();
    }

    async function init() {
      const isFile = window.location.protocol === 'file:';
      if (isFile) {
        showErrorHtml(
          'Opened via <code>file://</code>. This page needs a local server to read repo files.<br><br>' +
          'Steps:<br>' +
          '<pre>cd /Users/dgolden/Documents/GitHub/REE_assembly\npython3 -m http.server</pre>' +
          'Then open:<br>' +
          '<pre>http://localhost:8000/docs/claims/explorer.html</pre>'
        );
        return;
      } else {
        hideError();
      }

      if (!initialized) {
        initDraftTabs();
        setupDraftActions();
        wireEvents();
        updateWorksetUI();
        initialized = true;
      }

      try {
        await refreshData();
        if (!refreshTimer) {
          refreshTimer = setInterval(() => {
            refreshData().catch(err => showError(`Failed to refresh claims: ${String(err)}`));
          }, REFRESH_MS);
        }
      } catch (err) {
        showError(`Failed to load claims: ${String(err)}`);
      }
    }

    init();
  </script>
</body>
</html>
