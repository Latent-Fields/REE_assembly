<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>REE Claims Explorer</title>
  <style>
    :root {
      --bg: #f5f1e8;
      --bg-2: #efe6d9;
      --ink: #1f2328;
      --muted: #5b5f66;
      --accent: #2b6f72;
      --accent-2: #b45a2a;
      --card: #ffffff;
      --border: #d8d0c3;
      --shadow: rgba(31,35,40,0.08);
      --error: #8c2f2f;
      --error-bg: #fbecec;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Avenir Next", "Gill Sans", "Segoe UI", sans-serif;
      color: var(--ink);
      background: radial-gradient(1200px 800px at 20% 0%, var(--bg), var(--bg-2));
    }

    header {
      padding: 28px 24px 12px 24px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.5));
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 5;
    }

    h1 {
      margin: 0 0 6px 0;
      font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
      letter-spacing: 0.4px;
      font-size: 28px;
    }

    .subtitle {
      color: var(--muted);
      font-size: 14px;
    }

    .stats {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    .stat-card {
      background: var(--card);
      border: 1px solid var(--border);
      padding: 8px 12px;
      border-radius: 10px;
      box-shadow: 0 2px 8px var(--shadow);
      font-size: 13px;
    }

    main {
      padding: 18px 24px 32px 24px;
    }

    .error-banner {
      display: none;
      background: var(--error-bg);
      color: var(--error);
      border: 1px solid var(--error);
      border-radius: 10px;
      padding: 10px 12px;
      margin-bottom: 12px;
      font-size: 13px;
    }
    .error-banner pre {
      margin: 6px 0 10px 0;
      padding: 8px;
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: auto;
      font-size: 12px;
    }
    .error-banner code {
      background: #fff;
      border: 1px solid var(--border);
      padding: 1px 4px;
      border-radius: 4px;
    }

    .controls {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 2px 8px var(--shadow);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      align-items: end;
    }

    .controls label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 4px;
    }

    input, select, textarea {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
      color: var(--ink);
      font-size: 14px;
    }

    .buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      border: 1px solid var(--border);
      background: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
    }

    button.primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    button.ghost {
      background: transparent;
    }

    .layout {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 16px;
      margin-top: 16px;
    }

    .layout > * {
      min-width: 0;
    }

    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 2px 8px var(--shadow);
      padding: 12px;
      overflow: hidden;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    th, td {
      text-align: left;
      padding: 8px 6px;
      border-bottom: 1px solid #eee;
      vertical-align: top;
    }

    th {
      font-size: 12px;
      color: var(--muted);
    }

    tr:hover {
      background: #faf7f1;
      cursor: pointer;
    }

    tr.selected {
      background: #f0f7f6;
    }

    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid var(--border);
    }

    .type-invariant { background: #f7ecd0; border-color: #dfc17a; }
    .type-architectural_commitment { background: #e5efff; border-color: #9bb6e8; }
    .type-mechanism_hypothesis { background: #e3f2ee; border-color: #92c9b7; }
    .type-implementation_note { background: #efeff2; border-color: #c0c4ce; }
    .type-open_question { background: #fdebd8; border-color: #e5b37d; }

    .status-stable { border-left: 4px solid #2f6f3e; padding-left: 6px; }
    .status-provisional { border-left: 4px dashed #b67923; padding-left: 6px; }
    .status-candidate { border-left: 4px dotted #7a4e2e; padding-left: 6px; }
    .status-legacy { border-left: 4px solid #8c2f2f; padding-left: 6px; }
    .status-active { border-left: 4px solid #2f6f3e; padding-left: 6px; }

    .conflict { color: #8c2f2f; font-weight: 600; }

    .detail h2 {
      margin: 0 0 8px 0;
      font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
      font-size: 20px;
    }

    .detail .meta {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 10px;
    }

    .detail ul {
      list-style: none;
      padding: 0;
      margin: 0 0 8px 0;
    }

    .detail li {
      margin-bottom: 4px;
    }

    .panel.detail {
      position: sticky;
      top: 120px;
      align-self: start;
      max-height: calc(100vh - 160px);
      overflow: auto;
    }

    .panel.table-panel {
      max-height: calc(100vh - 160px);
      overflow: auto;
    }

    .selected-summary {
      position: sticky;
      top: 0;
      background: var(--card);
      padding-bottom: 8px;
      margin-bottom: 10px;
      border-bottom: 1px dashed var(--border);
      z-index: 1;
    }

    .selected-group {
      margin-bottom: 8px;
    }

    .selected-label {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #f0f7f6;
      font-size: 11px;
      cursor: pointer;
    }

    .chip.empty {
      background: #fff;
      color: var(--muted);
      cursor: default;
    }

    .excerpt-content {
      background: #fbfaf6;
      border: 1px solid var(--border);
      padding: 10px;
      border-radius: 8px;
      max-height: 380px;
      overflow: auto;
      font-size: 12px;
      line-height: 1.45;
    }

    .conflict-detail {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      background: #fff;
      margin: 8px 0;
    }

    .conflict-detail summary {
      font-weight: 600;
      color: #6d4c1f;
    }

    .conflict-meta {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .conflict-body {
      margin-top: 8px;
      font-size: 12px;
      color: var(--ink);
      line-height: 1.5;
    }

    .conflict-block {
      margin: 8px 0;
    }

    details summary {
      cursor: pointer;
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }

    #leftWrap {
      display: block;
      min-width: 0;
    }

    #graphWrap {
      display: none;
      min-width: 0;
    }

    .graph-panel-wrap {
      max-height: calc(100vh - 160px);
      overflow: hidden;
      position: relative;
      min-width: 0;
    }

    .graph-panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px;
      overflow: auto;
      max-height: 520px;
      position: relative;
      min-height: 260px;
      max-width: 100%;
    }

    .graph-panel svg {
      display: block;
    }

    .graph-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 8px 0 10px 0;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
      color: var(--ink);
    }

    .control-group.inactive {
      opacity: 0.6;
    }

    .control-label {
      font-size: 11px;
      color: var(--muted);
    }

    .graph-controls label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--ink);
    }

    .graph-controls input {
      width: auto;
    }

    .docs-wrap {
      max-height: calc(100vh - 160px);
      overflow: auto;
      display: none;
      min-width: 0;
    }

    .triple-view-wrap {
      max-height: calc(100vh - 160px);
      overflow: auto;
      display: none;
      min-width: 0;
    }

    .triple-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .triple-toolbar .meta {
      margin: 0;
    }

    .triple-meta-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .triple-meta-row .meta {
      margin: 0;
    }

    .triple-epoch-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      background: #f8f5ef;
      color: var(--muted);
    }

    .triple-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .triple-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      padding: 10px;
      box-shadow: 0 2px 8px var(--shadow);
    }

    .triple-card-head {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .triple-card-head h3 {
      margin: 0;
      font-size: 16px;
      font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
    }

    .triple-links {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .triple-links a {
      display: inline-flex;
      align-items: center;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: #fff;
      color: var(--accent);
      text-decoration: none;
      font-size: 11px;
      padding: 2px 8px;
    }

    .triple-links a:hover {
      text-decoration: underline;
    }

    .triple-controls {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .triple-controls button {
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fff;
      color: var(--ink);
      font-size: 12px;
      line-height: 1;
      padding: 4px 8px;
      cursor: pointer;
    }

    .triple-controls button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .triple-controls .zoom-value {
      min-width: 46px;
      font-size: 12px;
      color: var(--muted);
    }

    .triple-controls .hint {
      font-size: 11px;
      color: var(--muted);
    }

    .triple-body {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
      min-height: 200px;
      max-height: 520px;
      overflow: auto;
      padding: 8px;
      position: relative;
    }

    .triple-body.zoomable {
      cursor: grab;
    }

    .triple-body.zoomable.dragging {
      cursor: grabbing;
      user-select: none;
    }

    .triple-body svg {
      display: block;
      width: 100%;
      max-width: none;
      height: auto;
    }

    .triple-code {
      margin: 8px 0 0 0;
      background: #f7f5f0;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      overflow: auto;
      font-size: 12px;
      font-family: "SFMono-Regular", Menlo, Consolas, monospace;
      white-space: pre;
    }

    .triple-node-badges {
      pointer-events: none;
    }

    .triple-node-badge {
      stroke-width: 1;
    }

    .triple-node-badge.claims {
      fill: #e8f2f2;
      stroke: #2b6f72;
    }

    .triple-node-badge.conflicts {
      fill: #fbecec;
      stroke: #8c2f2f;
    }

    .triple-node-badge.needs {
      fill: #fff5de;
      stroke: #b67923;
    }

    .triple-node-badge-text {
      font-size: 9px;
      fill: #1f2328;
      font-weight: 600;
      text-anchor: middle;
      dominant-baseline: central;
    }

    .triple-edge-marker {
      pointer-events: none;
    }

    .triple-edge-marker circle {
      stroke-width: 1;
      fill: #fff;
    }

    .triple-edge-marker.conflicts circle {
      stroke: #8c2f2f;
    }

    .triple-edge-marker.questions circle {
      stroke: #b67923;
    }

    .triple-edge-marker text {
      font-size: 9px;
      fill: #1f2328;
      font-weight: 600;
      text-anchor: middle;
      dominant-baseline: central;
    }

    .triple-edge-conflict {
      stroke: #8c2f2f !important;
      stroke-width: 2.3px !important;
    }

    .triple-edge-open {
      stroke-dasharray: 5 3 !important;
    }

    .triple-target {
      cursor: pointer;
    }

    .triple-target:focus-visible {
      outline: none;
      filter: drop-shadow(0 0 0.35rem rgba(43, 111, 114, 0.35));
    }

    .triple-tooltip {
      position: fixed;
      z-index: 20;
      display: none;
      width: min(360px, calc(100vw - 24px));
      max-height: 320px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      box-shadow: 0 8px 22px rgba(0,0,0,0.14);
      padding: 10px;
      font-size: 12px;
      color: var(--ink);
    }

    .triple-tooltip .title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .triple-tooltip .meta {
      margin-bottom: 4px;
      font-size: 11px;
      color: var(--muted);
    }

    .triple-tooltip ul {
      margin: 6px 0;
      padding-left: 16px;
    }

    .triple-tooltip li {
      margin: 0 0 4px 0;
      line-height: 1.35;
    }

    .triple-tooltip .actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 6px;
    }

    .triple-tooltip .actions button {
      padding: 4px 8px;
      font-size: 11px;
    }

    .triple-inspector {
      display: grid;
      gap: 8px;
    }

    .triple-inspector h2 {
      margin: 0;
      font-size: 20px;
      font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
    }

    .triple-inspector .meta {
      margin: 0;
    }

    .triple-inspector .inspector-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }

    .triple-inspector .inspector-tabs button {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
    }

    .triple-inspector .inspector-tabs button.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    .triple-inspector .inspector-pane {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      background: #fff;
      display: none;
      max-height: 330px;
      overflow: auto;
    }

    .triple-inspector .inspector-pane.active {
      display: block;
    }

    .triple-inspector .inspector-list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 6px;
    }

    .triple-inspector .inspector-item {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 8px;
      background: #fbfaf6;
      font-size: 12px;
      line-height: 1.4;
    }

    .triple-inspector .inspector-item .meta {
      margin-top: 2px;
      font-size: 11px;
    }

    .triple-inspector .inspector-empty {
      font-size: 12px;
      color: var(--muted);
    }

    .triple-inspector .inspector-close {
      justify-self: end;
      font-size: 12px;
      padding: 4px 8px;
    }

    .governance-wrap {
      display: none;
      max-height: calc(100vh - 160px);
      overflow: auto;
      min-width: 0;
    }

    .governance-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }

    .gov-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      padding: 10px;
      box-shadow: 0 2px 8px var(--shadow);
    }

    .gov-card .label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .gov-card .value {
      font-size: 20px;
      font-weight: 600;
      line-height: 1;
    }

    .gov-meta {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 10px;
    }

    .gov-staleness {
      display: inline-block;
      margin-left: 6px;
      padding: 2px 8px;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 11px;
      vertical-align: middle;
    }

    .gov-staleness.fresh { background: #e7f5eb; border-color: #8fc4a0; color: #24583a; }
    .gov-staleness.stale { background: #fff5de; border-color: #d8b36d; color: #7c5a1f; }
    .gov-staleness.old { background: #fbecec; border-color: #c98f8f; color: #8c2f2f; }

    .gov-toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .gov-toolbar label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--ink);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 10px;
      background: #f8f5ef;
    }

    .gov-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      border: 1px solid var(--border);
      background: #f8f5ef;
      margin-left: 6px;
    }

    .gov-pill.human {
      background: #fbecec;
      border-color: #c98f8f;
      color: #8c2f2f;
    }

    .gov-pill.creative {
      background: #e9f1fb;
      border-color: #93afcf;
      color: #24466b;
    }

    .gov-sections {
      display: grid;
      gap: 12px;
    }

    .gov-section {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      background: #fff;
    }

    .gov-section h3 {
      margin: 0 0 8px 0;
      font-size: 15px;
      font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
    }

    .gov-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .gov-table th,
    .gov-table td {
      border-bottom: 1px solid #eee;
      padding: 6px 5px;
      text-align: left;
      vertical-align: top;
    }

    .gov-table th {
      color: var(--muted);
      font-size: 11px;
      white-space: nowrap;
    }

    .gov-empty {
      color: var(--muted);
      font-size: 12px;
      padding: 6px 0;
    }

    .gov-context-links {
      margin: 4px 0 10px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .gov-link-chip {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #f7f2e9;
      font-size: 11px;
      text-decoration: none;
      color: var(--ink);
    }

    .gov-claim-cell {
      display: grid;
      gap: 2px;
      min-width: 200px;
    }

    .gov-claim-meta {
      color: var(--muted);
      font-size: 11px;
    }

    .command-list {
      display: grid;
      gap: 8px;
    }

    .command-row {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      background: #f8f5ef;
    }

    .command-row code {
      display: block;
      white-space: pre-wrap;
      word-break: break-all;
      font-size: 12px;
      margin: 4px 0 8px 0;
    }

    .map-wrap {
      display: none;
      max-height: calc(100vh - 160px);
      overflow: auto;
      min-width: 0;
    }

    .map-toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .map-toolbar label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--ink);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 10px;
      background: #f8f5ef;
    }

    .map-summary {
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 8px 0;
    }

    .map-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
    }

    .map-card {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      background: #fff;
      box-shadow: 0 2px 8px var(--shadow);
    }

    .map-card.heat-low {
      border-color: #9ab6d6;
      background: linear-gradient(180deg, #f7fbff 0%, #ffffff 100%);
    }

    .map-card.heat-medium {
      border-color: #d8b36d;
      background: linear-gradient(180deg, #fffaf0 0%, #ffffff 100%);
    }

    .map-card.heat-high {
      border-color: #c98f8f;
      background: linear-gradient(180deg, #fff5f5 0%, #ffffff 100%);
    }

    .map-card h3 {
      margin: 0 0 6px 0;
      font-size: 15px;
      font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
    }

    .map-meta {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .map-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .map-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #f7f2e9;
      font-size: 11px;
      cursor: pointer;
    }

    .map-chip.signal-decision {
      border-color: #c98f8f;
      background: #fbecec;
    }

    .map-chip.signal-creative {
      border-color: #93afcf;
      background: #e9f1fb;
    }

    .map-chip.signal-conflict {
      border-color: #d8b36d;
      background: #fff5de;
    }

    .map-chip.stale-only {
      opacity: 0.65;
    }

    .map-chip.selected {
      border-color: var(--accent);
      background: #e7f1f1;
    }

    .map-badges {
      display: inline-flex;
      gap: 3px;
      align-items: center;
    }

    .map-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      font-size: 9px;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--muted);
      font-weight: 600;
    }

    .map-badge.decision {
      border-color: #c98f8f;
      color: #8c2f2f;
      background: #fbecec;
    }

    .map-badge.creative {
      border-color: #93afcf;
      color: #24466b;
      background: #e9f1fb;
    }

    .map-badge.conflict {
      border-color: #d8b36d;
      color: #7c5a1f;
      background: #fff5de;
    }

    .legend-wrap {
      border: 1px dashed var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      background: #fcfaf5;
      margin: 0 0 10px 0;
    }

    .legend-title {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .legend-note {
      margin-left: auto;
      font-size: 11px;
      color: var(--muted);
    }

    .legend-toggle {
      margin-left: 6px;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--muted);
      border-radius: 999px;
      font-size: 11px;
      padding: 2px 8px;
      cursor: pointer;
      line-height: 1.4;
    }

    .legend-toggle.push {
      margin-left: auto;
    }

    .legend-toggle:hover {
      color: var(--ink);
      border-color: #b7ae9d;
    }

    .legend-body[hidden] {
      display: none;
    }

    .legend-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 6px;
    }

    .legend-row:last-child {
      margin-bottom: 0;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #fff;
      font-size: 11px;
    }

    .legend-node {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      border: 1px solid var(--border);
      display: inline-block;
      flex-shrink: 0;
    }

    .legend-node.invariant { background: #f7ecd0; border-color: #dfc17a; }
    .legend-node.architectural_commitment { background: #e5efff; border-color: #9bb6e8; }
    .legend-node.mechanism_hypothesis { background: #e3f2ee; border-color: #92c9b7; }
    .legend-node.open_question { background: #fdebd8; border-color: #e5b37d; }
    .legend-node.implementation_note { background: #efeff2; border-color: #c0c4ce; }

    .legend-status {
      width: 16px;
      height: 10px;
      border: 2px solid #7f7f7f;
      border-radius: 3px;
      display: inline-block;
      flex-shrink: 0;
    }

    .legend-status.provisional { border-style: dashed; }
    .legend-status.candidate { border-style: dotted; }
    .legend-status.legacy { border-style: solid; border-color: #8c2f2f; }

    .legend-line {
      width: 18px;
      border-top: 2px solid #777;
      display: inline-block;
      flex-shrink: 0;
    }

    .legend-line.upstream {
      border-top: 2px dashed var(--accent-2);
    }

    .legend-line.downstream {
      border-top: 2px solid var(--accent);
    }

    .legend-line.dim {
      border-top: 2px solid #cfc6b8;
    }

    .legend-swatch {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      border: 1px solid var(--border);
      display: inline-block;
      flex-shrink: 0;
      background: #fff;
    }

    .legend-swatch.heat-low {
      border-color: #9ab6d6;
      background: #f7fbff;
    }

    .legend-swatch.heat-medium {
      border-color: #d8b36d;
      background: #fffaf0;
    }

    .legend-swatch.heat-high {
      border-color: #c98f8f;
      background: #fff5f5;
    }

    .map-legend .map-chip {
      cursor: default;
      pointer-events: none;
    }

    .map-legend .map-badge {
      pointer-events: none;
    }

    .help-tip {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: #fff;
      color: var(--muted);
      font-size: 11px;
      line-height: 1;
      cursor: help;
      user-select: none;
      outline: none;
    }

    .help-tip::after {
      content: attr(data-tip);
      position: absolute;
      left: 50%;
      top: calc(100% + 8px);
      transform: translateX(-50%);
      background: #1f2328;
      color: #fff;
      border-radius: 8px;
      padding: 6px 8px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.16);
      font-size: 11px;
      line-height: 1.35;
      width: max-content;
      max-width: 280px;
      min-width: 180px;
      white-space: normal;
      opacity: 0;
      pointer-events: none;
      z-index: 8;
    }

    .help-tip:hover::after,
    .help-tip:focus-visible::after {
      opacity: 1;
    }

    .docs-toolbar {
      display: grid;
      grid-template-columns: minmax(200px, 1fr) minmax(180px, 240px);
      gap: 12px;
      align-items: end;
      margin-bottom: 8px;
    }

    .doc-meta {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .doc-content {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      background: #fff;
      max-height: calc(100vh - 280px);
      overflow: auto;
      font-size: 13px;
      line-height: 1.5;
    }

    .doc-content h1,
    .doc-content h2,
    .doc-content h3,
    .doc-content h4 {
      font-family: "Iowan Old Style", "Palatino Linotype", Palatino, serif;
    }

    .doc-content h1 { font-size: 22px; margin: 16px 0 8px; }
    .doc-content h2 { font-size: 18px; margin: 14px 0 6px; }
    .doc-content h3 { font-size: 16px; margin: 12px 0 6px; }
    .doc-content h4 { font-size: 14px; margin: 10px 0 6px; }

    .doc-content p { margin: 8px 0; }
    .doc-content ul,
    .doc-content ol { padding-left: 20px; margin: 8px 0; }
    .doc-content li { margin-bottom: 4px; }
    .doc-content pre {
      background: #f7f5f0;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      overflow: auto;
      font-size: 12px;
    }
    .doc-content code {
      background: #f7f5f0;
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 1px 4px;
      font-size: 12px;
    }
    .doc-content a {
      color: var(--accent);
      text-decoration: none;
    }
    .doc-content a:hover {
      text-decoration: underline;
    }
    .doc-content blockquote {
      border-left: 3px solid var(--border);
      padding-left: 10px;
      color: var(--muted);
      margin: 8px 0;
    }

    .doc-open {
      margin-left: 6px;
      padding: 2px 6px;
      font-size: 11px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #fff;
      cursor: pointer;
    }

    svg text {
      font-size: 11px;
    }

    .node {
      cursor: pointer;
    }

    .node:hover rect {
      stroke-width: 2;
    }

    .node.selected rect {
      stroke: var(--accent-2);
      stroke-width: 2;
    }

    .node.dim {
      opacity: 0.2;
    }

    .node.upstream rect {
      stroke: var(--accent-2);
      stroke-width: 1.5;
      stroke-dasharray: 4 3;
    }

    .node.downstream rect {
      stroke: var(--accent);
      stroke-width: 1.8;
    }

    .edge {
      stroke: #777;
      stroke-width: 1.4;
    }

    .edge.dim {
      stroke: #cfc6b8;
      stroke-width: 1;
      opacity: 0.35;
    }

    .edge.upstream {
      stroke: var(--accent-2);
      stroke-width: 1.4;
      stroke-dasharray: 4 3;
    }

    .edge.downstream {
      stroke: var(--accent);
      stroke-width: 2;
    }

    .graph-tooltip {
      position: absolute;
      z-index: 2;
      display: none;
      max-width: 280px;
      background: #fff;
      border: 1px solid var(--border);
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      color: var(--ink);
      pointer-events: none;
    }

    .graph-tooltip .title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .graph-tooltip .meta {
      font-size: 11px;
      color: var(--muted);
    }

    .claim-toggles {
      display: flex;
      gap: 12px;
      align-items: center;
      margin: 8px 0;
      font-size: 12px;
      color: var(--muted);
    }

    .claim-toggles input {
      width: auto;
      margin-right: 4px;
    }

    .drafts {
      margin-top: 20px;
    }

    .draft-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .draft-tab {
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      background: #fff;
      font-size: 13px;
    }

    .draft-tab.active {
      background: var(--accent-2);
      color: #fff;
      border-color: var(--accent-2);
    }

    .draft-pane {
      display: none;
    }

    .draft-pane.active {
      display: block;
    }

    .draft-output {
      min-height: 180px;
      font-family: "SFMono-Regular", Menlo, Consolas, monospace;
      font-size: 12px;
    }

    .picker {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      max-height: 160px;
      overflow: auto;
      background: #fff;
      font-size: 12px;
    }

    .picker-item {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      margin-bottom: 6px;
    }

    .picker-item:last-child {
      margin-bottom: 0;
    }

    .footer {
      margin-top: 24px;
      color: var(--muted);
      font-size: 12px;
    }

    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <h1>REE Claims Explorer</h1>
    <div class="subtitle">Browse claims, dependencies, and conflicts. Generate intake and resolution drafts.</div>
    <div class="subtitle" style="margin-top:6px;">Auto-updates require a local server (not file://). Run: <code>python3 -m http.server</code> from repo root.</div>
    <div class="subtitle" id="refreshStatus" style="margin-top:6px;">Last refreshed: --</div>
    <div id="stats" class="stats"></div>
  </header>

  <main>
    <div id="errorBanner" class="error-banner"></div>

    <section class="controls">
      <div>
        <label for="search">Search</label>
        <input id="search" type="text" placeholder="ID, subject, type..." />
      </div>
      <div>
        <label for="typeFilter">Type</label>
        <select id="typeFilter"></select>
      </div>
      <div>
        <label for="statusFilter">Status</label>
        <select id="statusFilter"></select>
      </div>
      <div>
        <label for="subjectFilter">Subject (contains)</label>
        <input id="subjectFilter" type="text" list="subjectList" placeholder="ethics.persistence" />
        <datalist id="subjectList"></datalist>
      </div>
      <div>
        <label for="viewToggle">View</label>
        <div class="buttons">
          <button id="listViewBtn" class="primary">List</button>
          <button id="graphViewBtn">Graph</button>
          <button id="docsViewBtn">Docs</button>
          <button id="mapViewBtn">Map</button>
          <button id="tripleViewBtn">Triple View</button>
          <button id="governanceViewBtn">Governance</button>
        </div>
      </div>
      <div>
        <label for="includeDeps">Graph Options</label>
        <div class="buttons">
          <label style="display:flex;align-items:center;gap:6px;font-size:12px;">
            <input id="includeDeps" type="checkbox" checked />
            Include dependencies
          </label>
        </div>
      </div>
      <div>
        <label>Actions</label>
        <div class="buttons">
          <button id="clearFilters" class="ghost">Clear Filters</button>
        </div>
      </div>
    </section>

    <section id="viewWrap" class="layout">
      <div id="leftWrap">
        <div id="listWrap" class="panel table-panel">
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>Type</th>
                <th>Status</th>
                <th>Subject</th>
                <th>Depends On</th>
                <th>Conflicts</th>
                <th>Thought</th>
                <th>Conflict</th>
              </tr>
            </thead>
            <tbody id="claimsTable"></tbody>
          </table>
        </div>
        <div id="graphWrap" class="panel graph-panel-wrap">
        <div class="meta" id="graphMeta">Dependency graph (filtered set)</div>
        <div class="graph-controls">
          <div class="control-group">
            <div class="control-label">Graph focus</div>
            <div class="buttons">
              <label title="Focus on a single selected claim.">
                <input type="radio" name="graphFocus" value="anchor" checked />
                Anchor
              </label>
              <label title="Focus on the selected workset claims.">
                <input type="radio" name="graphFocus" value="workset" />
                Workset
              </label>
            </div>
          </div>
          <div class="control-group workset-only">
            <div class="control-label">Workset scope</div>
            <div class="buttons">
              <label title="Show anything connected to any selected claim; broad context.">
                <input type="radio" name="worksetScope" value="union" checked />
                Union
              </label>
              <label title="Show only nodes connected to all selected claims; shared core.">
                <input type="radio" name="worksetScope" value="intersection" />
                Intersection
              </label>
              <label title="Show selected claims plus minimal dependency paths between them.">
                <input type="radio" name="worksetScope" value="connect" />
                Connect
              </label>
            </div>
          </div>
          <div class="control-group workset-only">
            <div class="control-label">Workset source</div>
            <div class="buttons">
              <label title="Use Thought selections from the list.">
                <input type="checkbox" id="worksetThought" checked />
                Thought
              </label>
              <label title="Use Conflict selections from the list.">
                <input type="checkbox" id="worksetConflict" checked />
                Conflict
              </label>
            </div>
          </div>
        </div>
          <div class="legend-wrap" id="graphLegend">
            <div class="legend-title">
              Graph key
              <span class="help-tip" tabindex="0" data-tip="Hover nodes for quick claim details. Click a node to open the claim panel and related conflicts.">?</span>
              <button type="button" class="legend-toggle push" data-target="graphLegendBody" data-pref="graph">Hide key</button>
            </div>
            <div class="legend-body" id="graphLegendBody">
              <div class="legend-row">
                <span class="legend-item"><span class="legend-node invariant"></span>Invariant</span>
                <span class="legend-item"><span class="legend-node architectural_commitment"></span>Architectural commitment</span>
                <span class="legend-item"><span class="legend-node mechanism_hypothesis"></span>Mechanism hypothesis</span>
                <span class="legend-item"><span class="legend-node open_question"></span>Open question</span>
                <span class="legend-item"><span class="legend-node implementation_note"></span>Implementation note</span>
              </div>
              <div class="legend-row">
                <span class="legend-item"><span class="legend-status"></span>Stable/active</span>
                <span class="legend-item"><span class="legend-status provisional"></span>Provisional</span>
                <span class="legend-item"><span class="legend-status candidate"></span>Candidate</span>
                <span class="legend-item"><span class="legend-status legacy"></span>Legacy</span>
              </div>
              <div class="legend-row">
                <span class="legend-item"><span class="legend-line"></span>Dependency edge</span>
                <span class="legend-item"><span class="legend-line upstream"></span>Upstream focus path</span>
                <span class="legend-item"><span class="legend-line downstream"></span>Downstream focus path</span>
                <span class="legend-item"><span class="legend-line dim"></span>Outside focus</span>
                <span class="legend-item"><code>*</code> Claim has conflict file(s)</span>
              </div>
            </div>
          </div>
          <div class="graph-panel" id="graphPanel"></div>
          <div class="graph-tooltip" id="graphTooltip"></div>
        </div>
        <div id="docsWrap" class="panel docs-wrap">
          <div class="docs-toolbar">
            <div>
              <label for="docSelect">Document</label>
              <select id="docSelect"></select>
            </div>
            <div>
              <label for="docSearch">Filter</label>
              <input id="docSearch" type="text" placeholder="Filter docs..." />
            </div>
          </div>
          <div id="docMeta" class="doc-meta"></div>
          <div id="docContent" class="doc-content"></div>
        </div>
        <div id="mapWrap" class="panel map-wrap">
          <div class="meta">Subsystem map (filtered set)</div>
          <div class="map-toolbar">
            <label title="Choose map interpretation lens.">
              Lens
              <select id="mapLens">
                <option value="atlas" selected>Subsystem Atlas</option>
                <option value="governance_heat">Governance Heat</option>
              </select>
            </label>
            <label title="Hide claims with zero applicable evidence in the current architecture epoch.">
              <input type="checkbox" id="mapEpochOnly" checked />
              Current Epoch Only
            </label>
            <label title="Show only claims currently touched by governance queues (conflict/decision/structure).">
              <input type="checkbox" id="mapGovernanceOnly" />
              Governance-Signaled Only
            </label>
          </div>
          <div class="legend-wrap map-legend" id="mapLegend">
            <div class="legend-title">
              Map key
              <span class="help-tip" tabindex="0" data-tip="Each chip is a claim. Click a chip to open full claim context in the right-side panel.">?</span>
              <span class="legend-note" id="mapLegendMode">Subsystem Atlas lens active</span>
              <button type="button" class="legend-toggle" data-target="mapLegendBody" data-pref="map">Hide key</button>
            </div>
            <div class="legend-body" id="mapLegendBody">
              <div class="legend-row">
                <span class="legend-item"><span class="map-badge decision">D</span>Human decision queue</span>
                <span class="legend-item"><span class="map-badge creative">I</span>Human inspiration / generative input</span>
                <span class="legend-item"><span class="map-badge conflict">C</span>Conflict queue</span>
              </div>
              <div class="legend-row">
                <span class="map-chip">MECH-000</span>
                <span class="map-chip selected">Selected claim</span>
                <span class="map-chip stale-only">Stale-only (not current epoch)</span>
              </div>
              <div class="legend-row">
                <span class="legend-item" data-lens-only="governance_heat"><span class="legend-swatch heat-low"></span>Low heat</span>
                <span class="legend-item" data-lens-only="governance_heat"><span class="legend-swatch heat-medium"></span>Medium heat</span>
                <span class="legend-item" data-lens-only="governance_heat"><span class="legend-swatch heat-high"></span>High heat</span>
                <span class="legend-item" data-lens-only="atlas">Heat colors appear only in Governance Heat lens</span>
              </div>
            </div>
          </div>
          <div id="mapMeta" class="map-summary"></div>
          <div id="mapGrid" class="map-grid"></div>
        </div>
        <div id="governanceWrap" class="panel governance-wrap">
          <div class="meta" id="governanceMeta">Governance cycle dashboard</div>
          <div class="gov-toolbar">
            <label title="Filter claim-centric governance tables to claims with current-epoch applicable evidence.">
              <input type="checkbox" id="govEpochOnly" checked />
              Current Epoch Claims Only
            </label>
          </div>
          <div id="governanceContent" class="gov-empty">Loading governance agenda...</div>
        </div>
        <div id="tripleViewWrap" class="panel triple-view-wrap">
          <div class="triple-toolbar">
            <div class="meta" id="tripleStatus">Triple-view diagrams are not loaded.</div>
            <div class="buttons">
              <button id="tripleReloadBtn" type="button">Reload Diagrams</button>
            </div>
          </div>
          <div class="triple-meta-row">
            <div class="meta">Latest-epoch annotations on nodes/edges show claims, conflicts, and structure gaps.</div>
            <span id="tripleEpochChip" class="triple-epoch-chip">epoch: --</span>
          </div>
          <div class="legend-wrap" id="tripleLegend">
            <div class="legend-title">
              Triple annotation key
              <span class="help-tip" tabindex="0" data-tip="Hover nodes/edges for latest-epoch summaries. Click to inspect Claims, Conflicts, and Needs in the right panel.">?</span>
              <button type="button" class="legend-toggle push" data-target="tripleLegendBody" data-pref="triple">Hide key</button>
            </div>
            <div class="legend-body" id="tripleLegendBody">
              <div class="legend-row">
                <span class="legend-item">Node badges: <code>C</code> claims, <code>F</code> conflicts, <code>N</code> needs/gaps</span>
                <span class="legend-item">Edge markers: <code>!</code> conflict pressure, <code>?</code> open question / unresolved support</span>
              </div>
              <div class="legend-row">
                <span class="legend-item"><span class="legend-line" style="border-top-color:#8c2f2f;"></span>Conflict-contested edge</span>
                <span class="legend-item"><span class="legend-line" style="border-top-style:dashed;"></span>Open-question / gap edge</span>
              </div>
            </div>
          </div>
          <div class="triple-grid">
            <div class="triple-card">
              <div class="triple-card-head">
                <div>
                  <h3>1. Static Structure</h3>
                  <div class="meta">Component atlas (stable interfaces).</div>
                </div>
                <div class="triple-links">
                  <a href="../architecture/architecture_static.svg" target="_blank" rel="noopener">SVG</a>
                  <a href="../architecture/architecture_static.mmd" target="_blank" rel="noopener">MMD</a>
                </div>
              </div>
              <div class="triple-controls">
                <button type="button" data-triple-zoom-out="static" title="Zoom out">-</button>
                <button type="button" data-triple-zoom-in="static" title="Zoom in">+</button>
                <button type="button" data-triple-zoom-reset="static" title="Reset zoom">Reset</button>
                <span id="tripleStaticZoomLabel" class="zoom-value">100%</span>
                <span class="hint">Scroll to pan. Ctrl/Cmd + wheel to zoom.</span>
              </div>
              <div id="tripleStaticBody" class="triple-body">
                <div class="meta">Not loaded.</div>
              </div>
            </div>
            <div class="triple-card">
              <div class="triple-card-head">
                <div>
                  <h3>2. Typed Dataflow</h3>
                  <div class="meta">Stream/signal routing view.</div>
                </div>
                <div class="triple-links">
                  <a href="../architecture/architecture_typed_dataflow.svg" target="_blank" rel="noopener">SVG</a>
                  <a href="../architecture/architecture_typed_dataflow.mmd" target="_blank" rel="noopener">MMD</a>
                </div>
              </div>
              <div class="triple-controls">
                <button type="button" data-triple-zoom-out="typed" title="Zoom out">-</button>
                <button type="button" data-triple-zoom-in="typed" title="Zoom in">+</button>
                <button type="button" data-triple-zoom-reset="typed" title="Reset zoom">Reset</button>
                <span id="tripleTypedZoomLabel" class="zoom-value">100%</span>
                <span class="hint">Scroll to pan. Ctrl/Cmd + wheel to zoom.</span>
              </div>
              <div id="tripleTypedBody" class="triple-body">
                <div class="meta">Not loaded.</div>
              </div>
            </div>
            <div class="triple-card">
              <div class="triple-card-head">
                <div>
                  <h3>3. Episode Trace</h3>
                  <div class="meta">Single-tick temporal sequence trace.</div>
                </div>
                <div class="triple-links">
                  <a href="../architecture/episode_sequence.svg" target="_blank" rel="noopener">SVG</a>
                  <a href="../architecture/episode_sequence.mmd" target="_blank" rel="noopener">MMD</a>
                </div>
              </div>
              <div class="triple-controls">
                <button type="button" data-triple-zoom-out="episode" title="Zoom out">-</button>
                <button type="button" data-triple-zoom-in="episode" title="Zoom in">+</button>
                <button type="button" data-triple-zoom-reset="episode" title="Reset zoom">Reset</button>
                <span id="tripleEpisodeZoomLabel" class="zoom-value">100%</span>
                <span class="hint">Scroll to pan. Ctrl/Cmd + wheel to zoom.</span>
              </div>
              <div id="tripleEpisodeBody" class="triple-body">
                <div class="meta">Not loaded.</div>
              </div>
            </div>
          </div>
          <div id="tripleTooltip" class="triple-tooltip" role="dialog" aria-live="polite"></div>
        </div>
      </div>
      <div class="panel detail" id="detailPanel">
        <div id="selectedSummary" class="selected-summary">
          <div class="selected-group">
            <div class="selected-label">Thought claims</div>
            <div id="selectedThought" class="chips"></div>
          </div>
          <div class="selected-group">
            <div class="selected-label">Conflict claims</div>
            <div id="selectedConflict" class="chips"></div>
          </div>
          <div class="selected-group">
            <div class="selected-label">Conflict files</div>
            <div id="selectedConflictFiles" class="chips"></div>
          </div>
        </div>
        <div id="detailContent" class="detail-content">
          <div class="meta">Select a claim to see details.</div>
        </div>
      </div>
    </section>

    <section class="drafts">
      <div class="panel">
        <h2 style="margin-top:0; font-family: Iowan Old Style, Palatino, serif;">Draft Generator</h2>
        <div class="draft-tabs">
          <div class="draft-tab active" data-tab="thought">Thought Intake</div>
          <div class="draft-tab" data-tab="conflict">Conflict Resolution</div>
        </div>

        <div class="draft-pane active" id="thoughtPane">
          <label for="thoughtInput">Thought (free text)</label>
          <textarea id="thoughtInput" rows="6" placeholder="Paste your thought here..."></textarea>
          <div class="meta" style="margin-top:6px;">Uses Thought selections from the claims list above.</div>
          <div class="buttons" style="margin-top:8px;">
            <button id="generateThought" class="primary">Generate Draft</button>
            <button id="copyThought">Copy</button>
            <button id="downloadThought">Download .md</button>
          </div>
          <label for="thoughtOutput" style="margin-top:10px; display:block;">Draft Output</label>
          <textarea id="thoughtOutput" class="draft-output" rows="10" readonly></textarea>
        </div>

        <div class="draft-pane" id="conflictPane">
          <label for="conflictRefs">Conflict reference(s)</label>
          <input id="conflictRefs" type="text" placeholder="docs/conflicts/foo.md, INV-001" />
          <label for="conflictFileList" style="margin-top:8px; display:block;">Select conflict files (optional)</label>
          <div id="conflictFileList" class="picker"></div>
          <div class="meta" style="margin-top:6px;">Uses Conflict selections from the claims list above.</div>
          <label for="conflictDecision" style="margin-top:8px; display:block;">Resolution decision</label>
          <textarea id="conflictDecision" rows="6" placeholder="Describe the resolution..."></textarea>
          <div class="buttons" style="margin-top:8px;">
            <button id="generateConflict" class="primary">Generate Draft</button>
            <button id="copyConflict">Copy</button>
            <button id="downloadConflict">Download .md</button>
          </div>
          <label for="conflictOutput" style="margin-top:10px; display:block;">Draft Output</label>
          <textarea id="conflictOutput" class="draft-output" rows="12" readonly></textarea>
        </div>
      </div>
    </section>

    <div class="footer">Data source: docs/claims/claims.yaml and docs/conflicts/*.md</div>
  </main>

  <script>
    /*
      Latest epoch annotations: how it works
      1) Derive a "latest epoch" snapshot from already-loaded governance payloads.
      2) Build a per-diagram view-model from current-epoch claims only (respecting active filters).
      3) Attach node/edge annotation metadata as __anno and render subtle SVG cues + inspector links.
    */
    const CLAIMS_URL = './claims.yaml';
    const CONFLICT_INDEX_URL = '../conflicts/README.md';
    const README_URL = '../README.md';
    const GOVERNANCE_AGENDA_URL = '../../evidence/planning/governance_agenda.v1.json';
    const GOVERNANCE_BACKLOG_URL = '../../evidence/planning/evidence_backlog.v1.json';
    const GOVERNANCE_PROPOSALS_URL = '../../evidence/planning/experiment_proposals.v1.json';
    const REFRESH_MS = 60000;

    const CMD_RUN_GOVERNANCE = 'python3 /Users/dgolden/Documents/GitHub/REE_assembly/evidence/planning/scripts/run_governance_cycle.py';
    const CMD_RUN_GOVERNANCE_STRICT = 'python3 /Users/dgolden/Documents/GitHub/REE_assembly/evidence/planning/scripts/run_governance_cycle.py --strict-thoughts';
    const CMD_RECORD_DECISION_TEMPLATE = 'python3 /Users/dgolden/Documents/GitHub/REE_assembly/evidence/experiments/scripts/record_decision.py --claim-id <CLAIM_ID> --recommendation <RECOMMENDATION> --decision-needed \"<DECISION_NEEDED>\" --decision-status approved --selected-option \"<OPTION>\" --rationale \"<RATIONALE>\" --actor dgolden';
    const REPO_ABS_PREFIX = '/Users/dgolden/Documents/GitHub/REE_assembly/';
    const GOVERNANCE_CONTEXT_DOCS = {
      thought_intake: [
        'docs/thoughts/SWEEP_REPORT.md',
        'docs/thoughts/thought_sweep.v1.json',
      ],
      conflict_resolution: [
        'evidence/experiments/conflicts.md',
        'evidence/planning/ARCHITECTURE_GAP_REGISTER.md',
      ],
      architecture_epoch_applicability: [
        'evidence/planning/architecture_epoch_applicability.v1.json',
        'evidence/planning/planning_criteria.v1.yaml',
      ],
      governance_decisions: [
        'evidence/experiments/promotion_demotion_recommendations.md',
        'evidence/decisions/decision_log.v1.jsonl',
      ],
      manual_carryover: [
        'evidence/planning/manual_carryover_items.v1.json',
        'evidence/planning/task_inbox.md',
      ],
      architecture_structure: [
        'evidence/planning/ARCHITECTURE_GAP_REGISTER.md',
        'evidence/planning/structure_review/latest/ACTIVE_INDEX.md',
        'evidence/planning/structure_review/latest/ARCHIVE_INDEX.md',
      ],
      structure_review_dossiers: [
        'evidence/planning/structure_review/latest/ACTIVE_INDEX.md',
        'evidence/planning/structure_review/latest/ARCHIVE_INDEX.md',
      ],
      connectome_literature_pull: [
        'evidence/planning/CONNECTOME_LITERATURE_PULL.md',
        'evidence/planning/connectome_pull_state.v1.json',
      ],
      model_adjudication: [
        'evidence/planning/planning_criteria.v1.yaml',
        'evidence/planning/ARCHITECTURE_GAP_REGISTER.md',
      ],
      adjudication_cascade: [
        'evidence/planning/ADJUDICATION_CASCADE_PATCH_QUEUE.md',
        'evidence/decisions/adjudication_cascade_state.v1.json',
      ],
      evidence_dispatch: [
        'evidence/planning/experiment_proposals.v1.json',
      ],
      maintenance: [
        'evidence/experiments/claim_evidence.v1.json',
        'evidence/experiments/TODOs.md',
      ],
    };

    const FALLBACK_THOUGHT_PROMPT = `You are the AI agent maintaining the REE repository (Codex in this session). I am going to describe a thought, concern, or new understanding about REE in free text.

Your job is to:
1) Infer the scope and affected components.
2) Determine whether this introduces or modifies:
   - an invariant,
   - an architectural commitment,
   - a mechanism hypothesis,
   - or an open question.
3) Update the canonical REE docs incrementally (do NOT refactor the whole repo).
4) Preserve all prior formulations; do not delete or overwrite history.
5) If this thought conflicts with existing claims:
   - represent the conflict explicitly in docs/conflicts/
   - do NOT resolve it.
6) Update the claim registry, glossary (if needed), and changelog.
7) Run an implicit consistency check and surface any new tensions created.

I will now write the thought in natural language.

BEGIN THOUGHT:
<PASTE YOUR THOUGHT HERE>
END THOUGHT`;

    const FALLBACK_CONFLICT_PROMPT = `You are the AI agent maintaining the REE repository (Codex in this session). I am resolving an explicitly documented conflict or fork in the REE documentation.

Your job is to:
1) Locate and read the referenced conflict file(s) in docs/conflicts/.
2) Identify the conflicting claim IDs, their types, scopes, and dependencies.
3) Apply my resolution decision carefully and minimally.
4) Update the canonical documentation, claim registry, and dependency graph to reflect the resolution.
5) Preserve historical record:
   - Do NOT delete superseded claims.
   - Mark them as legacy or deprecated with clear rationale.
6) Ensure the repo is internally consistent after resolution.
7) Surface any new tensions created by this change.
8) Update docs/changelog.md with a clear record of what was resolved and why.

BEGIN CONFLICT RESOLUTION:

Conflict reference(s):
- <PASTE docs/conflicts/*.md PATHS OR CLAIM IDs>

Resolution decision (free text):
<DESCRIBE THE RESOLUTION IN YOUR OWN WORDS>

END CONFLICT RESOLUTION`;

    const DOC_GROUPS = [
      {
        label: 'Architecture',
        docs: [
          { title: 'Overview', path: '../architecture/overview.md' },
          { title: 'E1', path: '../architecture/e1.md' },
          { title: 'E2', path: '../architecture/e2.md' },
          { title: 'E3', path: '../architecture/e3.md' },
          { title: 'L-space', path: '../architecture/l_space.md' },
          { title: 'Control Plane', path: '../architecture/control_plane.md' },
          { title: 'Control Plane Signal Map', path: '../architecture/control_plane_signal_map.md' },
          { title: 'Default Mode', path: '../architecture/default_mode.md' },
          { title: 'Hippocampal Systems', path: '../architecture/hippocampal_systems.md' },
          { title: 'Hippocampal Braid (legacy)', path: '../architecture/hippocampal_braid.md' },
          { title: 'Residue Geometry', path: '../architecture/residue_geometry.md' },
          { title: 'Sensory Stream Tags', path: '../architecture/sensory_stream_tags.md' },
          { title: 'Temporal Dynamics', path: '../architecture/temporal_dynamics.md' },
          { title: 'Mode Manager', path: '../architecture/mode_manager.md' },
          { title: 'Modes of Cognition', path: '../architecture/modes_of_cognition.md' },
          { title: 'Agency Responsibility Flow', path: '../architecture/agency_responsibility_flow.md' },
          { title: 'Trajectory Selection', path: '../architecture/trajectory_selection.md' },
          { title: 'Entities and Binding', path: '../architecture/entities_and_binding.md' },
          { title: 'Precision Control', path: '../architecture/precision_control.md' },
          { title: 'Precision Scoping', path: '../architecture/precision_scoping.md' },
          { title: 'Path Authority and Interrupts', path: '../architecture/path_authority_and_interrupts.md' },
          { title: 'Astrocyte Regulatory Stack', path: '../architecture/astrocyte_regulatory_stack.md' },
          { title: 'Serotonin', path: '../architecture/serotonin.md' },
          { title: 'Language (overview)', path: '../architecture/language.md' },
          { title: 'Sleep (overview)', path: '../architecture/sleep.md' },
          { title: 'Social', path: '../architecture/social.md' },
          { title: 'Why Attention Must Be Fragmented', path: '../architecture/why_attention_must_be_fragmented.md' },
          { title: 'Architecture Triple-View Guide', path: '../architecture/diagram_views.md' },
          { title: 'Architecture Stream Catalog', path: '../architecture/streams.md' },
          { title: 'Architecture Routing Table', path: '../architecture/stream_routing.v1.yaml' },
          { title: 'Architecture Static Diagram Source', path: '../architecture/architecture_static.mmd' },
          { title: 'Architecture Typed Dataflow Source', path: '../architecture/architecture_typed_dataflow.mmd' },
          { title: 'Architecture Episode Sequence Source', path: '../architecture/episode_sequence.mmd' },
        ],
      },
      {
        label: 'Architecture / Language',
        docs: [
          { title: 'Emergence and Bootstrapping', path: '../architecture/language/emergence_and_bootstrapping.md' },
          { title: 'Language and Learning', path: '../architecture/language/language_and_learning.md' },
          { title: 'Language and Institutions', path: '../architecture/language/language_and_institutions.md' },
          { title: 'Language Failure Modes', path: '../architecture/language/language_failure_modes.md' },
          { title: 'Minimal Signalling Channel', path: '../architecture/language/minimal_signalling_channel.md' },
          { title: 'Trust and Deception', path: '../architecture/language/trust_and_deception.md' },
        ],
      },
      {
        label: 'Architecture / Sleep',
        docs: [
          { title: 'Precision Recalibration', path: '../architecture/sleep/precision_recalibration.md' },
          { title: 'Reality Consolidation', path: '../architecture/sleep/reality_consolidation.md' },
          { title: 'Residue Integration', path: '../architecture/sleep/residue_integration.md' },
        ],
      },
      {
        label: 'Core Docs',
        docs: [
          { title: 'Invariants', path: '../invariants.md' },
          { title: 'Glossary', path: '../glossary.md' },
          { title: 'REE Minimum Spec', path: '../REE_MIN_SPEC.md' },
          { title: 'REE Overview', path: '../REE_overview.md' },
          { title: 'REE Failure Modes', path: '../REE_failure_modes.md' },
        ],
      },
      {
        label: 'Governance / Planning',
        docs: [
          { title: 'Governance Agenda', path: '../../evidence/planning/GOVERNANCE_AGENDA.md' },
          { title: 'Architecture Gap Register', path: '../../evidence/planning/ARCHITECTURE_GAP_REGISTER.md' },
          { title: 'Connectome Literature Pull', path: '../../evidence/planning/CONNECTOME_LITERATURE_PULL.md' },
          { title: 'Planning README', path: '../../evidence/planning/README.md' },
          { title: 'Task Inbox', path: '../../evidence/planning/task_inbox.md' },
          { title: 'Manual Carryover Items', path: '../../evidence/planning/manual_carryover_items.v1.json' },
          { title: 'Planning Criteria', path: '../../evidence/planning/planning_criteria.v1.yaml' },
          { title: 'Structure Review (Active)', path: '../../evidence/planning/structure_review/latest/ACTIVE_INDEX.md' },
          { title: 'Structure Review (Archive)', path: '../../evidence/planning/structure_review/latest/ARCHIVE_INDEX.md' },
          { title: 'Connectome Pull State', path: '../../evidence/planning/connectome_pull_state.v1.json' },
          { title: 'Experiment Proposals', path: '../../evidence/planning/experiment_proposals.v1.json' },
        ],
      },
    ];

    const SUBSYSTEM_MAP_URL = './subsystem_map.yaml';
    let subsystemRules = [];
    const ATLAS_ORDER = [
      'INV',
      'REP',
      'CTL',
      'TRJ',
      'COM',
      'AUT',
      'SOC',
      'LAN',
      'SLP',
      'IMP',
      'META',
      'UNMAPPED',
    ];
    const ATLAS_LABEL = {
      INV: 'INV Foundations',
      REP: 'REP Representation',
      CTL: 'CTL Control Plane',
      TRJ: 'TRJ Trajectory & Residue',
      COM: 'COM Commitment & Responsibility',
      AUT: 'AUT Authority & Verifier',
      SOC: 'SOC Social',
      LAN: 'LAN Language',
      SLP: 'SLP Sleep & Consolidation',
      IMP: 'IMP Implementation & Interfaces',
      META: 'META Docs & Governance',
      UNMAPPED: 'UNMAPPED',
    };
    const SUBJECT_PREFIX_TO_ATLAS = {
      e1: 'REP',
      e2: 'REP',
      e3: 'COM',
      l_space: 'REP',
      latent_predictive_models: 'REP',
      jepa_substrate: 'REP',
      control_plane: 'CTL',
      precision: 'CTL',
      astrocyte: 'CTL',
      attention: 'CTL',
      cognitive_modes: 'CTL',
      temporal: 'CTL',
      default_mode: 'CTL',
      sensory_stream_tags: 'CTL',
      hippocampus: 'TRJ',
      hippocampal: 'TRJ',
      residue: 'TRJ',
      trajectory: 'TRJ',
      commitment: 'COM',
      agency: 'COM',
      responsibility: 'COM',
      agentic_extension: 'COM',
      affect: 'COM',
      provenance: 'AUT',
      entities: 'AUT',
      social: 'SOC',
      emotion: 'SOC',
      care_weights_override_other_harm_veto: 'SOC',
      valence_vs_mu_kappa_overlays: 'SOC',
      selfhood_personality_ethics: 'SOC',
      language: 'LAN',
      terminology: 'LAN',
      sleep: 'SLP',
      interfaces: 'IMP',
      integration: 'IMP',
      roadmap: 'IMP',
      spec: 'IMP',
      invariance: 'INV',
      ethics: 'INV',
      consequence: 'INV',
      coherence: 'INV',
      architecture: 'INV',
      meta: 'META',
      docs: 'META',
      repo: 'META',
      claims: 'META',
      conflicts: 'META',
      failure: 'META',
      failure_modes: 'META',
      examples: 'META',
      migration: 'META',
      overview: 'META',
      refactor: 'META',
      design: 'META',
      developmental: 'META',
      developmental_ordering: 'META',
      wiring: 'META',
      diagrams: 'META',
    };
    const LOCATION_RULES_TO_ATLAS = [
      ['docs/architecture/language/', 'LAN'],
      ['docs/architecture/language.md', 'LAN'],
      ['docs/architecture/social', 'SOC'],
      ['docs/architecture/sleep', 'SLP'],
      ['docs/architecture/agency_responsibility_flow', 'COM'],
      ['docs/architecture/e3', 'COM'],
      ['docs/architecture/path_authority', 'AUT'],
      ['docs/architecture/entities_and_binding', 'AUT'],
      ['docs/architecture/papez_circuit', 'AUT'],
      ['docs/architecture/control_plane', 'CTL'],
      ['docs/architecture/precision', 'CTL'],
      ['docs/architecture/astrocyte', 'CTL'],
      ['docs/architecture/serotonin', 'CTL'],
      ['docs/architecture/temporal', 'CTL'],
      ['docs/architecture/mode', 'CTL'],
      ['docs/architecture/hippocampal', 'TRJ'],
      ['docs/architecture/residue', 'TRJ'],
      ['docs/architecture/trajectory', 'TRJ'],
      ['docs/architecture/e1', 'REP'],
      ['docs/architecture/e2', 'REP'],
      ['docs/architecture/l_space', 'REP'],
      ['docs/architecture/jepa', 'REP'],
      ['docs/architecture/hook_surface', 'IMP'],
      ['docs/invariants', 'INV'],
      ['docs/REE_MIN_SPEC', 'INV'],
      ['docs/claims/', 'META'],
      ['docs/changelog', 'META'],
      ['docs/roadmap', 'META'],
      ['docs/README', 'META'],
    ];

    const TRIPLE_VIEW_SPECS = [
      {
        id: 'static',
        label: 'Static Structure',
        svgPath: '../architecture/architecture_static.svg',
        mmdPath: '../architecture/architecture_static.mmd',
        bodyId: 'tripleStaticBody',
        zoomLabelId: 'tripleStaticZoomLabel',
      },
      {
        id: 'typed',
        label: 'Typed Dataflow',
        svgPath: '../architecture/architecture_typed_dataflow.svg',
        mmdPath: '../architecture/architecture_typed_dataflow.mmd',
        bodyId: 'tripleTypedBody',
        zoomLabelId: 'tripleTypedZoomLabel',
      },
      {
        id: 'episode',
        label: 'Episode Trace',
        svgPath: '../architecture/episode_sequence.svg',
        mmdPath: '../architecture/episode_sequence.mmd',
        bodyId: 'tripleEpisodeBody',
        zoomLabelId: 'tripleEpisodeZoomLabel',
      },
    ];
    const TRIPLE_ATLAS_ALIAS_FALLBACK = {
      INV: ['BND', 'VER', 'STORES'],
      REP: ['E1', 'E2', 'BND'],
      CTL: ['CP', 'CAL', 'F1', 'F2', 'F3', 'F4'],
      TRJ: ['HPC', 'LRN'],
      COM: ['E3', 'G1', 'G2', 'G3', 'ACT'],
      AUT: ['VER', 'STORES'],
      SOC: ['F3', 'G2'],
      LAN: ['BND', 'E1', 'E3'],
      SLP: ['LRN', 'HPC', 'CAL'],
      IMP: ['CP', 'BND', 'ACT'],
      META: ['CP', 'VER'],
      UNMAPPED: [],
    };
    const TRIPLE_SUBJECT_ALIAS_HINTS = [
      [/(\b|_)e1(\b|_)/i, 'E1'],
      [/(\b|_)e2(\b|_)/i, 'E2'],
      [/(\b|_)e3(\b|_)/i, 'E3'],
      [/control_plane|precision|serotonin|astrocyte|mode|temporal/i, 'CP'],
      [/hippocamp|path_memory|trajectory|residue/i, 'HPC'],
      [/reality_coherence|\brc\b/i, 'RC'],
      [/verifier|authority|provenance/i, 'VER'],
      [/trusted_store|caps|pol_id_caps/i, 'STORES'],
      [/commit|gate_motor|motor/i, 'G3'],
      [/gate_cognitive|cognitive_set/i, 'G1'],
      [/gate_motivational|motivational/i, 'G2'],
      [/action_executor|actuator|effect/i, 'ACT'],
      [/post_commit|learning|outcome_trace/i, 'LRN'],
      [/context_anchor/i, 'F1'],
      [/body_feasible|homeostasis/i, 'F2'],
      [/motivation_ok|valence|motivation/i, 'F3'],
      [/hard_veto|harm|veto/i, 'F4'],
      [/external_inputs|sensor|exteroceptive/i, 'EXT'],
      [/world_state|environment|world/i, 'WORLD'],
      [/typed_payload|boundary/i, 'BND'],
    ];

    const els = {
      search: document.getElementById('search'),
      typeFilter: document.getElementById('typeFilter'),
      statusFilter: document.getElementById('statusFilter'),
      subjectFilter: document.getElementById('subjectFilter'),
      subjectList: document.getElementById('subjectList'),
      claimsTable: document.getElementById('claimsTable'),
      listWrap: document.getElementById('listWrap'),
      graphWrap: document.getElementById('graphWrap'),
      docsWrap: document.getElementById('docsWrap'),
      mapWrap: document.getElementById('mapWrap'),
      tripleViewWrap: document.getElementById('tripleViewWrap'),
      mapLegend: document.getElementById('mapLegend'),
      mapLegendMode: document.getElementById('mapLegendMode'),
      mapMeta: document.getElementById('mapMeta'),
      mapLens: document.getElementById('mapLens'),
      graphPanel: document.getElementById('graphPanel'),
      graphMeta: document.getElementById('graphMeta'),
      graphTooltip: document.getElementById('graphTooltip'),
      graphFocusRadios: document.querySelectorAll('input[name="graphFocus"]'),
      worksetScopeRadios: document.querySelectorAll('input[name="worksetScope"]'),
      worksetThought: document.getElementById('worksetThought'),
      worksetConflict: document.getElementById('worksetConflict'),
      worksetGroups: document.querySelectorAll('.workset-only'),
      listViewBtn: document.getElementById('listViewBtn'),
      graphViewBtn: document.getElementById('graphViewBtn'),
      docsViewBtn: document.getElementById('docsViewBtn'),
      mapViewBtn: document.getElementById('mapViewBtn'),
      tripleViewBtn: document.getElementById('tripleViewBtn'),
      governanceViewBtn: document.getElementById('governanceViewBtn'),
      tripleStatus: document.getElementById('tripleStatus'),
      tripleEpochChip: document.getElementById('tripleEpochChip'),
      tripleReloadBtn: document.getElementById('tripleReloadBtn'),
      tripleTooltip: document.getElementById('tripleTooltip'),
      mapEpochOnly: document.getElementById('mapEpochOnly'),
      mapGovernanceOnly: document.getElementById('mapGovernanceOnly'),
      govEpochOnly: document.getElementById('govEpochOnly'),
      includeDeps: document.getElementById('includeDeps'),
      clearFilters: document.getElementById('clearFilters'),
      stats: document.getElementById('stats'),
      errorBanner: document.getElementById('errorBanner'),
      refreshStatus: document.getElementById('refreshStatus'),
      selectedThought: document.getElementById('selectedThought'),
      selectedConflict: document.getElementById('selectedConflict'),
      selectedConflictFiles: document.getElementById('selectedConflictFiles'),
      detailContent: document.getElementById('detailContent'),
      thoughtInput: document.getElementById('thoughtInput'),
      thoughtOutput: document.getElementById('thoughtOutput'),
      generateThought: document.getElementById('generateThought'),
      copyThought: document.getElementById('copyThought'),
      downloadThought: document.getElementById('downloadThought'),
      conflictRefs: document.getElementById('conflictRefs'),
      conflictFileList: document.getElementById('conflictFileList'),
      conflictDecision: document.getElementById('conflictDecision'),
      conflictOutput: document.getElementById('conflictOutput'),
      generateConflict: document.getElementById('generateConflict'),
      copyConflict: document.getElementById('copyConflict'),
      downloadConflict: document.getElementById('downloadConflict'),
      docSelect: document.getElementById('docSelect'),
      docSearch: document.getElementById('docSearch'),
      docMeta: document.getElementById('docMeta'),
      docContent: document.getElementById('docContent'),
      mapGrid: document.getElementById('mapGrid'),
      governanceWrap: document.getElementById('governanceWrap'),
      governanceMeta: document.getElementById('governanceMeta'),
      governanceContent: document.getElementById('governanceContent'),
    };

    const typeOrder = [
      'invariant',
      'architectural_commitment',
      'mechanism_hypothesis',
      'open_question',
      'implementation_note',
    ];

    let allClaims = [];
    let claimMap = new Map();
    let conflictsMap = {};
    const conflictDetailCache = new Map();
    const claimTextCache = new Map();
    const fileCache = new Map();
    let initialized = false;
    let refreshTimer = null;
    let conflictFiles = [];
    const thoughtSelected = new Set();
    const conflictSelectedClaims = new Set();
    const conflictSelectedFiles = new Set();
    let hoverId = null;
    let hoverPoint = null;
    let docsInitialized = false;
    let currentDocUrl = null;
    let docIndex = [];
    let docIndexMap = new Map();
    let governanceAgenda = null;
    let governanceBacklog = null;
    let governanceProposals = null;
    let governanceError = '';
    let governanceLoadedAt = '';
    let governanceLoading = false;
    let tripleViewLoaded = false;
    let tripleViewLoading = false;
    const tripleZoomState = new Map();
    const tripleDiagramModel = new Map();
    const tripleInteractiveIndex = new Map();
    let tripleLatestEpoch = '';
    let tripleViewModel = null;
    let tripleTooltipHideTimer = null;

    function showError(message) {
      els.errorBanner.textContent = message;
      els.errorBanner.style.display = 'block';
    }

    function showErrorHtml(html) {
      els.errorBanner.innerHTML = html;
      els.errorBanner.style.display = 'block';
    }

    function hideError() {
      els.errorBanner.style.display = 'none';
    }

    async function fetchText(url) {
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) {
        throw new Error(`Failed to fetch ${url} (${res.status})`);
      }
      return res.text();
    }

    function parseClaimsYaml(text) {
      const normalized = text
        .replace(/\uFEFF/g, '')
        .replace(/\u200B/g, '')
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n');
      const lines = normalized.split('\n');
      const claims = [];
      let cur = null;
      let mode = null;
      const depPattern = /\b(INV|ARC|MECH|IMPL|Q)-\d{3}\b/;

      function pushCur() {
        if (!cur) return;
        if (!cur.depends_on) cur.depends_on = [];
        claims.push(cur);
      }

      function normalizeDep(item) {
        if (!item) return '';
        const stripped = item.replace(/#.*/, '').replace(/[,\]]+$/, '').trim();
        const match = stripped.match(depPattern);
        return match ? match[0] : stripped;
      }

      for (const rawLine of lines) {
        const line = rawLine.replace(/\t/g, '  ');
        const idIndex = line.indexOf('id:');
        const idMatch = line.match(/id:\s*([A-Z]{1,6}-\d{3})/i);
        if (idMatch && idIndex > -1 && idIndex <= 10) {
          pushCur();
          cur = { id: idMatch[1].trim() };
          mode = null;
          continue;
        }
        if (!cur) continue;

        const keyMatch = line.match(/^\s{2,}([a-z_]+):\s*(.*)$/);
        if (keyMatch) {
          const key = keyMatch[1];
          const val = keyMatch[2] || '';
          if (key === 'depends_on') {
            cur.depends_on = [];
            mode = 'depends_on';
            if (val.trim()) {
              const inline = val.replace(/^\[/, '').replace(/\]$/, '');
              inline.split(',').map(s => s.trim()).filter(Boolean).forEach(item => {
                const norm = normalizeDep(item);
                if (norm) cur.depends_on.push(norm);
              });
              mode = null;
            }
            continue;
          }
          if (key === 'source') {
            mode = 'source';
            continue;
          }
          mode = null;
          if (['claim_type', 'subject', 'polarity', 'status', 'location'].includes(key)) {
            cur[key] = val.trim();
          }
          continue;
        }

        const listMatch = line.match(/^\s*-\s*(.+)$/);
        if (listMatch && mode === 'depends_on') {
          const norm = normalizeDep(listMatch[1]);
          if (norm) cur.depends_on.push(norm);
        }
      }

      pushCur();
      if (claims.length) return claims;

      const blocks = normalized.split(/(?=^\s*.*id:\s*[A-Z]{1,6}-\d{3})/mi);
      const fallback = [];
      blocks.forEach(block => {
        const idMatch = block.match(/id:\s*([A-Z]{1,6}-\d{3})/i);
        if (!idMatch) return;
        const c = { id: idMatch[1].trim(), depends_on: [] };
        ['claim_type', 'subject', 'polarity', 'status', 'location'].forEach(key => {
          const km = block.match(new RegExp(`^\\s*${key}:\\s*(.+)$`, 'm'));
          if (km) c[key] = km[1].trim();
        });
        const depLine = block.match(/^\s*depends_on:\s*(.*)$/m);
        if (depLine) {
          const rest = depLine[1].trim();
          if (rest && rest !== '[]') {
            const inline = rest.replace(/^\[/, '').replace(/\]$/, '');
            inline.split(',').map(s => s.trim()).filter(Boolean).forEach(item => {
              const norm = normalizeDep(item);
              if (norm) c.depends_on.push(norm);
            });
          } else if (rest === '') {
            const depItems = block.split('\n');
            let inDeps = false;
            for (const line of depItems) {
              if (/^\s*depends_on:\s*$/.test(line)) { inDeps = true; continue; }
              if (inDeps) {
                if (/^\s{2,}[a-z_]+:/.test(line)) break;
                const m = line.match(/^\s*-\s*(.+)$/);
                if (m) {
                  const norm = normalizeDep(m[1]);
                  if (norm) c.depends_on.push(norm);
                }
              }
            }
          }
        }
        fallback.push(c);
      });
      return fallback;
    }

    function normalizeClaim(c) {
      return {
        id: c.id,
        type: c.claim_type || 'unknown',
        status: c.status || 'unknown',
        subject: c.subject || '',
        polarity: c.polarity || '',
        depends_on: c.depends_on || [],
        location: c.location || '',
      };
    }

    function renderInlineMarkdown(text) {
      const parts = text.split(/(`[^`]+`)/g);
      return parts.map(part => {
        if (part.startsWith('`') && part.endsWith('`')) {
          return `<code>${escapeHtml(part.slice(1, -1))}</code>`;
        }
        let out = escapeHtml(part);
        out = out.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, label, url) => {
          const safeUrl = url.replace(/"/g, '%22');
          return `<a href="${safeUrl}">${label}</a>`;
        });
        out = out.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        out = out.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        return out;
      }).join('');
    }

    function renderMarkdown(text) {
      const normalized = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      const lines = normalized.split('\n');
      const html = [];
      let inCode = false;
      let codeLang = '';
      let codeBuffer = [];
      let listType = null;
      let paragraph = [];
      let inBlockquote = false;
      let blockLines = [];

      function flushParagraph() {
        if (!paragraph.length) return;
        html.push(`<p>${renderInlineMarkdown(paragraph.join(' '))}</p>`);
        paragraph = [];
      }

      function closeList() {
        if (!listType) return;
        html.push(`</${listType}>`);
        listType = null;
      }

      function flushBlockquote() {
        if (!inBlockquote) return;
        html.push(`<blockquote>${renderInlineMarkdown(blockLines.join(' '))}</blockquote>`);
        blockLines = [];
        inBlockquote = false;
      }

      for (const rawLine of lines) {
        const trimmed = rawLine.trim();

        if (trimmed.startsWith('```')) {
          if (inCode) {
            const langClass = codeLang ? ` class="lang-${escapeHtml(codeLang)}"` : '';
            html.push(`<pre><code${langClass}>${escapeHtml(codeBuffer.join('\n'))}</code></pre>`);
            codeBuffer = [];
            codeLang = '';
            inCode = false;
          } else {
            flushParagraph();
            closeList();
            flushBlockquote();
            inCode = true;
            codeLang = trimmed.slice(3).trim();
          }
          continue;
        }

        if (inCode) {
          codeBuffer.push(rawLine);
          continue;
        }

        if (!trimmed) {
          flushParagraph();
          closeList();
          flushBlockquote();
          continue;
        }

        if (trimmed.startsWith('<a id=')) {
          flushParagraph();
          closeList();
          flushBlockquote();
          html.push(trimmed);
          continue;
        }

        const headingMatch = trimmed.match(/^(#{1,6})\s+(.*)$/);
        if (headingMatch) {
          flushParagraph();
          closeList();
          flushBlockquote();
          const level = headingMatch[1].length;
          const textContent = headingMatch[2];
          html.push(`<h${level}>${renderInlineMarkdown(textContent)}</h${level}>`);
          continue;
        }

        if (/^---+$/.test(trimmed)) {
          flushParagraph();
          closeList();
          flushBlockquote();
          html.push('<hr />');
          continue;
        }

        if (trimmed.startsWith('>')) {
          flushParagraph();
          closeList();
          inBlockquote = true;
          blockLines.push(trimmed.replace(/^>\s?/, ''));
          continue;
        } else if (inBlockquote) {
          flushBlockquote();
        }

        const listMatch = trimmed.match(/^(\d+\.|[-*+])\s+(.*)$/);
        if (listMatch) {
          flushParagraph();
          flushBlockquote();
          const type = /^\d+\./.test(listMatch[1]) ? 'ol' : 'ul';
          if (listType && listType !== type) {
            closeList();
          }
          if (!listType) {
            listType = type;
            html.push(`<${type}>`);
          }
          html.push(`<li>${renderInlineMarkdown(listMatch[2])}</li>`);
          continue;
        }

        paragraph.push(trimmed);
      }

      if (inCode) {
        const langClass = codeLang ? ` class="lang-${escapeHtml(codeLang)}"` : '';
        html.push(`<pre><code${langClass}>${escapeHtml(codeBuffer.join('\n'))}</code></pre>`);
      }

      flushParagraph();
      closeList();
      flushBlockquote();
      return html.join('\n');
    }

    function escapeHtml(text) {
      if (!text) return '';
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function updateRefreshStatus() {
      if (!els.refreshStatus) return;
      const now = new Date();
      els.refreshStatus.textContent = `Last refreshed: ${now.toLocaleTimeString()}`;
    }

    function buildDocIndex() {
      docIndex = [];
      docIndexMap = new Map();
      DOC_GROUPS.forEach(group => {
        group.docs.forEach(doc => {
          const url = doc.path.match(/^https?:\/\//)
            ? doc.path
            : new URL(doc.path, window.location.href).toString();
          const entry = {
            group: group.label,
            title: doc.title,
            path: doc.path,
            url,
          };
          docIndex.push(entry);
          docIndexMap.set(url, entry);
        });
      });
    }

    function escapeRegex(text) {
      return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function compileSubsystemRules(entries) {
      const rules = [];
      (entries || []).forEach(entry => {
        if (!entry || !entry.key || !entry.patterns) return;
        const patterns = entry.patterns.map(p => String(p)).filter(Boolean);
        const regexes = patterns.map(pattern => {
          if (pattern.endsWith('/')) {
            const base = escapeRegex(pattern).replace(/\/$/, '');
            return new RegExp(`^${base}`);
          }
          return new RegExp(`^${escapeRegex(pattern)}$`);
        });
        rules.push({ key: entry.key, patterns, regexes });
      });
      return rules;
    }

    function parseSubsystemMap(text) {
      const normalized = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      const lines = normalized.split('\n');
      const entries = [];
      let cur = null;
      let inPatterns = false;
      lines.forEach(raw => {
        const trimmed = raw.trim();
        if (!trimmed || trimmed.startsWith('#')) return;
        if (trimmed.startsWith('- key:')) {
          if (cur) entries.push(cur);
          cur = { patterns: [] };
          inPatterns = false;
          const keyMatch = trimmed.match(/^-\\s+key:\\s*(.+)$/);
          if (keyMatch) cur.key = keyMatch[1].trim();
          return;
        }
        if (!cur) return;
        if (trimmed.startsWith('key:')) {
          cur.key = trimmed.split(':', 2)[1].trim();
          return;
        }
        if (trimmed.startsWith('patterns:')) {
          cur.patterns = [];
          inPatterns = true;
          return;
        }
        if (inPatterns) {
          const patMatch = trimmed.match(/^-\\s+(.+)$/);
          if (patMatch) {
            cur.patterns.push(patMatch[1].trim());
          }
        }
      });
      if (cur) entries.push(cur);
      return entries;
    }

    async function loadSubsystemMap() {
      try {
        const text = await fetchText(SUBSYSTEM_MAP_URL);
        const parsed = parseSubsystemMap(text);
        subsystemRules = compileSubsystemRules(parsed);
      } catch (_) {
        subsystemRules = [];
      }
    }

    function getSubsystemKey(claim) {
      if (!claim || !claim.location) return 'Unmapped';
      const path = claim.location.split('#')[0];
      const rules = subsystemRules || [];
      for (const rule of rules) {
        const regexes = rule.regexes || [];
        for (const re of regexes) {
          if (re.test(path)) return rule.key;
        }
      }
      return 'Unmapped';
    }

    function atlasKeyFromSubject(claim) {
      const subject = String((claim && claim.subject) || '').trim().toLowerCase();
      if (!subject) return '';
      const prefix = subject.split('.')[0] || '';
      return SUBJECT_PREFIX_TO_ATLAS[prefix] || '';
    }

    function atlasKeyFromLocation(claim) {
      const path = String((claim && claim.location) || '').split('#')[0].toLowerCase();
      if (!path) return '';
      for (const [needle, key] of LOCATION_RULES_TO_ATLAS) {
        if (path.includes(String(needle).toLowerCase())) return key;
      }
      return '';
    }

    function atlasGroupForClaim(claim) {
      if (!claim) return { key: 'UNMAPPED', label: ATLAS_LABEL.UNMAPPED, reason: 'missing_claim' };
      const bySubject = atlasKeyFromSubject(claim);
      if (bySubject) {
        return { key: bySubject, label: ATLAS_LABEL[bySubject] || bySubject, reason: `subject:${claim.subject}` };
      }
      const byLocation = atlasKeyFromLocation(claim);
      if (byLocation) {
        return { key: byLocation, label: ATLAS_LABEL[byLocation] || byLocation, reason: `location:${claim.location}` };
      }
      const mapped = getSubsystemKey(claim);
      if (mapped && mapped !== 'Unmapped') {
        const token = String(mapped).toLowerCase();
        const fallback = (
          token.includes('language') ? 'LAN'
          : token.includes('social') ? 'SOC'
          : token.includes('sleep') ? 'SLP'
          : token.includes('hippocamp') || token.includes('residue') || token.includes('trajectory') ? 'TRJ'
          : token.includes('agency') || token === 'e3' ? 'COM'
          : token.includes('authority') || token.includes('entities') || token.includes('papez') ? 'AUT'
          : token.includes('control') || token.includes('precision') || token.includes('serotonin') || token.includes('mode') ? 'CTL'
          : token === 'e1' || token === 'e2' || token.includes('l-space') || token.includes('jepa') ? 'REP'
          : token.includes('invariant') ? 'INV'
          : token.includes('hook') ? 'IMP'
          : 'META'
        );
        return { key: fallback, label: ATLAS_LABEL[fallback] || fallback, reason: `fallback:${mapped}` };
      }
      if (claim.type === 'invariant') {
        return { key: 'INV', label: ATLAS_LABEL.INV, reason: 'claim_type:invariant' };
      }
      if (claim.type === 'implementation_note') {
        return { key: 'IMP', label: ATLAS_LABEL.IMP, reason: 'claim_type:implementation_note' };
      }
      return { key: 'UNMAPPED', label: ATLAS_LABEL.UNMAPPED, reason: 'no_subject_or_location_rule' };
    }

    function buildConflictRatioMap(checkpoints) {
      const ratios = new Map();
      const rows = checkpoints && checkpoints.conflict_resolution && Array.isArray(checkpoints.conflict_resolution.items)
        ? checkpoints.conflict_resolution.items
        : [];
      rows.forEach(row => {
        const claimId = extractClaimIdFromItem(row);
        if (!claimId) return;
        const ratio = Number(row.conflict_ratio || 0);
        if (!Number.isNaN(ratio)) ratios.set(claimId, ratio);
      });
      return ratios;
    }

    function governancePressureScore(claimId, signals, epochMap, conflictRatios) {
      let score = 0;
      if (signals.decisionClaims.has(claimId)) score += 2.0;
      if (signals.creativeClaims.has(claimId)) score += 1.6;
      if (signals.conflictClaims.has(claimId)) score += 1.4;
      const ratio = Number(conflictRatios.get(claimId) || 0);
      if (ratio > 0) score += Math.min(1.5, ratio * 1.5);
      const epochSlot = epochMap.get(claimId);
      if (epochSlot) {
        const staleRatio = Number(epochSlot.stale_ratio || 0);
        if (staleRatio > 0.4) score += 0.6;
      }
      return score;
    }

    function statusSummary(claims) {
      const counts = {};
      claims.forEach(c => {
        const status = c.status || 'unknown';
        counts[status] = (counts[status] || 0) + 1;
      });
      const order = ['stable', 'active', 'provisional', 'candidate', 'legacy', 'unknown'];
      return order.filter(k => counts[k]).map(k => `${k} ${counts[k]}`).join(' \u2022 ');
    }

    function updateMapLegend(lens) {
      if (!els.mapLegend) return;
      if (els.mapLegendMode) {
        els.mapLegendMode.textContent = lens === 'governance_heat'
          ? 'Governance Heat lens active'
          : 'Subsystem Atlas lens active';
      }
      els.mapLegend.querySelectorAll('[data-lens-only]').forEach(node => {
        const target = String(node.getAttribute('data-lens-only') || '').trim();
        node.hidden = !!target && target !== lens;
      });
    }

    function readLegendTogglePref(key, fallback) {
      try {
        const raw = localStorage.getItem(`ree_explorer.legend.${key}`);
        if (raw === '0') return false;
        if (raw === '1') return true;
      } catch (_) {}
      return fallback;
    }

    function writeLegendTogglePref(key, expanded) {
      try {
        localStorage.setItem(`ree_explorer.legend.${key}`, expanded ? '1' : '0');
      } catch (_) {}
    }

    function setLegendToggleState(button, body, expanded) {
      if (!button || !body) return;
      body.hidden = !expanded;
      button.textContent = expanded ? 'Hide key' : 'Show key';
      button.setAttribute('aria-expanded', expanded ? 'true' : 'false');
      button.setAttribute('aria-controls', body.id);
    }

    function initLegendToggles() {
      document.querySelectorAll('.legend-toggle[data-target]').forEach(button => {
        const targetId = String(button.getAttribute('data-target') || '').trim();
        if (!targetId) return;
        const body = document.getElementById(targetId);
        if (!body) return;
        const pref = String(button.getAttribute('data-pref') || targetId).trim();
        const initialExpanded = readLegendTogglePref(pref, true);
        setLegendToggleState(button, body, initialExpanded);
        button.addEventListener('click', () => {
          const nextExpanded = !!body.hidden;
          setLegendToggleState(button, body, nextExpanded);
          writeLegendTogglePref(pref, nextExpanded);
        });
      });
    }

    function renderMap() {
      if (!els.mapGrid) return;
      const checkpoints = governanceAgenda && governanceAgenda.checkpoints
        ? governanceAgenda.checkpoints
        : {};
      const epochMap = buildEpochApplicabilityMap(checkpoints);
      const signals = buildGovernanceClaimSignals(checkpoints);
      const conflictRatios = buildConflictRatioMap(checkpoints);
      const lens = els.mapLens ? String(els.mapLens.value || 'atlas') : 'atlas';
      updateMapLegend(lens);
      const epochOnly = els.mapEpochOnly ? !!els.mapEpochOnly.checked : true;
      const governanceOnly = els.mapGovernanceOnly ? !!els.mapGovernanceOnly.checked : false;

      let filtered = applyFilters();
      if (epochOnly) {
        filtered = filtered.filter(c => isCurrentEpochClaim(c.id, epochMap));
      }
      if (governanceOnly) {
        filtered = filtered.filter(c => {
          return signals.decisionClaims.has(c.id)
            || signals.conflictClaims.has(c.id)
            || signals.creativeClaims.has(c.id);
        });
      }

      const groups = new Map();
      filtered.forEach(c => {
        const atlas = atlasGroupForClaim(c);
        const key = atlas.key;
        if (!groups.has(key)) {
          groups.set(key, {
            key,
            label: atlas.label || ATLAS_LABEL[key] || key,
            claims: [],
            decision: 0,
            conflict: 0,
            creative: 0,
            pressure_total: 0,
          });
        }
        const hasDecision = signals.decisionClaims.has(c.id);
        const hasConflict = signals.conflictClaims.has(c.id);
        const hasCreative = signals.creativeClaims.has(c.id);
        const pressure = governancePressureScore(c.id, signals, epochMap, conflictRatios);
        const slot = groups.get(key);
        slot.claims.push({
          claim: c,
          atlas,
          hasDecision,
          hasConflict,
          hasCreative,
          pressure,
          staleOnly: !isCurrentEpochClaim(c.id, epochMap),
        });
        if (hasDecision) slot.decision += 1;
        if (hasConflict) slot.conflict += 1;
        if (hasCreative) slot.creative += 1;
        slot.pressure_total += pressure;
      });
      const keys = Array.from(groups.keys()).sort((a, b) => {
        if (lens === 'governance_heat') {
          const as = groups.get(a);
          const bs = groups.get(b);
          const av = as && as.claims.length ? as.pressure_total / as.claims.length : 0;
          const bv = bs && bs.claims.length ? bs.pressure_total / bs.claims.length : 0;
          if (bv !== av) return bv - av;
        }
        const ai = ATLAS_ORDER.indexOf(a);
        const bi = ATLAS_ORDER.indexOf(b);
        if (ai === -1 && bi === -1) return String(a).localeCompare(String(b));
        if (ai === -1) return 1;
        if (bi === -1) return -1;
        return ai - bi;
      });

      els.mapGrid.innerHTML = '';
      let decisionCount = 0;
      let conflictCount = 0;
      let creativeCount = 0;
      keys.forEach(key => {
        const group = groups.get(key);
        if (!group || !group.claims.length) return;
        const claims = group.claims.slice();
        if (lens === 'governance_heat') {
          claims.sort((a, b) => {
            if (b.pressure !== a.pressure) return b.pressure - a.pressure;
            return a.claim.id.localeCompare(b.claim.id);
          });
        } else {
          claims.sort((a, b) => a.claim.id.localeCompare(b.claim.id));
        }

        const avgPressure = group.claims.length
          ? group.pressure_total / group.claims.length
          : 0;
        const card = document.createElement('div');
        card.className = 'map-card';
        if (lens === 'governance_heat') {
          if (avgPressure >= 3.2) card.classList.add('heat-high');
          else if (avgPressure >= 1.8) card.classList.add('heat-medium');
          else card.classList.add('heat-low');
        }
        const title = document.createElement('h3');
        title.textContent = group.label;
        const meta = document.createElement('div');
        meta.className = 'map-meta';
        const statusText = statusSummary(claims.map(entry => entry.claim));
        const signalText = `D ${group.decision}  C ${group.conflict}  I ${group.creative}`;
        if (lens === 'governance_heat') {
          meta.textContent = `Total ${claims.length}  Heat ${avgPressure.toFixed(2)}  ${signalText}` + (statusText ? `  ${statusText}` : '');
        } else {
          meta.textContent = `Total ${claims.length}` + (statusText ? `  ${statusText}` : '') + `  ${signalText}`;
        }
        const chips = document.createElement('div');
        chips.className = 'map-chips';
        claims.forEach(entry => {
          const c = entry.claim;
          const hasDecision = entry.hasDecision;
          const hasConflict = entry.hasConflict;
          const hasCreative = entry.hasCreative;
          if (hasDecision) decisionCount += 1;
          if (hasConflict) conflictCount += 1;
          if (hasCreative) creativeCount += 1;

          const chip = document.createElement('span');
          chip.className = 'map-chip';
          if (hasDecision) chip.classList.add('signal-decision');
          if (hasConflict) chip.classList.add('signal-conflict');
          if (hasCreative) chip.classList.add('signal-creative');
          if (entry.staleOnly) chip.classList.add('stale-only');
          if (selectedId === c.id) chip.classList.add('selected');
          const flags = [];
          if (hasDecision) flags.push('decision_queue');
          if (hasConflict) flags.push('conflict_queue');
          if (hasCreative) flags.push('creative_structure_review');
          if (entry.staleOnly) flags.push('stale_only');
          flags.push(entry.atlas.reason);
          chip.title = flags.length ? `${c.id}: ${flags.join(', ')}` : c.id;

          const label = document.createElement('span');
          label.textContent = c.id;
          chip.appendChild(label);

          const badges = document.createElement('span');
          badges.className = 'map-badges';
          if (hasDecision) {
            const b = document.createElement('span');
            b.className = 'map-badge decision';
            b.textContent = 'D';
            b.title = 'Human decision queue';
            badges.appendChild(b);
          }
          if (hasCreative) {
            const b = document.createElement('span');
            b.className = 'map-badge creative';
            b.textContent = 'I';
            b.title = 'Human inspiration / generative design input';
            badges.appendChild(b);
          }
          if (hasConflict) {
            const b = document.createElement('span');
            b.className = 'map-badge conflict';
            b.textContent = 'C';
            b.title = 'Conflict queue';
            badges.appendChild(b);
          }
          if (lens === 'governance_heat') {
            const b = document.createElement('span');
            b.className = 'map-badge';
            b.textContent = `${Math.round(entry.pressure)}`;
            b.title = `Governance pressure score: ${entry.pressure.toFixed(2)}`;
            badges.appendChild(b);
          }
          if (badges.childNodes.length) chip.appendChild(badges);

          chip.addEventListener('click', () => selectClaim(c.id));
          chips.appendChild(chip);
        });
        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(chips);
        els.mapGrid.appendChild(card);
      });

      if (els.mapMeta) {
        const tokens = [
          `Lens: ${lens === 'governance_heat' ? 'Governance Heat' : 'Subsystem Atlas'}`,
          `Claims shown: ${filtered.length}`,
          `Subsystems shown: ${keys.length}`,
          `Decision-signaled: ${decisionCount}`,
          `Creative-signaled: ${creativeCount}`,
          `Conflict-signaled: ${conflictCount}`,
        ];
        if (epochOnly) tokens.push('Epoch filter: ON');
        if (governanceOnly) tokens.push('Governance filter: ON');
        els.mapMeta.textContent = tokens.join(' | ');
      }
    }

    async function fetchJson(url) {
      const text = await fetchText(url);
      return JSON.parse(text);
    }

    function stripTicks(value) {
      if (value === null || value === undefined) return '';
      return String(value).replace(/`/g, '');
    }

    function toCellText(value) {
      if (Array.isArray(value)) return value.map(v => stripTicks(v)).join(', ');
      if (value === null || value === undefined) return '';
      if (typeof value === 'object') return JSON.stringify(value);
      return stripTicks(value);
    }

    function normalizeClaimId(value) {
      if (value === null || value === undefined) return '';
      const match = stripTicks(value).match(/\b(INV|ARC|MECH|IMPL|Q)-\d{3}\b/);
      return match ? match[0] : '';
    }

    function repoRelativePath(location) {
      if (!location) return '';
      let path = stripTicks(location).trim();
      if (!path) return '';
      if (path.match(/^https?:\/\//)) return path;
      if (path.startsWith(REPO_ABS_PREFIX)) {
        path = path.slice(REPO_ABS_PREFIX.length);
      } else {
        const marker = '/REE_assembly/';
        const markerIdx = path.indexOf(marker);
        if (markerIdx !== -1) path = path.slice(markerIdx + marker.length);
      }
      if (path.startsWith('./') || path.startsWith('../') || path.startsWith('#')) return path;
      if (path.startsWith('/')) path = path.slice(1);
      if (path.startsWith('docs/')) return '../' + path.slice(5);
      return '../../' + path;
    }

    function checkpointLabel(key) {
      if (!key) return '';
      return key.replace(/_/g, ' ');
    }

    function collectCheckpointContextDocs(checkpointKey, checkpointData) {
      const docs = new Set((GOVERNANCE_CONTEXT_DOCS[checkpointKey] || []).map(stripTicks));
      const pathFields = ['queue_path', 'patch_queue_path', 'report_path', 'index_path', 'active_index_path', 'archive_index_path', 'source_path'];
      pathFields.forEach(field => {
        const value = checkpointData && checkpointData[field];
        if (value) docs.add(stripTicks(value));
      });
      const itemPathFields = ['dossier_md_path'];
      const items = checkpointData && Array.isArray(checkpointData.items) ? checkpointData.items : [];
      items.slice(0, 10).forEach(item => {
        itemPathFields.forEach(field => {
          if (item && item[field]) docs.add(stripTicks(item[field]));
        });
      });
      return Array.from(docs);
    }

    function renderContextLinks(paths) {
      if (!paths || !paths.length) return '';
      return `<div class="gov-context-links">${paths.map(path => {
        const href = repoRelativePath(path);
        const label = stripTicks(path).replace(REPO_ABS_PREFIX, '');
        return `<a class="gov-link-chip" href="${escapeHtml(href)}" target="_blank" rel="noopener">${escapeHtml(label)}</a>`;
      }).join('')}</div>`;
    }

    function renderCheckpointMeta(checkpointKey, checkpointData) {
      const prompt = checkpointData && checkpointData.prompt
        ? `<div class="gov-meta">${escapeHtml(checkpointData.prompt)}</div>`
        : '';
      const contextDocs = collectCheckpointContextDocs(checkpointKey, checkpointData);
      const contextLinks = renderContextLinks(contextDocs);
      return `${prompt}${contextLinks}`;
    }

    function renderClaimCell(rawClaimId) {
      const claimId = normalizeClaimId(rawClaimId);
      if (!claimId) return escapeHtml(toCellText(rawClaimId)) || '-';
      const claim = claimMap.get(claimId);
      if (!claim) return `<code>${escapeHtml(claimId)}</code>`;
      const subject = claim.subject ? escapeHtml(claim.subject) : '';
      const type = claim.type ? escapeHtml(claim.type.replace(/_/g, ' ')) : '';
      const loc = claim.location ? repoRelativePath(claim.location) : '';
      const locHtml = loc
        ? `<div class="gov-claim-meta"><a href="${escapeHtml(loc)}" target="_blank" rel="noopener">spec anchor</a></div>`
        : '';
      return `
        <div class="gov-claim-cell">
          <div><code>${escapeHtml(claimId)}</code></div>
          ${subject ? `<div>${subject}</div>` : ''}
          ${type ? `<div class="gov-claim-meta">${type}</div>` : ''}
          ${locHtml}
        </div>
      `;
    }

    function extractClaimIdFromItem(item) {
      if (!item || typeof item !== 'object') return '';
      return normalizeClaimId(item.claim_id || item.id || item.claim || '');
    }

    function buildEpochApplicabilityMap(checkpoints) {
      const out = new Map();
      const epoch = checkpoints && checkpoints.architecture_epoch_applicability
        ? checkpoints.architecture_epoch_applicability
        : {};
      const rows = Array.isArray(epoch.claims_with_stale_entries)
        ? epoch.claims_with_stale_entries
        : [];
      rows.forEach(row => {
        const claimId = normalizeClaimId(row.claim_id);
        if (!claimId) return;
        const applicable = Number(row.applicable_entries || 0);
        const stale = Number(row.stale_entries || 0);
        out.set(claimId, {
          applicable_entries: applicable,
          stale_entries: stale,
          stale_ratio: Number(row.stale_ratio || 0),
          current_epoch_only: applicable > 0,
        });
      });
      return out;
    }

    function isCurrentEpochClaim(claimId, epochMap) {
      const normalized = normalizeClaimId(claimId);
      if (!normalized) return true;
      if (!epochMap || !epochMap.size) return true;
      const slot = epochMap.get(normalized);
      if (!slot) return true;
      return Number(slot.applicable_entries || 0) > 0;
    }

    function filterRowsByCurrentEpoch(rows, epochMap, enabled) {
      if (!enabled) return rows || [];
      const list = Array.isArray(rows) ? rows : [];
      return list.filter(row => isCurrentEpochClaim(extractClaimIdFromItem(row), epochMap));
    }

    function buildGovernanceClaimSignals(checkpoints) {
      const decisionClaims = new Set();
      const conflictClaims = new Set();
      const creativeClaims = new Set();

      const decisionItems = checkpoints && checkpoints.governance_decisions && Array.isArray(checkpoints.governance_decisions.items)
        ? checkpoints.governance_decisions.items
        : [];
      decisionItems.forEach(item => {
        const claimId = extractClaimIdFromItem(item);
        if (claimId) decisionClaims.add(claimId);
      });

      const conflictItems = checkpoints && checkpoints.conflict_resolution && Array.isArray(checkpoints.conflict_resolution.items)
        ? checkpoints.conflict_resolution.items
        : [];
      conflictItems.forEach(item => {
        const claimId = extractClaimIdFromItem(item);
        if (claimId) conflictClaims.add(claimId);
      });

      const structureItems = checkpoints && checkpoints.architecture_structure && Array.isArray(checkpoints.architecture_structure.consider_new_structure)
        ? checkpoints.architecture_structure.consider_new_structure
        : [];
      structureItems.forEach(item => {
        const claimId = extractClaimIdFromItem(item);
        if (claimId) creativeClaims.add(claimId);
      });

      return { decisionClaims, conflictClaims, creativeClaims };
    }

    function stalenessBadge(generatedAtUtc) {
      if (!generatedAtUtc) return { label: 'unknown', cls: 'old' };
      const then = new Date(generatedAtUtc);
      if (Number.isNaN(then.getTime())) return { label: 'unknown', cls: 'old' };
      const ageMin = (Date.now() - then.getTime()) / 60000;
      if (ageMin <= 120) return { label: `fresh (${Math.round(ageMin)}m)`, cls: 'fresh' };
      if (ageMin <= 1440) return { label: `stale (${Math.round(ageMin / 60)}h)`, cls: 'stale' };
      return { label: `old (${Math.round(ageMin / 1440)}d)`, cls: 'old' };
    }

    function renderGovTable(rows, columns, emptyText) {
      if (!rows || !rows.length) {
        return `<div class="gov-empty">${escapeHtml(emptyText || 'No items')}</div>`;
      }
      const head = columns.map(col => `<th>${escapeHtml(col.label)}</th>`).join('');
      const body = rows.map(row => {
        const cells = columns.map(col => {
          if (col.render) {
            const rendered = col.render(row[col.key], row);
            return `<td>${rendered || '-'}</td>`;
          }
          const raw = col.format ? col.format(row[col.key], row) : row[col.key];
          return `<td>${escapeHtml(toCellText(raw)) || '-'}</td>`;
        }).join('');
        return `<tr>${cells}</tr>`;
      }).join('');
      return `<table class="gov-table"><thead><tr>${head}</tr></thead><tbody>${body}</tbody></table>`;
    }

    function commandRowsHtml() {
      const rows = [
        { label: 'Run governance cycle', cmd: CMD_RUN_GOVERNANCE },
        { label: 'Run strict governance cycle', cmd: CMD_RUN_GOVERNANCE_STRICT },
        { label: 'Record decision (template)', cmd: CMD_RECORD_DECISION_TEMPLATE },
      ];
      return rows.map((row, idx) => `
        <div class="command-row">
          <div class="meta">${escapeHtml(row.label)}</div>
          <code>${escapeHtml(row.cmd)}</code>
          <button class="ghost" data-copy-cmd="${escapeHtml(row.cmd)}" data-copy-id="cmd-${idx}">Copy Command</button>
        </div>
      `).join('');
    }

    async function copyText(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
        return;
      }
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      ta.remove();
    }

    function wireGovernanceCommandButtons() {
      if (!els.governanceContent) return;
      els.governanceContent.querySelectorAll('button[data-copy-cmd]').forEach(btn => {
        btn.addEventListener('click', async () => {
          const cmd = btn.getAttribute('data-copy-cmd') || '';
          if (!cmd) return;
          const status = els.governanceContent.querySelector('#governanceCopyStatus');
          try {
            await copyText(cmd);
            if (status) status.textContent = 'Command copied to clipboard.';
          } catch (_) {
            if (status) status.textContent = 'Copy failed. Select command text manually.';
          }
        });
      });
    }

    async function refreshGovernanceData() {
      governanceLoading = true;
      governanceError = '';
      try {
        governanceAgenda = await fetchJson(GOVERNANCE_AGENDA_URL);
      } catch (err) {
        governanceAgenda = null;
        governanceError = String(err);
      }

      try {
        governanceBacklog = await fetchJson(GOVERNANCE_BACKLOG_URL);
      } catch (_) {
        governanceBacklog = null;
      }
      try {
        governanceProposals = await fetchJson(GOVERNANCE_PROPOSALS_URL);
      } catch (_) {
        governanceProposals = null;
      }
      governanceLoadedAt = new Date().toISOString();
      governanceLoading = false;
      if (currentView === 'governance') renderGovernance();
      if (currentView === 'map') renderMap();
      refreshTripleAnnotationsFromCurrentFilters();
    }

    function renderGovernance() {
      if (!els.governanceContent) return;
      if (governanceLoading && !governanceAgenda) {
        els.governanceContent.innerHTML = '<div class="gov-empty">Loading governance agenda...</div>';
        return;
      }

      if (!governanceAgenda) {
        const errorText = governanceError
          ? `Agenda unavailable: ${governanceError}`
          : 'Agenda unavailable. Run the governance cycle and refresh.';
        els.governanceContent.innerHTML = `
          <div class="gov-empty">${escapeHtml(errorText)}</div>
          <div class="gov-section">
            <h3>Manual Commands</h3>
            <div class="command-list">${commandRowsHtml()}</div>
            <div id="governanceCopyStatus" class="gov-meta"></div>
          </div>
        `;
        wireGovernanceCommandButtons();
        return;
      }

      const summary = governanceAgenda.summary || {};
      const checkpoints = governanceAgenda.checkpoints || {};
      const epochMap = buildEpochApplicabilityMap(checkpoints);
      const epochOnly = els.govEpochOnly ? !!els.govEpochOnly.checked : true;
      const thoughtItems = (checkpoints.thought_intake && checkpoints.thought_intake.items) || [];
      const conflictItemsRaw = (checkpoints.conflict_resolution && checkpoints.conflict_resolution.items) || [];
      const decisionItemsRaw = (checkpoints.governance_decisions && checkpoints.governance_decisions.items) || [];
      const conflictItems = filterRowsByCurrentEpoch(conflictItemsRaw, epochMap, epochOnly);
      const decisionItems = filterRowsByCurrentEpoch(decisionItemsRaw, epochMap, epochOnly);
      const structureItemsRaw = (checkpoints.architecture_structure && checkpoints.architecture_structure.consider_new_structure) || [];
      const structureItems = filterRowsByCurrentEpoch(structureItemsRaw, epochMap, epochOnly);
      const autonomyItems = (checkpoints.autonomy_triage && checkpoints.autonomy_triage.items) || [];
      const dispatch = checkpoints.evidence_dispatch || {};
      const highPriorityRaw = dispatch.high_priority_proposals || [];
      const highPriority = filterRowsByCurrentEpoch(highPriorityRaw, epochMap, epochOnly);
      const dispatchByRepo = dispatch.by_target_repo || [];
      const maintenance = checkpoints.maintenance || {};
      const maintenanceRuns = maintenance.unlinked_runs || [];
      const warnings = governanceAgenda.warnings || [];
      const generatedAt = governanceAgenda.generated_at_utc || '';
      const stale = stalenessBadge(generatedAt);

      const backlogItems = governanceBacklog && governanceBacklog.items ? governanceBacklog.items : [];
      const highBacklogRows = backlogItems
        .filter(item => item.priority === 'high')
        .slice(0, 15);
      const highBacklogVisible = filterRowsByCurrentEpoch(highBacklogRows, epochMap, epochOnly);

      const isPendingDecision = (item) => {
        const token = String((item && item.decision_status) || '').toLowerCase().trim();
        return !token || !['applied', 'approved', 'done'].includes(token);
      };
      const claimDecisionRows = decisionItems.filter(isPendingDecision);
      const humanOnlyRows = autonomyItems.filter(item => String(item.tier || '').toUpperCase() === 'HUMAN_ONLY');
      const approvalRows = autonomyItems.filter(item => {
        const tier = String(item.tier || '').toUpperCase();
        const needed = String(item.decision_needed || '').toLowerCase() === 'yes';
        return tier === 'AUTO_WITH_APPROVAL' && needed;
      });
      const humanDecisionRows = [
        ...claimDecisionRows.map(item => ({
          source: 'claim_queue',
          claim_id: item.claim_id || '',
          work_item: item.decision_needed || '',
          recommendation: item.recommendation || '',
          rationale: item.decision_status ? `decision_status=${item.decision_status}` : '',
        })),
        ...humanOnlyRows.map(item => ({
          source: 'autonomy_gate',
          claim_id: '',
          work_item: item.work_item || '',
          recommendation: item.recommendation || '',
          rationale: item.rationale || '',
        })),
        ...approvalRows.map(item => ({
          source: 'approval_gate',
          claim_id: '',
          work_item: item.work_item || '',
          recommendation: item.recommendation || '',
          rationale: item.rationale || '',
        })),
      ];
      const creativeRows = structureItems
        .filter(item => Boolean(item.consider_new_structure) || Boolean(item.escalate_architecture_decision))
        .slice(0, 20);

      const allProposals = governanceProposals && governanceProposals.items ? governanceProposals.items : [];
      const checkpointGuideRows = Object.entries(checkpoints).map(([key, checkpoint]) => ({
        checkpoint: checkpointLabel(key),
        prompt: checkpoint && checkpoint.prompt ? checkpoint.prompt : '',
        context_docs: collectCheckpointContextDocs(key, checkpoint),
      }));

      const generatedLabel = generatedAt ? new Date(generatedAt).toLocaleString() : 'unknown';
      const loadedLabel = governanceLoadedAt ? new Date(governanceLoadedAt).toLocaleTimeString() : 'unknown';
      const epochLabel = epochOnly ? 'current epoch only' : 'all epochs';
      if (els.governanceMeta) {
        els.governanceMeta.innerHTML =
          `Agenda generated: <strong>${escapeHtml(generatedLabel)}</strong>` +
          `<span class="gov-staleness ${escapeHtml(stale.cls)}">${escapeHtml(stale.label)}</span>` +
          ` &nbsp;|&nbsp; dashboard refreshed: ${escapeHtml(loadedLabel)}` +
          ` &nbsp;|&nbsp; scope: ${escapeHtml(epochLabel)}`;
      }

      const cards = `
        <div class="governance-grid">
          <div class="gov-card"><div class="label">Unprocessed Thoughts</div><div class="value">${Number(summary.thought_unprocessed || 0)}</div></div>
          <div class="gov-card"><div class="label">Conflicts (visible)</div><div class="value">${conflictItems.length}</div></div>
          <div class="gov-card"><div class="label">Decision Queue (visible)</div><div class="value">${decisionItems.length}</div></div>
          <div class="gov-card"><div class="label">Human Decisions Needed</div><div class="value">${humanDecisionRows.length}</div></div>
          <div class="gov-card"><div class="label">Inspiration / Generative Needed</div><div class="value">${creativeRows.length}</div></div>
          <div class="gov-card"><div class="label">High Priority Backlog (visible)</div><div class="value">${highBacklogVisible.length}</div></div>
          <div class="gov-card"><div class="label">High Priority Proposals (visible)</div><div class="value">${highPriority.length}</div></div>
          <div class="gov-card"><div class="label">Warnings</div><div class="value">${Number(summary.warnings || 0)}</div></div>
        </div>
      `;

      const checkpointSections = `
        <div class="gov-sections">
          <div class="gov-section">
            <h3>Checkpoint Guide</h3>
            ${renderGovTable(
              checkpointGuideRows,
              [
                { key: 'checkpoint', label: 'checkpoint' },
                { key: 'prompt', label: 'prompt' },
                { key: 'context_docs', label: 'context_docs', render: value => renderContextLinks(value) },
              ],
              'No checkpoints available.'
            )}
          </div>
          <div class="gov-section">
            <h3>Thought Intake</h3>
            ${renderCheckpointMeta('thought_intake', checkpoints.thought_intake)}
            ${renderGovTable(
              thoughtItems,
              [
                { key: 'file', label: 'file' },
                { key: 'status', label: 'status' },
              ],
              'No unprocessed thoughts.'
            )}
          </div>
          <div class="gov-section">
            <h3>Conflict Resolution</h3>
            ${renderCheckpointMeta('conflict_resolution', checkpoints.conflict_resolution)}
            ${renderGovTable(
              conflictItems,
              [
                { key: 'claim_id', label: 'claim', render: value => renderClaimCell(value) },
                { key: 'conflict_types', label: 'conflict_types' },
                { key: 'conflict_ratio', label: 'conflict_ratio' },
                { key: 'latest', label: 'latest' },
              ],
              'No active conflicts.'
            )}
          </div>
          <div class="gov-section">
            <h3>Governance Decisions <span class="gov-pill human">human ${humanDecisionRows.length}</span></h3>
            ${renderCheckpointMeta('governance_decisions', checkpoints.governance_decisions)}
            ${renderGovTable(
              decisionItems,
              [
                { key: 'claim_id', label: 'claim', render: value => renderClaimCell(value) },
                { key: 'decision_needed', label: 'decision_needed' },
                { key: 'recommendation', label: 'recommendation' },
                { key: 'decision_status', label: 'decision_status' },
              ],
              'No decision items.'
            )}
          </div>
          <div class="gov-section">
            <h3>Human Attention Queue <span class="gov-pill human">decide ${humanDecisionRows.length}</span><span class="gov-pill creative">design ${creativeRows.length}</span></h3>
            ${renderContextLinks([
              'evidence/planning/GOVERNANCE_AGENDA.md',
              'evidence/planning/structure_review/latest/ACTIVE_INDEX.md',
            ])}
            <div class="gov-meta">Items in this section require explicit human ownership and cannot be resolved by automated runs alone.</div>
            ${renderGovTable(
              humanDecisionRows,
              [
                { key: 'source', label: 'source' },
                { key: 'claim_id', label: 'claim', render: value => value ? renderClaimCell(value) : '-' },
                { key: 'work_item', label: 'work_item' },
                { key: 'recommendation', label: 'recommendation' },
                { key: 'rationale', label: 'rationale' },
              ],
              'No explicit human-decision items.'
            )}
            <div style="height:8px;"></div>
            ${renderGovTable(
              creativeRows,
              [
                { key: 'claim_id', label: 'claim', render: value => renderClaimCell(value) },
                { key: 'recommendation', label: 'recommendation' },
                { key: 'conflict_ratio', label: 'conflict_ratio' },
                { key: 'trigger_signals', label: 'trigger_signals' },
              ],
              'No explicit human-inspiration items.'
            )}
          </div>
          <div class="gov-section">
            <h3>Backlog (High Priority)</h3>
            ${renderContextLinks([
              'evidence/planning/evidence_backlog.v1.json',
              'evidence/planning/ARCHITECTURE_GAP_REGISTER.md',
            ])}
            ${renderGovTable(
              highBacklogVisible,
              [
                { key: 'backlog_id', label: 'backlog_id' },
                { key: 'claim_id', label: 'claim', render: value => renderClaimCell(value) },
                { key: 'evidence_needed', label: 'evidence_needed' },
                { key: 'reasons', label: 'reasons' },
              ],
              'No high-priority backlog items.'
            )}
          </div>
          <div class="gov-section">
            <h3>Evidence Dispatch by Repo</h3>
            ${renderCheckpointMeta('evidence_dispatch', checkpoints.evidence_dispatch)}
            ${renderGovTable(
              dispatchByRepo,
              [
                { key: 'target_repo', label: 'target_repo' },
                { key: 'total', label: 'total' },
                { key: 'experimental', label: 'experimental' },
                { key: 'literature_review', label: 'literature_review' },
              ],
              'No dispatch items.'
            )}
          </div>
          <div class="gov-section">
            <h3>High Priority Proposals</h3>
            ${renderCheckpointMeta('evidence_dispatch', checkpoints.evidence_dispatch)}
            ${renderGovTable(
              highPriority,
              [
                { key: 'proposal_id', label: 'proposal_id' },
                { key: 'claim_id', label: 'claim', render: value => renderClaimCell(value) },
                { key: 'proposal_type', label: 'type' },
                { key: 'target_repo', label: 'target_repo' },
                { key: 'status', label: 'status' },
              ],
              'No high-priority proposals.'
            )}
            <div class="gov-meta" style="margin-top:8px;">
              Total proposals in file: ${allProposals.length} | visible under scope: ${highPriority.length}
            </div>
          </div>
          <div class="gov-section">
            <h3>Maintenance Flags</h3>
            ${renderCheckpointMeta('maintenance', checkpoints.maintenance)}
            ${renderGovTable(
              maintenanceRuns,
              [
                { key: 'source_type', label: 'source_type' },
                { key: 'experiment_type', label: 'experiment_type' },
                { key: 'run_id', label: 'run_id' },
                { key: 'status', label: 'status' },
              ],
              'No unlinked evidence runs.'
            )}
            ${warnings.length ? `<div class="gov-meta" style="margin-top:8px;">Warnings: ${escapeHtml(warnings.join(' | '))}</div>` : '<div class="gov-meta" style="margin-top:8px;">Warnings: none</div>'}
          </div>
        </div>
      `;

      els.governanceContent.innerHTML = `
        ${cards}
        <div class="gov-section">
          <h3>Manual Commands</h3>
          <div class="command-list">${commandRowsHtml()}</div>
          <div id="governanceCopyStatus" class="gov-meta"></div>
        </div>
        ${checkpointSections}
      `;
      wireGovernanceCommandButtons();
    }

    function populateDocSelect(filterText) {
      if (!els.docSelect) return;
      const term = (filterText || '').trim().toLowerCase();
      const current = els.docSelect.value;
      els.docSelect.innerHTML = '';
      DOC_GROUPS.forEach(group => {
        const opts = group.docs.filter(doc => {
          if (!term) return true;
          return doc.title.toLowerCase().includes(term) || doc.path.toLowerCase().includes(term);
        });
        if (!opts.length) return;
        const optgroup = document.createElement('optgroup');
        optgroup.label = group.label;
        opts.forEach(doc => {
          const url = doc.path.match(/^https?:\/\//)
            ? doc.path
            : new URL(doc.path, window.location.href).toString();
          const opt = document.createElement('option');
          opt.value = url;
          opt.textContent = doc.title;
          optgroup.appendChild(opt);
        });
        els.docSelect.appendChild(optgroup);
      });
      if (current) {
        const exists = Array.from(els.docSelect.options).some(o => o.value === current);
        if (exists) els.docSelect.value = current;
      }
    }

    function updateDocMeta(entry) {
      if (!els.docMeta) return;
      if (!entry) {
        els.docMeta.textContent = '';
        return;
      }
      els.docMeta.textContent = `${entry.title}  ${entry.path}`;
    }

    function wireDocLinks(baseUrl) {
      if (!els.docContent) return;
      els.docContent.querySelectorAll('a[href]').forEach(link => {
        const href = link.getAttribute('href');
        if (!href) return;
        if (href.startsWith('#')) {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const target = els.docContent.querySelector(href);
            if (target) target.scrollIntoView({ block: 'start' });
          });
          return;
        }
        if (href.includes('.md')) {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const url = new URL(href, baseUrl).toString();
            const [pathOnly, anchor] = url.split('#', 2);
            openDoc(pathOnly, anchor);
          });
          return;
        }
        link.setAttribute('target', '_blank');
      });
    }

    async function openDoc(path, anchor) {
      if (!path) return;
      const url = path.match(/^https?:\/\//)
        ? path
        : new URL(path, window.location.href).toString();
      currentDocUrl = url;
      const entry = docIndexMap.get(url);
      if (entry && els.docSelect) {
        els.docSelect.value = url;
        updateDocMeta(entry);
      } else if (els.docMeta) {
        const displayPath = path.replace(new URL(window.location.href).origin, '');
        els.docMeta.textContent = displayPath;
      }
      try {
        const text = await fetchText(url);
        if (els.docContent) {
          els.docContent.innerHTML = renderMarkdown(text);
          wireDocLinks(url);
          if (anchor) {
            const target = els.docContent.querySelector(`#${anchor}`);
            if (target) target.scrollIntoView({ block: 'start' });
          }
        }
      } catch (err) {
        if (els.docContent) {
          els.docContent.innerHTML = `<div class="meta">Failed to load document: ${escapeHtml(String(err))}</div>`;
        }
      }
    }

    function openDocFromLocation(location) {
      if (!location) return;
      const rel = relativeLink(location);
      const parts = rel.split('#');
      const path = parts[0];
      const anchor = parts.length > 1 ? parts[1] : null;
      setView('docs');
      openDoc(path, anchor);
    }

    function initDocs() {
      if (docsInitialized) return;
      buildDocIndex();
      populateDocSelect('');
      if (els.docSelect && els.docSelect.value) {
        openDoc(els.docSelect.value);
      }
      docsInitialized = true;
    }

    function normalizeSpace(text) {
      return String(text || '').replace(/\s+/g, ' ').trim();
    }

    function normalizeEdgeLabel(text) {
      return normalizeSpace(String(text || '').replace(/^["'`]+|["'`]+$/g, ''));
    }

    function escapeSelectorValue(value) {
      if (window.CSS && typeof window.CSS.escape === 'function') return window.CSS.escape(String(value));
      return String(value).replace(/[^a-zA-Z0-9_\-]/g, '\\$&');
    }

    function parseFlowchartMmd(text) {
      const nodes = new Map();
      const edges = [];
      const lines = String(text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');

      lines.forEach((raw, idx) => {
        const line = raw.replace(/%%.*$/, '').trim();
        if (!line) return;

        const quotedNodeRe = /\b([A-Za-z][A-Za-z0-9_]*)\s*\[\s*"([^"]+)"\s*\]/g;
        let match = null;
        while ((match = quotedNodeRe.exec(line)) !== null) {
          const nodeId = match[1];
          const label = normalizeSpace(match[2]) || nodeId;
          if (!nodes.has(nodeId)) nodes.set(nodeId, { id: nodeId, label });
        }

        const plainNodeRe = /\b([A-Za-z][A-Za-z0-9_]*)\s*\[\s*([^\]"'][^\]]*?)\s*\]/g;
        while ((match = plainNodeRe.exec(line)) !== null) {
          const nodeId = match[1];
          if (nodes.has(nodeId)) continue;
          const label = normalizeSpace(match[2]) || nodeId;
          nodes.set(nodeId, { id: nodeId, label });
        }

        const edgeMatch = line.match(/^([A-Za-z][A-Za-z0-9_]*)\s*-->\s*(?:\|([^|]+)\|\s*)?([A-Za-z][A-Za-z0-9_]*)\s*$/);
        if (!edgeMatch) return;
        const from = edgeMatch[1];
        const to = edgeMatch[3];
        const label = normalizeEdgeLabel(edgeMatch[2] || '');
        if (!nodes.has(from)) nodes.set(from, { id: from, label: from });
        if (!nodes.has(to)) nodes.set(to, { id: to, label: to });
        edges.push({
          id: `flow-${from}-${to}-${idx}`,
          from,
          to,
          label,
        });
      });

      return {
        type: 'flowchart',
        nodes: Array.from(nodes.values()),
        edges,
      };
    }

    function parseSequenceMmd(text) {
      const nodes = new Map();
      const edges = [];
      const lines = String(text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');

      lines.forEach((raw, idx) => {
        const line = raw.trim();
        if (!line) return;

        const participantMatch = line.match(/^participant\s+([A-Za-z][A-Za-z0-9_]*)\s+as\s+(.+?)\s*$/);
        if (participantMatch) {
          const id = participantMatch[1];
          const label = normalizeSpace(participantMatch[2]) || id;
          if (!nodes.has(id)) nodes.set(id, { id, label });
          return;
        }

        const msgMatch = line.match(/^([A-Za-z][A-Za-z0-9_]*)\s*-+>>\s*([A-Za-z][A-Za-z0-9_]*)\s*:\s*(.+?)\s*$/);
        if (!msgMatch) return;
        const from = msgMatch[1];
        const to = msgMatch[2];
        const label = normalizeEdgeLabel(msgMatch[3] || '');
        if (!nodes.has(from)) nodes.set(from, { id: from, label: from });
        if (!nodes.has(to)) nodes.set(to, { id: to, label: to });
        edges.push({
          id: `seq-${from}-${to}-${idx}`,
          from,
          to,
          label,
        });
      });

      return {
        type: 'sequence',
        nodes: Array.from(nodes.values()),
        edges,
      };
    }

    function parseTripleDiagramModel(spec, mmdText) {
      if (!mmdText) return null;
      const trimmed = String(mmdText).trim();
      if (!trimmed) return null;
      if (trimmed.startsWith('sequenceDiagram')) {
        return parseSequenceMmd(trimmed);
      }
      if (trimmed.startsWith('flowchart')) {
        return parseFlowchartMmd(trimmed);
      }
      return null;
    }

    function compareEpochCandidate(a, b) {
      if (!a) return -1;
      if (!b) return 1;
      if (a.kind === b.kind) {
        if (a.kind === 'time' || a.kind === 'number') {
          return a.value === b.value ? 0 : (a.value > b.value ? 1 : -1);
        }
        return String(a.raw).localeCompare(String(b.raw));
      }
      const rank = { time: 3, number: 2, string: 1 };
      return (rank[a.kind] || 0) - (rank[b.kind] || 0);
    }

    function coerceEpochCandidate(raw) {
      if (raw === null || raw === undefined) return null;
      if (typeof raw === 'number' && Number.isFinite(raw)) {
        return { kind: 'number', value: raw, raw: String(raw) };
      }
      const text = normalizeSpace(raw);
      if (!text) return null;
      const asNumber = Number(text);
      if (!Number.isNaN(asNumber) && Number.isFinite(asNumber)) {
        return { kind: 'number', value: asNumber, raw: text };
      }
      const parsed = Date.parse(text);
      if (!Number.isNaN(parsed)) {
        return { kind: 'time', value: parsed, raw: new Date(parsed).toISOString() };
      }
      return { kind: 'string', value: 0, raw: text };
    }

    function collectEpochCandidates(node, path, out) {
      if (node === null || node === undefined) return;
      if (typeof node !== 'object') {
        const key = path.length ? path[path.length - 1] : '';
        if (!key) return;
        if (!/(epoch|timestamp|generated_at_utc|adjudicated_at_utc|latest)/i.test(key)) return;
        const cand = coerceEpochCandidate(node);
        if (cand) out.push(cand);
        return;
      }
      if (Array.isArray(node)) {
        node.forEach((item, idx) => collectEpochCandidates(item, path.concat(String(idx)), out));
        return;
      }
      Object.entries(node).forEach(([key, value]) => {
        collectEpochCandidates(value, path.concat(key), out);
      });
    }

    function getLatestEpoch(data) {
      const candidates = [];

      const policyEpoch = data
        && data.governanceAgenda
        && data.governanceAgenda.checkpoints
        && data.governanceAgenda.checkpoints.architecture_epoch_applicability
        && data.governanceAgenda.checkpoints.architecture_epoch_applicability.policy
        ? data.governanceAgenda.checkpoints.architecture_epoch_applicability.policy.current_architecture_epoch
        : '';
      const policyEpochStart = data
        && data.governanceAgenda
        && data.governanceAgenda.checkpoints
        && data.governanceAgenda.checkpoints.architecture_epoch_applicability
        && data.governanceAgenda.checkpoints.architecture_epoch_applicability.policy
        ? data.governanceAgenda.checkpoints.architecture_epoch_applicability.policy.epoch_start_utc
        : '';
      const generatedAt = data && data.governanceAgenda ? data.governanceAgenda.generated_at_utc : '';

      [policyEpoch, policyEpochStart, generatedAt].forEach(value => {
        const cand = coerceEpochCandidate(value);
        if (cand) candidates.push(cand);
      });
      collectEpochCandidates(data && data.governanceAgenda ? data.governanceAgenda : {}, ['governanceAgenda'], candidates);

      if (!candidates.length) return '';
      let best = candidates[0];
      for (let i = 1; i < candidates.length; i++) {
        if (compareEpochCandidate(candidates[i], best) > 0) best = candidates[i];
      }
      return best.raw || '';
    }

    function makeClaimRef(claim) {
      if (!claim) return null;
      return {
        id: claim.id,
        title: claim.subject || claim.id,
        type: claim.type || '',
        status: claim.status || '',
        location: claim.location || '',
      };
    }

    function dedupeById(entries) {
      const out = [];
      const seen = new Set();
      (entries || []).forEach(entry => {
        if (!entry) return;
        const id = normalizeSpace(entry.id || entry.claimId || entry.title || JSON.stringify(entry));
        if (!id || seen.has(id)) return;
        seen.add(id);
        out.push(entry);
      });
      return out;
    }

    function mapClaimToTripleAliases(claim, specModel) {
      const aliases = new Set();
      if (!claim || !specModel || !Array.isArray(specModel.nodes)) return aliases;
      const available = new Set(specModel.nodes.map(node => String(node.id || '').trim()).filter(Boolean));
      const hay = `${claim.subject || ''} ${claim.location || ''}`.toLowerCase();

      const subjectPrefix = String(claim.subject || '').split('.')[0].trim();
      if (subjectPrefix) {
        const upper = subjectPrefix.toUpperCase();
        if (available.has(upper)) aliases.add(upper);
      }

      TRIPLE_SUBJECT_ALIAS_HINTS.forEach(([pattern, alias]) => {
        if (pattern.test(hay) && available.has(alias)) aliases.add(alias);
      });

      specModel.nodes.forEach(node => {
        const alias = String(node.id || '').trim();
        if (!alias) return;
        const aliasLower = alias.toLowerCase();
        if (new RegExp(`\\b${escapeRegex(aliasLower)}\\b`, 'i').test(hay)) aliases.add(alias);

        const labelTokens = String(node.label || '')
          .toLowerCase()
          .split(/[^a-z0-9]+/)
          .filter(token => token.length >= 3 && !['ree', 'env', 'stream', 'control', 'typed'].includes(token));
        if (labelTokens.some(token => hay.includes(token))) aliases.add(alias);
      });

      if (!aliases.size) {
        const atlas = atlasGroupForClaim(claim).key;
        const fallback = TRIPLE_ATLAS_ALIAS_FALLBACK[atlas] || [];
        fallback.forEach(alias => {
          if (available.has(alias)) aliases.add(alias);
        });
      }

      return aliases;
    }

    function claimSupportsTripleEdge(claim, edge, aliasMap) {
      if (!claim || !edge) return false;
      const claimAliases = aliasMap.get(claim.id) || new Set();
      if (claimAliases.has(edge.from) && claimAliases.has(edge.to)) return true;

      const deps = Array.isArray(claim.depends_on) ? claim.depends_on : [];
      for (const depId of deps) {
        const depAliases = aliasMap.get(depId) || new Set();
        if (depAliases.has(edge.from) && claimAliases.has(edge.to)) return true;
        if (depAliases.has(edge.to) && claimAliases.has(edge.from)) return true;
      }
      return false;
    }

    function buildViewModelForEpoch(rawData, latestEpoch) {
      const claims = Array.isArray(rawData && rawData.claims) ? rawData.claims : [];
      const filteredClaims = Array.isArray(rawData && rawData.filteredClaims) ? rawData.filteredClaims : claims;
      const filteredSet = new Set(filteredClaims.map(c => c.id));
      const checkpoints = rawData && rawData.governanceAgenda && rawData.governanceAgenda.checkpoints
        ? rawData.governanceAgenda.checkpoints
        : {};
      const epochMap = buildEpochApplicabilityMap(checkpoints);
      const epochClaims = claims.filter(claim => isCurrentEpochClaim(claim.id, epochMap));
      const activeClaims = epochClaims.filter(claim => filteredSet.has(claim.id));
      const activeIds = new Set(activeClaims.map(claim => claim.id));

      const conflictRows = checkpoints && checkpoints.conflict_resolution && Array.isArray(checkpoints.conflict_resolution.items)
        ? checkpoints.conflict_resolution.items
        : [];
      const structureRows = checkpoints && checkpoints.architecture_structure && Array.isArray(checkpoints.architecture_structure.consider_new_structure)
        ? checkpoints.architecture_structure.consider_new_structure
        : [];
      const decisionRows = checkpoints && checkpoints.governance_decisions && Array.isArray(checkpoints.governance_decisions.items)
        ? checkpoints.governance_decisions.items
        : [];

      const conflictsByClaim = new Map();
      const needsByClaim = new Map();
      const evidenceByClaim = new Map();

      function pushMapEntry(map, claimId, entry) {
        const norm = normalizeClaimId(claimId);
        if (!norm || !activeIds.has(norm)) return;
        if (!map.has(norm)) map.set(norm, []);
        map.get(norm).push(entry);
      }

      Object.entries(conflictsMap || {}).forEach(([claimId, files]) => {
        const norm = normalizeClaimId(claimId);
        if (!norm || !activeIds.has(norm)) return;
        (files || []).forEach((filePath, idx) => {
          const short = String(filePath || '').split('/').pop() || String(filePath || '');
          pushMapEntry(conflictsByClaim, norm, {
            id: `conf-file-${norm}-${idx}-${short}`,
            claimId: norm,
            title: short,
            source: 'conflict_file',
            href: relativeLink(filePath),
            detail: filePath,
          });
        });
      });

      conflictRows.forEach((row, idx) => {
        const claimId = extractClaimIdFromItem(row);
        if (!claimId) return;
        const typeLabel = toCellText(row.conflict_types || row.recommendation || 'governance conflict');
        const latest = stripTicks(row.latest || '');
        pushMapEntry(conflictsByClaim, claimId, {
          id: `gov-conf-${claimId}-${idx}`,
          claimId,
          title: typeLabel || 'governance conflict',
          source: 'governance_conflict',
          detail: latest || '',
          ratio: Number(row.conflict_ratio || 0),
        });
      });

      structureRows.forEach((row, idx) => {
        const claimId = extractClaimIdFromItem(row);
        if (!claimId) return;
        const needTitle = toCellText(row.recommendation || row.consider_new_structure || row.escalate_architecture_decision || 'needs structure review');
        const signals = toCellText(row.trigger_signals || []);
        pushMapEntry(needsByClaim, claimId, {
          id: String(row.gap_id || `need-${claimId}-${idx}`),
          claimId,
          title: needTitle || 'needs structure review',
          source: 'architecture_structure',
          detail: signals || '',
        });
        const confidence = Number(row.overall_confidence);
        if (!Number.isNaN(confidence)) {
          const prev = evidenceByClaim.get(claimId);
          evidenceByClaim.set(claimId, prev === undefined ? confidence : Math.max(prev, confidence));
        }
      });

      decisionRows.forEach((row, idx) => {
        const claimId = extractClaimIdFromItem(row);
        if (!claimId || !activeIds.has(claimId)) return;
        const needsDecision = String(row.decision_needed || '').toLowerCase() === 'yes';
        if (!needsDecision) return;
        pushMapEntry(needsByClaim, claimId, {
          id: `decision-${claimId}-${idx}`,
          claimId,
          title: toCellText(row.recommendation || 'decision pending'),
          source: 'governance_decision',
          detail: toCellText(row.decision_status || ''),
        });
      });

      const diagrams = {};
      TRIPLE_VIEW_SPECS.forEach(spec => {
        const model = tripleDiagramModel.get(spec.id);
        if (!model) {
          diagrams[spec.id] = {
            id: spec.id,
            label: spec.label,
            type: 'unknown',
            nodes: [],
            edges: [],
          };
          return;
        }

        const aliasMap = new Map();
        activeClaims.forEach(claim => {
          aliasMap.set(claim.id, mapClaimToTripleAliases(claim, model));
        });

        const nodes = model.nodes.map(node => {
          const relatedClaims = activeClaims
            .filter(claim => (aliasMap.get(claim.id) || new Set()).has(node.id))
            .map(makeClaimRef)
            .filter(Boolean);
          const claimIds = relatedClaims.map(entry => entry.id);
          const conflicts = dedupeById(claimIds.flatMap(claimId => conflictsByClaim.get(claimId) || []));
          const needsStructure = dedupeById(claimIds.flatMap(claimId => needsByClaim.get(claimId) || []));
          const evidenceVals = claimIds
            .map(claimId => evidenceByClaim.get(claimId))
            .filter(value => typeof value === 'number' && !Number.isNaN(value));
          const evidenceStrength = evidenceVals.length
            ? Number((evidenceVals.reduce((acc, value) => acc + value, 0) / evidenceVals.length).toFixed(3))
            : null;

          return {
            ...node,
            __anno: {
              epoch: latestEpoch,
              relatedClaims,
              conflicts,
              needsStructure,
              evidenceStrength,
            },
          };
        });

        const edges = model.edges.map(edge => {
          const supportingClaims = activeClaims
            .filter(claim => claimSupportsTripleEdge(claim, edge, aliasMap))
            .map(makeClaimRef)
            .filter(Boolean);
          const supportingIds = supportingClaims.map(entry => entry.id);
          const conflicts = dedupeById(supportingIds.flatMap(claimId => conflictsByClaim.get(claimId) || []));
          let openQuestions = dedupeById(
            supportingIds.flatMap(claimId => {
              const claim = claimMap.get(claimId);
              const out = [];
              if (claim && claim.type === 'open_question') {
                out.push({
                  id: `oq-${claimId}`,
                  claimId,
                  title: `${claimId} remains open`,
                  source: 'claim_type',
                  detail: claim.subject || '',
                });
              }
              (needsByClaim.get(claimId) || []).forEach(entry => {
                out.push({
                  id: `need-as-question-${entry.id}`,
                  claimId,
                  title: entry.title,
                  source: entry.source,
                  detail: entry.detail,
                });
              });
              return out;
            })
          );
          if (!supportingClaims.length) {
            openQuestions = openQuestions.concat([{
              id: `edge-gap-${spec.id}-${edge.id}`,
              claimId: '',
              title: 'No supporting claim mapped in current filters / epoch',
              source: 'gap',
              detail: '',
            }]);
          }
          openQuestions = dedupeById(openQuestions);
          const evidenceVals = supportingIds
            .map(claimId => evidenceByClaim.get(claimId))
            .filter(value => typeof value === 'number' && !Number.isNaN(value));
          const evidenceStrength = evidenceVals.length
            ? Number((evidenceVals.reduce((acc, value) => acc + value, 0) / evidenceVals.length).toFixed(3))
            : null;

          return {
            ...edge,
            __anno: {
              epoch: latestEpoch,
              supportingClaims,
              conflicts,
              openQuestions,
              evidenceStrength,
            },
          };
        });

        diagrams[spec.id] = {
          id: spec.id,
          label: spec.label,
          type: model.type,
          nodes,
          edges,
        };
      });

      return {
        latestEpoch,
        diagrams,
      };
    }

    function refreshTripleViewModel() {
      const latestEpoch = getLatestEpoch({
        governanceAgenda,
      }) || normalizeSpace(governanceLoadedAt || '');
      tripleLatestEpoch = latestEpoch || '';
      tripleViewModel = buildViewModelForEpoch({
        claims: allClaims,
        filteredClaims: applyFilters(),
        governanceAgenda,
      }, tripleLatestEpoch);

      updateTripleEpochChip(tripleViewModel);
      console.assert(Boolean(tripleLatestEpoch), 'triple annotations: latestEpoch should exist');
      console.assert(Boolean(tripleViewModel && tripleViewModel.diagrams), 'triple annotations: view-model should exist');
      TRIPLE_VIEW_SPECS.forEach(spec => {
        const diagram = tripleViewModel && tripleViewModel.diagrams ? tripleViewModel.diagrams[spec.id] : null;
        if (!diagram) return;
        console.assert(diagram.nodes.every(node => !!node.__anno), `triple annotations: node __anno missing for ${spec.id}`);
        console.assert(diagram.edges.every(edge => !!edge.__anno), `triple annotations: edge __anno missing for ${spec.id}`);
      });
      return tripleViewModel;
    }

    function updateTripleEpochChip(vm) {
      if (!els.tripleEpochChip) return;
      const epochPolicy = governanceAgenda
        && governanceAgenda.checkpoints
        && governanceAgenda.checkpoints.architecture_epoch_applicability
        && governanceAgenda.checkpoints.architecture_epoch_applicability.policy
        ? governanceAgenda.checkpoints.architecture_epoch_applicability.policy.current_architecture_epoch
        : '';
      const token = normalizeSpace(epochPolicy || (vm && vm.latestEpoch) || '--');
      els.tripleEpochChip.textContent = `epoch: ${token}`;
      els.tripleEpochChip.title = vm && vm.latestEpoch ? `latest snapshot: ${vm.latestEpoch}` : '';
    }

    function getTripleControlButton(kind, specId) {
      return document.querySelector(`[data-triple-${kind}="${specId}"]`);
    }

    function setTripleControlState(spec, enabled, labelText) {
      ['zoom-in', 'zoom-out', 'zoom-reset'].forEach(kind => {
        const btn = getTripleControlButton(kind, spec.id);
        if (btn) btn.disabled = !enabled;
      });
      if (!spec.zoomLabelId) return;
      const label = document.getElementById(spec.zoomLabelId);
      if (!label) return;
      if (typeof labelText === 'string') {
        label.textContent = labelText;
      } else if (!enabled) {
        label.textContent = 'n/a';
      }
    }

    function setTripleZoom(spec, requestedScale, preserveCenter = true) {
      const state = tripleZoomState.get(spec.id);
      if (!state || !state.svg || !state.container) return;

      const minScale = state.minScale || 0.5;
      const maxScale = state.maxScale || 4;
      const nextScale = Math.max(minScale, Math.min(maxScale, Number(requestedScale) || 1));
      const currentScale = state.scale || 1;
      const container = state.container;

      let focusX = 0;
      let focusY = 0;
      if (preserveCenter) {
        focusX = (container.scrollLeft + container.clientWidth / 2) / currentScale;
        focusY = (container.scrollTop + container.clientHeight / 2) / currentScale;
      }

      state.scale = nextScale;
      state.svg.style.width = `${(nextScale * 100).toFixed(0)}%`;
      state.svg.style.maxWidth = 'none';
      state.svg.style.height = 'auto';

      if (spec.zoomLabelId) {
        const label = document.getElementById(spec.zoomLabelId);
        if (label) label.textContent = `${Math.round(nextScale * 100)}%`;
      }

      if (preserveCenter) {
        container.scrollLeft = Math.max(0, focusX * nextScale - container.clientWidth / 2);
        container.scrollTop = Math.max(0, focusY * nextScale - container.clientHeight / 2);
      }
    }

    function tripleNodeCounts(anno) {
      const claims = Array.isArray(anno && anno.relatedClaims) ? anno.relatedClaims.length : 0;
      const conflicts = Array.isArray(anno && anno.conflicts) ? anno.conflicts.length : 0;
      const needs = Array.isArray(anno && anno.needsStructure) ? anno.needsStructure.length : 0;
      return { claims, conflicts, needs };
    }

    function tripleEdgeCounts(anno) {
      const claims = Array.isArray(anno && anno.supportingClaims) ? anno.supportingClaims.length : 0;
      const conflicts = Array.isArray(anno && anno.conflicts) ? anno.conflicts.length : 0;
      const needs = Array.isArray(anno && anno.openQuestions) ? anno.openQuestions.length : 0;
      return { claims, conflicts, needs };
    }

    function createSvgEl(tag, attrs) {
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      Object.entries(attrs || {}).forEach(([key, value]) => {
        if (value === undefined || value === null) return;
        el.setAttribute(key, String(value));
      });
      return el;
    }

    function clearTripleTooltipTimer() {
      if (!tripleTooltipHideTimer) return;
      clearTimeout(tripleTooltipHideTimer);
      tripleTooltipHideTimer = null;
    }

    function hideTripleTooltip() {
      clearTripleTooltipTimer();
      if (!els.tripleTooltip) return;
      els.tripleTooltip.style.display = 'none';
      els.tripleTooltip.innerHTML = '';
    }

    function scheduleHideTripleTooltip() {
      clearTripleTooltipTimer();
      tripleTooltipHideTimer = setTimeout(() => {
        hideTripleTooltip();
      }, 120);
    }

    function positionTripleTooltip(event) {
      if (!els.tripleTooltip || els.tripleTooltip.style.display === 'none') return;
      const pad = 12;
      const maxX = window.innerWidth - els.tripleTooltip.offsetWidth - pad;
      const maxY = window.innerHeight - els.tripleTooltip.offsetHeight - pad;
      const x = Math.max(pad, Math.min(event.clientX + 14, maxX));
      const y = Math.max(pad, Math.min(event.clientY + 14, maxY));
      els.tripleTooltip.style.left = `${x}px`;
      els.tripleTooltip.style.top = `${y}px`;
    }

    function sliceTopItems(items, limit) {
      return Array.isArray(items) ? items.slice(0, limit) : [];
    }

    function tooltipListHtml(items, emptyLabel) {
      if (!items || !items.length) return `<div class="meta">${escapeHtml(emptyLabel)}</div>`;
      return `<ul>${items.map(item => `<li>${escapeHtml(item.title || item.id || String(item))}</li>`).join('')}</ul>`;
    }

    function renderTripleTooltip(payload, event) {
      if (!payload || !els.tripleTooltip) return;
      const anno = payload.item && payload.item.__anno ? payload.item.__anno : {};
      const counts = payload.kind === 'edge' ? tripleEdgeCounts(anno) : tripleNodeCounts(anno);
      const epoch = normalizeSpace(anno.epoch || tripleLatestEpoch || '');
      const claims = payload.kind === 'edge'
        ? sliceTopItems(anno.supportingClaims || [], 5)
        : sliceTopItems(anno.relatedClaims || [], 5);
      const conflicts = sliceTopItems(anno.conflicts || [], 5);
      const needs = payload.kind === 'edge'
        ? sliceTopItems(anno.openQuestions || [], 5)
        : sliceTopItems(anno.needsStructure || [], 5);

      const title = payload.kind === 'edge'
        ? `${payload.item.from} -> ${payload.item.to}${payload.item.label ? ` (${payload.item.label})` : ''}`
        : `${payload.item.label || payload.item.id}`;
      const kindLabel = payload.kind === 'edge' ? 'connection' : 'node';
      const evidenceLabel = typeof anno.evidenceStrength === 'number'
        ? `evidence ${anno.evidenceStrength.toFixed(3)}`
        : 'evidence n/a';

      els.tripleTooltip.innerHTML = `
        <div class="title">${escapeHtml(title)}</div>
        <div class="meta">${escapeHtml(kindLabel)} | epoch ${escapeHtml(epoch || 'n/a')}</div>
        <div class="meta">claims ${counts.claims}  conflicts ${counts.conflicts}  needs ${counts.needs}  ${escapeHtml(evidenceLabel)}</div>
        <div class="meta"><strong>Top claims</strong></div>
        ${tooltipListHtml(claims, 'No mapped claims in latest epoch view.')}
        <div class="meta"><strong>Top conflicts</strong></div>
        ${tooltipListHtml(conflicts, 'No mapped conflicts.')}
        <div class="meta"><strong>Top needs / gaps</strong></div>
        ${tooltipListHtml(needs, 'No mapped needs.')}
        <div class="actions">
          <button type="button" data-triple-view-all="1">View all</button>
        </div>
      `;
      const viewAll = els.tripleTooltip.querySelector('button[data-triple-view-all="1"]');
      if (viewAll) {
        viewAll.addEventListener('click', (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          openTripleInspector(payload);
          hideTripleTooltip();
        });
      }

      els.tripleTooltip.style.display = 'block';
      positionTripleTooltip(event);
      els.tripleTooltip.addEventListener('mouseenter', clearTripleTooltipTimer, { once: true });
      els.tripleTooltip.addEventListener('mouseleave', scheduleHideTripleTooltip, { once: true });
    }

    function renderTripleInspectorList(items, mode) {
      const list = Array.isArray(items) ? items : [];
      if (!list.length) {
        return '<div class="inspector-empty">No items in this tab for the latest epoch view.</div>';
      }
      const html = list.map((entry, idx) => {
        const stableId = normalizeSpace(entry.id || entry.claimId || `item-${idx}`).replace(/[^A-Za-z0-9_\-:.]/g, '-');
        const claimId = normalizeClaimId(entry.claimId || entry.id || '');
        let titleHtml = escapeHtml(entry.title || entry.id || String(entry));
        if (mode === 'claims') {
          if (claimId && claimMap.has(claimId)) {
            titleHtml = `<a href="#" data-inspector-claim="${escapeHtml(claimId)}"><code>${escapeHtml(claimId)}</code>  ${escapeHtml(entry.title || claimId)}</a>`;
          } else if (claimId) {
            titleHtml = `<a href="#triple-claim-${escapeHtml(claimId)}"><code>${escapeHtml(claimId)}</code>  ${escapeHtml(entry.title || claimId)}</a>`;
          }
        } else if (claimId && claimMap.has(claimId)) {
          titleHtml = `<a href="#" data-inspector-claim="${escapeHtml(claimId)}"><code>${escapeHtml(claimId)}</code>  ${escapeHtml(entry.title || claimId)}</a>`;
        } else if (claimId) {
          titleHtml = `<a href="#triple-claim-${escapeHtml(claimId)}"><code>${escapeHtml(claimId)}</code>  ${escapeHtml(entry.title || claimId)}</a>`;
        }
        const detail = normalizeSpace(entry.detail || '');
        const source = normalizeSpace(entry.source || '');
        const href = normalizeSpace(entry.href || '');
        const hrefHtml = href ? `<div class="meta"><a href="${escapeHtml(href)}" target="_blank" rel="noopener">source</a></div>` : '';
        return `
          <li class="inspector-item" id="triple-${mode}-${stableId}">
            <div>${titleHtml}</div>
            ${detail ? `<div class="meta">${escapeHtml(detail)}</div>` : ''}
            ${source ? `<div class="meta">source: ${escapeHtml(source)}</div>` : ''}
            ${hrefHtml}
          </li>
        `;
      }).join('');
      return `<ul class="inspector-list">${html}</ul>`;
    }

    function closeTripleInspector() {
      if (!els.detailContent) return;
      const inspector = els.detailContent.querySelector('.triple-inspector');
      if (!inspector) return;
      if (selectedId && claimMap.has(selectedId)) {
        selectClaim(selectedId);
        return;
      }
      els.detailContent.innerHTML = '<div class="meta">Select a claim to see details.</div>';
    }

    function wireTripleInspectorTabs() {
      if (!els.detailContent) return;
      const tabs = Array.from(els.detailContent.querySelectorAll('[data-inspector-tab]'));
      const panes = Array.from(els.detailContent.querySelectorAll('[data-inspector-pane]'));
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const tabId = tab.getAttribute('data-inspector-tab');
          tabs.forEach(other => other.classList.toggle('active', other === tab));
          panes.forEach(pane => pane.classList.toggle('active', pane.getAttribute('data-inspector-pane') === tabId));
        });
      });
      const closeBtn = els.detailContent.querySelector('.inspector-close');
      if (closeBtn) closeBtn.addEventListener('click', () => closeTripleInspector());
      els.detailContent.querySelectorAll('a[data-inspector-claim]').forEach(link => {
        link.addEventListener('click', (event) => {
          event.preventDefault();
          const id = link.getAttribute('data-inspector-claim');
          if (id) selectClaim(id);
        });
      });
    }

    function openTripleInspector(payload) {
      if (!payload || !payload.item || !payload.item.__anno || !els.detailContent) return;
      const anno = payload.item.__anno;
      const counts = payload.kind === 'edge' ? tripleEdgeCounts(anno) : tripleNodeCounts(anno);
      const claims = payload.kind === 'edge' ? (anno.supportingClaims || []) : (anno.relatedClaims || []);
      const conflicts = anno.conflicts || [];
      const needs = payload.kind === 'edge' ? (anno.openQuestions || []) : (anno.needsStructure || []);
      const epoch = normalizeSpace(anno.epoch || tripleLatestEpoch || '');
      const title = payload.kind === 'edge'
        ? `${payload.item.from} -> ${payload.item.to}${payload.item.label ? ` (${payload.item.label})` : ''}`
        : (payload.item.label || payload.item.id);

      const tabs = [
        { id: 'claims', label: `Claims (${claims.length})`, items: claims, mode: 'claims', required: true },
        { id: 'conflicts', label: `Conflicts (${conflicts.length})`, items: conflicts, mode: 'conflicts', required: conflicts.length > 0 },
        { id: 'needs', label: `Needs / Gaps (${needs.length})`, items: needs, mode: 'needs', required: needs.length > 0 },
      ].filter(tab => tab.required);

      const firstTab = tabs[0] ? tabs[0].id : 'claims';
      const tabsHtml = tabs.map(tab => `
        <button type="button" data-inspector-tab="${tab.id}" class="${tab.id === firstTab ? 'active' : ''}">${escapeHtml(tab.label)}</button>
      `).join('');
      const panesHtml = tabs.map(tab => `
        <div class="inspector-pane ${tab.id === firstTab ? 'active' : ''}" data-inspector-pane="${tab.id}">
          ${renderTripleInspectorList(tab.items, tab.mode)}
        </div>
      `).join('');
      const evidenceLabel = typeof anno.evidenceStrength === 'number'
        ? anno.evidenceStrength.toFixed(3)
        : 'n/a';

      els.detailContent.innerHTML = `
        <div class="triple-inspector">
          <button type="button" class="inspector-close">Close Inspector</button>
          <h2>Triple Inspector</h2>
          <div class="meta">${escapeHtml(payload.specLabel || payload.specId)}  ${escapeHtml(payload.kind)}  epoch ${escapeHtml(epoch || 'n/a')}</div>
          <div><strong>${escapeHtml(title)}</strong></div>
          <div class="meta">claims ${counts.claims}  conflicts ${counts.conflicts}  needs ${counts.needs}  evidence ${escapeHtml(evidenceLabel)}</div>
          <div class="inspector-tabs">${tabsHtml}</div>
          ${panesHtml}
        </div>
      `;
      wireTripleInspectorTabs();
      const detailPanel = document.getElementById('detailPanel');
      if (detailPanel) detailPanel.scrollTop = 0;
    }

    function resolveTriplePayloadFromElement(target) {
      if (!target || typeof target.closest !== 'function') return null;
      const el = target.closest('[data-triple-key]');
      if (!el) return null;
      const key = el.getAttribute('data-triple-key');
      if (!key) return null;
      return tripleInteractiveIndex.get(key) || null;
    }

    function onTripleTargetEnter(event) {
      const payload = resolveTriplePayloadFromElement(event.target);
      if (!payload) return;
      clearTripleTooltipTimer();
      renderTripleTooltip(payload, event);
    }

    function onTripleTargetMove(event) {
      if (!els.tripleTooltip || els.tripleTooltip.style.display === 'none') return;
      positionTripleTooltip(event);
    }

    function onTripleTargetLeave() {
      scheduleHideTripleTooltip();
    }

    function onTripleTargetClick(event) {
      const payload = resolveTriplePayloadFromElement(event.target);
      if (!payload) return;
      event.preventDefault();
      openTripleInspector(payload);
    }

    function onTripleTargetKeydown(event) {
      if (event.key === 'Escape') {
        hideTripleTooltip();
        closeTripleInspector();
        return;
      }
      if (event.key !== 'Enter' && event.key !== ' ') return;
      const payload = resolveTriplePayloadFromElement(event.target);
      if (!payload) return;
      event.preventDefault();
      openTripleInspector(payload);
    }

    function registerTripleTarget(target, payload) {
      if (!target || !payload) return;
      const key = `${payload.specId}:${payload.kind}:${payload.item.id}`;
      tripleInteractiveIndex.set(key, payload);
      target.setAttribute('data-triple-interactive', '1');
      target.setAttribute('data-triple-key', key);
      target.classList.add('triple-target');
      if (!target.hasAttribute('tabindex')) target.setAttribute('tabindex', '0');
      target.setAttribute('role', 'button');
      if (target.dataset.tripleBound === '1') return;
      target.dataset.tripleBound = '1';
      target.addEventListener('mouseenter', onTripleTargetEnter);
      target.addEventListener('mousemove', onTripleTargetMove);
      target.addEventListener('mouseleave', onTripleTargetLeave);
      target.addEventListener('click', onTripleTargetClick);
      target.addEventListener('keydown', onTripleTargetKeydown);
    }

    function clearTripleInteractiveForSpec(specId) {
      const prefix = `${specId}:`;
      Array.from(tripleInteractiveIndex.keys()).forEach(key => {
        if (key.startsWith(prefix)) tripleInteractiveIndex.delete(key);
      });
    }

    function clearTripleSvgAnnotations(svg) {
      if (!svg) return;
      svg.querySelectorAll('.triple-node-badges').forEach(node => node.remove());
      svg.querySelectorAll('.triple-edge-marker').forEach(node => node.remove());
      svg.querySelectorAll('.triple-edge-conflict').forEach(node => node.classList.remove('triple-edge-conflict'));
      svg.querySelectorAll('.triple-edge-open').forEach(node => node.classList.remove('triple-edge-open'));
      svg.querySelectorAll('[data-triple-key]').forEach(node => node.removeAttribute('data-triple-key'));
      svg.querySelectorAll('[data-triple-interactive]').forEach(node => node.removeAttribute('data-triple-interactive'));
    }

    function addTripleNodeBadges(nodeElement, counts, isSequence) {
      if (!nodeElement) return;
      const claims = Number(counts.claims || 0);
      const conflicts = Number(counts.conflicts || 0);
      const needs = Number(counts.needs || 0);
      if (claims <= 0 && conflicts <= 0 && needs <= 0) return;

      const badges = createSvgEl('g', { class: 'triple-node-badges' });
      const add = (x, y, count, cls, label) => {
        if (count <= 0) return;
        const circle = createSvgEl('circle', { cx: x, cy: y, r: 6, class: `triple-node-badge ${cls}` });
        const text = createSvgEl('text', { x, y: y + 0.3, class: 'triple-node-badge-text' });
        text.textContent = count > 99 ? '99+' : String(count);
        const title = createSvgEl('title');
        title.textContent = `${label}: ${count}`;
        circle.appendChild(title);
        badges.appendChild(circle);
        badges.appendChild(text);
      };

      if (isSequence) {
        const x = Number(nodeElement.getAttribute('x') || 0);
        const y = Number(nodeElement.getAttribute('y') || 0);
        const w = Number(nodeElement.getAttribute('width') || 0);
        add(x + w - 8, y + 8, claims, 'claims', 'claims');
        add(x + w - 22, y + 8, conflicts, 'conflicts', 'conflicts');
        add(x + w - 36, y + 8, needs, 'needs', 'needs');
        nodeElement.parentNode.appendChild(badges);
        return;
      }

      const rect = nodeElement.querySelector('rect');
      if (!rect) return;
      const x = Number(rect.getAttribute('x') || 0);
      const y = Number(rect.getAttribute('y') || 0);
      const w = Number(rect.getAttribute('width') || 0);
      add(x + w - 8, y + 8, claims, 'claims', 'claims');
      add(x + w - 22, y + 8, conflicts, 'conflicts', 'conflicts');
      add(x + w - 36, y + 8, needs, 'needs', 'needs');
      nodeElement.appendChild(badges);
    }

    function addTripleEdgeMarker(svg, target, counts, isSequence) {
      if (!svg || !target) return;
      const conflicts = Number(counts.conflicts || 0);
      const needs = Number(counts.needs || 0);
      if (conflicts <= 0 && needs <= 0) return;

      let x = 0;
      let y = 0;
      if (isSequence) {
        const x1 = Number(target.getAttribute('x1') || 0);
        const x2 = Number(target.getAttribute('x2') || 0);
        const y1 = Number(target.getAttribute('y1') || 0);
        x = (x1 + x2) / 2;
        y = y1 - 8;
      } else {
        const len = typeof target.getTotalLength === 'function' ? target.getTotalLength() : 0;
        if (!len) return;
        const pt = target.getPointAtLength(len / 2);
        x = pt.x;
        y = pt.y - 9;
      }

      const marker = createSvgEl('g', { class: 'triple-edge-marker' });
      if (conflicts > 0) {
        marker.classList.add('conflicts');
        const c = createSvgEl('circle', { cx: x - 8, cy: y, r: 6 });
        const t = createSvgEl('text', { x: x - 8, y: y + 0.3 });
        t.textContent = conflicts > 99 ? '99+' : String(conflicts);
        marker.appendChild(c);
        marker.appendChild(t);
      }
      if (needs > 0) {
        marker.classList.add('questions');
        const c = createSvgEl('circle', { cx: x + 8, cy: y, r: 6 });
        const t = createSvgEl('text', { x: x + 8, y: y + 0.3 });
        t.textContent = needs > 99 ? '99+' : String(needs);
        marker.appendChild(c);
        marker.appendChild(t);
      }
      svg.appendChild(marker);
    }

    function annotateFlowchartTriple(spec, svg, vmSpec) {
      const nodesById = new Map();
      svg.querySelectorAll('g.node[id^="flowchart-"]').forEach(nodeEl => {
        const id = nodeEl.getAttribute('id') || '';
        const match = id.match(/^flowchart-([A-Za-z0-9_]+)-\d+$/);
        if (!match) return;
        const alias = match[1];
        if (!nodesById.has(alias)) nodesById.set(alias, []);
        nodesById.get(alias).push(nodeEl);
      });

      vmSpec.nodes.forEach(node => {
        const targets = nodesById.get(node.id) || [];
        targets.forEach(target => {
          addTripleNodeBadges(target, tripleNodeCounts(node.__anno), false);
          registerTripleTarget(target, {
            specId: spec.id,
            specLabel: spec.label,
            kind: 'node',
            item: node,
          });
        });
      });

      const edgeElements = new Map();
      svg.querySelectorAll('path[id^="L_"]').forEach(path => {
        const id = path.getAttribute('id') || '';
        const match = id.match(/^L_([A-Za-z0-9_]+)_([A-Za-z0-9_]+)_\d+$/);
        if (!match) return;
        const from = match[1];
        const to = match[2];
        const labelEl = svg.querySelector(`g.label[data-id="${escapeSelectorValue(id)}"] span.edgeLabel p`);
        const label = normalizeEdgeLabel(labelEl ? labelEl.textContent : '');
        const key = `${from}->${to}|${label}`;
        if (!edgeElements.has(key)) edgeElements.set(key, []);
        edgeElements.get(key).push(path);
      });

      vmSpec.edges.forEach(edge => {
        const key = `${edge.from}->${edge.to}|${normalizeEdgeLabel(edge.label || '')}`;
        let targets = edgeElements.get(key) || [];
        if (!targets.length) {
          const fallbackKey = `${edge.from}->${edge.to}|`;
          targets = edgeElements.get(fallbackKey) || [];
        }
        const target = targets.shift();
        if (!target) return;

        const counts = tripleEdgeCounts(edge.__anno);
        if (counts.conflicts > 0) target.classList.add('triple-edge-conflict');
        if (counts.needs > 0) target.classList.add('triple-edge-open');
        addTripleEdgeMarker(svg, target, counts, false);
        registerTripleTarget(target, {
          specId: spec.id,
          specLabel: spec.label,
          kind: 'edge',
          item: edge,
        });
      });
    }

    function annotateSequenceTriple(spec, svg, vmSpec) {
      const topActors = new Map();
      svg.querySelectorAll('rect.actor.actor-top[name]').forEach(rect => {
        const alias = rect.getAttribute('name');
        if (!alias) return;
        topActors.set(alias, rect);
      });

      vmSpec.nodes.forEach(node => {
        const actor = topActors.get(node.id);
        if (!actor) return;
        addTripleNodeBadges(actor, tripleNodeCounts(node.__anno), true);
        registerTripleTarget(actor, {
          specId: spec.id,
          specLabel: spec.label,
          kind: 'node',
          item: node,
        });
      });

      const lines = Array.from(svg.querySelectorAll('line.messageLine0, line.messageLine1'));
      const edgeCount = Math.min(lines.length, vmSpec.edges.length);
      for (let idx = 0; idx < edgeCount; idx++) {
        const edge = vmSpec.edges[idx];
        const line = lines[idx];
        if (!line || !edge) continue;
        const counts = tripleEdgeCounts(edge.__anno);
        if (counts.conflicts > 0) line.classList.add('triple-edge-conflict');
        if (counts.needs > 0) line.classList.add('triple-edge-open');
        addTripleEdgeMarker(svg, line, counts, true);
        registerTripleTarget(line, {
          specId: spec.id,
          specLabel: spec.label,
          kind: 'edge',
          item: edge,
        });
      }
    }

    function applyTripleAnnotations(spec, container) {
      if (!container) return;
      const svg = container.querySelector('svg');
      clearTripleInteractiveForSpec(spec.id);
      if (!svg) return;
      clearTripleSvgAnnotations(svg);
      const vmSpec = tripleViewModel && tripleViewModel.diagrams ? tripleViewModel.diagrams[spec.id] : null;
      if (!vmSpec) return;
      if (vmSpec.type === 'sequence') {
        annotateSequenceTriple(spec, svg, vmSpec);
      } else {
        annotateFlowchartTriple(spec, svg, vmSpec);
      }
    }

    function applyTripleAnnotationsAll() {
      TRIPLE_VIEW_SPECS.forEach(spec => {
        const container = document.getElementById(spec.bodyId);
        if (!container) return;
        applyTripleAnnotations(spec, container);
      });
    }

    function refreshTripleAnnotationsFromCurrentFilters() {
      if (!tripleViewLoaded) return;
      refreshTripleViewModel();
      applyTripleAnnotationsAll();
    }

    function attachTriplePanHandlers(spec, container) {
      if (!container || container.dataset.triplePanBound === '1') return;
      container.dataset.triplePanBound = '1';

      let dragging = false;
      let startX = 0;
      let startY = 0;
      let startLeft = 0;
      let startTop = 0;

      container.addEventListener('mousedown', (event) => {
        if (event.button !== 0) return;
        if (event.target && event.target.closest('[data-triple-interactive="1"],button,a,input,textarea,select')) return;
        const state = tripleZoomState.get(spec.id);
        if (!state || !state.svg) return;
        dragging = true;
        startX = event.clientX;
        startY = event.clientY;
        startLeft = container.scrollLeft;
        startTop = container.scrollTop;
        container.classList.add('dragging');
        event.preventDefault();
      });

      window.addEventListener('mousemove', (event) => {
        if (!dragging) return;
        container.scrollLeft = startLeft - (event.clientX - startX);
        container.scrollTop = startTop - (event.clientY - startY);
      });

      window.addEventListener('mouseup', () => {
        if (!dragging) return;
        dragging = false;
        container.classList.remove('dragging');
      });

      container.addEventListener('wheel', (event) => {
        if (!(event.ctrlKey || event.metaKey)) return;
        const state = tripleZoomState.get(spec.id);
        if (!state || !state.svg) return;
        event.preventDefault();
        const direction = event.deltaY < 0 ? 1 : -1;
        setTripleZoom(spec, (state.scale || 1) + direction * (state.step || 0.1), true);
      }, { passive: false });
    }

    function bindTripleControls() {
      TRIPLE_VIEW_SPECS.forEach(spec => {
        const zoomInBtn = getTripleControlButton('zoom-in', spec.id);
        const zoomOutBtn = getTripleControlButton('zoom-out', spec.id);
        const zoomResetBtn = getTripleControlButton('zoom-reset', spec.id);

        if (zoomInBtn && !zoomInBtn.dataset.bound) {
          zoomInBtn.dataset.bound = '1';
          zoomInBtn.addEventListener('click', () => {
            const state = tripleZoomState.get(spec.id);
            if (!state) return;
            setTripleZoom(spec, (state.scale || 1) + (state.step || 0.1), true);
          });
        }
        if (zoomOutBtn && !zoomOutBtn.dataset.bound) {
          zoomOutBtn.dataset.bound = '1';
          zoomOutBtn.addEventListener('click', () => {
            const state = tripleZoomState.get(spec.id);
            if (!state) return;
            setTripleZoom(spec, (state.scale || 1) - (state.step || 0.1), true);
          });
        }
        if (zoomResetBtn && !zoomResetBtn.dataset.bound) {
          zoomResetBtn.dataset.bound = '1';
          zoomResetBtn.addEventListener('click', () => {
            const state = tripleZoomState.get(spec.id);
            if (!state || !state.container) return;
            setTripleZoom(spec, 1, false);
            state.container.scrollLeft = 0;
            state.container.scrollTop = 0;
          });
        }
        setTripleControlState(spec, false, 'n/a');
      });
    }

    function configureTripleSvg(spec, container) {
      if (!container) return;
      const svg = container.querySelector('svg');
      if (!svg) {
        container.classList.remove('zoomable', 'dragging');
        tripleZoomState.delete(spec.id);
        clearTripleInteractiveForSpec(spec.id);
        setTripleControlState(spec, false, 'n/a');
        return;
      }

      const previous = tripleZoomState.get(spec.id);
      const initialScale = previous && typeof previous.scale === 'number' ? previous.scale : 1;
      tripleZoomState.set(spec.id, {
        container,
        svg,
        scale: initialScale,
        minScale: 0.5,
        maxScale: 4,
        step: 0.1,
      });
      container.classList.add('zoomable');
      attachTriplePanHandlers(spec, container);
      setTripleControlState(spec, true);
      setTripleZoom(spec, initialScale, false);
    }

    function renderTripleSourceFallback(spec, container, mmdText, reason) {
      if (!container) return;
      const note = document.createElement('div');
      note.className = 'meta';
      note.textContent = `${spec.label}: ${reason}. Showing Mermaid source instead.`;
      const pre = document.createElement('pre');
      pre.className = 'triple-code';
      pre.textContent = mmdText;
      container.innerHTML = '';
      container.appendChild(note);
      container.appendChild(pre);
      container.classList.remove('zoomable', 'dragging');
      tripleZoomState.delete(spec.id);
      clearTripleInteractiveForSpec(spec.id);
      setTripleControlState(spec, false, 'src');
    }

    function renderTripleUnavailable(spec, container, errorText) {
      if (!container) return;
      container.innerHTML = '';
      const note = document.createElement('div');
      note.className = 'meta';
      note.textContent = `${spec.label}: unable to load SVG or Mermaid source (${errorText}).`;
      container.appendChild(note);
      container.classList.remove('zoomable', 'dragging');
      tripleZoomState.delete(spec.id);
      clearTripleInteractiveForSpec(spec.id);
      setTripleControlState(spec, false, 'err');
    }

    async function loadTripleDiagram(spec) {
      const container = document.getElementById(spec.bodyId);
      if (!container) return { id: spec.id, mode: 'missing-container' };
      container.innerHTML = '<div class="meta">Loading diagram...</div>';
      setTripleControlState(spec, false, '...');

      const svgUrl = new URL(spec.svgPath, window.location.href).toString();
      const mmdUrl = new URL(spec.mmdPath, window.location.href).toString();
      const [svgResult, mmdResult] = await Promise.allSettled([
        fetchText(svgUrl),
        fetchText(mmdUrl),
      ]);

      let mmdText = '';
      if (mmdResult.status === 'fulfilled') {
        mmdText = String(mmdResult.value || '');
        try {
          const parsedModel = parseTripleDiagramModel(spec, mmdText);
          if (parsedModel) tripleDiagramModel.set(spec.id, parsedModel);
          else tripleDiagramModel.delete(spec.id);
        } catch (_) {
          tripleDiagramModel.delete(spec.id);
        }
      } else {
        tripleDiagramModel.delete(spec.id);
      }

      if (svgResult.status === 'fulfilled' && String(svgResult.value || '').includes('<svg')) {
        container.innerHTML = svgResult.value;
        configureTripleSvg(spec, container);
        return { id: spec.id, mode: 'svg' };
      }

      if (mmdText) {
        renderTripleSourceFallback(spec, container, mmdText, 'SVG not available');
        return { id: spec.id, mode: 'mmd' };
      }

      const errText = svgResult.status === 'rejected'
        ? String(svgResult.reason || 'svg load failed')
        : (mmdResult.status === 'rejected' ? String(mmdResult.reason || 'mmd load failed') : 'unknown');
      renderTripleUnavailable(spec, container, errText);
      return { id: spec.id, mode: 'error' };
    }

    async function renderTripleView(forceReload) {
      if (!els.tripleViewWrap || !els.tripleStatus) return;
      if (tripleViewLoading) return;
      if (tripleViewLoaded && !forceReload) {
        const vm = refreshTripleViewModel();
        applyTripleAnnotationsAll();
        els.tripleStatus.textContent = vm && vm.latestEpoch
          ? `Triple-view diagrams loaded  epoch ${vm.latestEpoch}.`
          : 'Triple-view diagrams loaded.';
        return;
      }

      tripleViewLoading = true;
      els.tripleStatus.textContent = 'Loading triple-view diagrams...';
      const results = await Promise.all(TRIPLE_VIEW_SPECS.map(loadTripleDiagram));
      const svgCount = results.filter(r => r.mode === 'svg').length;
      const mmdCount = results.filter(r => r.mode === 'mmd').length;
      const errorCount = results.filter(r => r.mode === 'error' || r.mode === 'missing-container').length;
      const vm = refreshTripleViewModel();
      applyTripleAnnotationsAll();
      const loadedAt = new Date().toLocaleTimeString();
      els.tripleStatus.textContent =
        `Loaded ${svgCount}/${TRIPLE_VIEW_SPECS.length} SVGs` +
        (mmdCount ? `, ${mmdCount} source fallbacks` : '') +
        (errorCount ? `, ${errorCount} errors` : '') +
        ` at ${loadedAt}` +
        (vm && vm.latestEpoch ? `  epoch ${vm.latestEpoch}` : '') +
        '.';
      tripleViewLoaded = true;
      tripleViewLoading = false;
    }

    function readFilterState() {
      return {
        search: els.search.value,
        type: els.typeFilter.value,
        status: els.statusFilter.value,
        subject: els.subjectFilter.value,
      };
    }

    function restoreFilterState(state) {
      if (!state) return;
      if (typeof state.search === 'string') els.search.value = state.search;
      if (state.type && Array.from(els.typeFilter.options).some(o => o.value === state.type)) {
        els.typeFilter.value = state.type;
      }
      if (state.status && Array.from(els.statusFilter.options).some(o => o.value === state.status)) {
        els.statusFilter.value = state.status;
      }
      if (typeof state.subject === 'string') els.subjectFilter.value = state.subject;
    }

    function renderConflictFilePicker() {
      if (!els.conflictFileList) return;
      els.conflictFileList.innerHTML = '';
      const files = (conflictFiles || []).slice().sort();
      if (!files.length) {
        const empty = document.createElement('div');
        empty.className = 'meta';
        empty.textContent = 'No conflicts found.';
        els.conflictFileList.appendChild(empty);
        return;
      }
      files.forEach(file => {
        const row = document.createElement('label');
        row.className = 'picker-item';
        const box = document.createElement('input');
        box.type = 'checkbox';
        box.value = file;
        box.checked = conflictSelectedFiles.has(file);
        box.addEventListener('change', () => {
          if (box.checked) conflictSelectedFiles.add(file);
          else conflictSelectedFiles.delete(file);
          renderSelectedSummary();
        });
        const text = document.createElement('span');
        text.textContent = file;
        row.appendChild(box);
        row.appendChild(text);
        els.conflictFileList.appendChild(row);
      });
    }

    function renderChips(container, items, clickable) {
      if (!container) return;
      container.innerHTML = '';
      if (!items.length) {
        const empty = document.createElement('span');
        empty.className = 'chip empty';
        empty.textContent = 'None';
        container.appendChild(empty);
        return;
      }
      items.forEach(item => {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.textContent = item;
        if (clickable) {
          chip.addEventListener('click', () => selectClaim(item));
        }
        container.appendChild(chip);
      });
    }

    function renderSelectedSummary() {
      renderChips(els.selectedThought, Array.from(thoughtSelected).sort(), true);
      renderChips(els.selectedConflict, Array.from(conflictSelectedClaims).sort(), true);
      renderChips(els.selectedConflictFiles, Array.from(conflictSelectedFiles).sort(), false);
    }

    function getFocusMode() {
      const checked = document.querySelector('input[name="graphFocus"]:checked');
      return checked ? checked.value : 'anchor';
    }

    function getWorksetScope() {
      const checked = document.querySelector('input[name="worksetScope"]:checked');
      return checked ? checked.value : 'union';
    }

    function getWorksetIds() {
      const ids = new Set();
      if (els.worksetThought && els.worksetThought.checked) {
        thoughtSelected.forEach(id => ids.add(id));
      }
      if (els.worksetConflict && els.worksetConflict.checked) {
        conflictSelectedClaims.forEach(id => ids.add(id));
      }
      return Array.from(ids);
    }

    function updateWorksetUI() {
      const active = getFocusMode() === 'workset';
      els.worksetGroups.forEach(group => {
        if (active) group.classList.remove('inactive');
        else group.classList.add('inactive');
      });
    }

    function renderPickers() {
      renderConflictFilePicker();
      renderSelectedSummary();
    }

    function statCard(text) {
      const div = document.createElement('div');
      div.className = 'stat-card';
      div.textContent = text;
      return div;
    }

    function buildStats() {
      const byType = {};
      const byStatus = {};
      allClaims.forEach(c => {
        byType[c.type] = (byType[c.type] || 0) + 1;
        byStatus[c.status] = (byStatus[c.status] || 0) + 1;
      });
      els.stats.innerHTML = '';
      const total = allClaims.length;
      els.stats.appendChild(statCard(`Total claims: ${total}`));
      Object.keys(byType).sort((a,b) => typeOrder.indexOf(a) - typeOrder.indexOf(b)).forEach(t => {
        els.stats.appendChild(statCard(`${t}: ${byType[t]}`));
      });
      Object.keys(byStatus).sort().forEach(s => {
        els.stats.appendChild(statCard(`status ${s}: ${byStatus[s]}`));
      });
    }

    function populateFilters() {
      const types = Array.from(new Set(allClaims.map(c => c.type))).sort((a,b) => typeOrder.indexOf(a) - typeOrder.indexOf(b));
      const statuses = Array.from(new Set(allClaims.map(c => c.status))).sort();
      const subjects = Array.from(new Set(allClaims.map(c => c.subject).filter(Boolean))).sort();

      els.typeFilter.innerHTML = '<option value="">All types</option>' + types.map(t => `<option value="${t}">${t}</option>`).join('');
      els.statusFilter.innerHTML = '<option value="">All statuses</option>' + statuses.map(s => `<option value="${s}">${s}</option>`).join('');
      els.subjectList.innerHTML = subjects.map(s => `<option value="${s}"></option>`).join('');
    }

    function applyFilters() {
      const term = (els.search.value || '').trim().toLowerCase();
      const type = els.typeFilter.value;
      const status = els.statusFilter.value;
      const subjectTerm = (els.subjectFilter.value || '').trim().toLowerCase();

      return allClaims.filter(c => {
        if (type && c.type !== type) return false;
        if (status && c.status !== status) return false;
        if (subjectTerm && !c.subject.toLowerCase().includes(subjectTerm)) return false;
        if (term) {
          const hay = `${c.id} ${c.subject} ${c.type} ${c.status}`.toLowerCase();
          if (!hay.includes(term)) return false;
        }
        return true;
      });
    }

    function dependsTitle(depends) {
      if (!depends || depends.length === 0) return '-';
      return depends.join(', ');
    }

    let selectedId = null;
    let currentView = 'list';

    function renderTable() {
      const filtered = applyFilters();
      els.claimsTable.innerHTML = '';
      filtered.forEach(c => {
        const tr = document.createElement('tr');
        tr.dataset.id = c.id;
        if (selectedId === c.id) tr.classList.add('selected');
        const conflicts = conflictsMap[c.id] || [];
        tr.innerHTML = `
          <td class="status-${c.status}"><span class="badge">${c.id}</span></td>
          <td><span class="badge type-${c.type}">${c.type}</span></td>
          <td>${c.status}</td>
          <td>${c.subject || '-'}</td>
          <td title="${dependsTitle(c.depends_on)}">${c.depends_on.length || '-'}</td>
          <td>${conflicts.length ? `<span class="conflict">${conflicts.length} conflict</span>` : '-'}</td>
          <td><input type="checkbox" data-role="thought" /></td>
          <td><input type="checkbox" data-role="conflict" /></td>
        `;
        tr.addEventListener('click', () => selectClaim(c.id));
        const thoughtBox = tr.querySelector('input[data-role="thought"]');
        const conflictBox = tr.querySelector('input[data-role="conflict"]');
        if (thoughtBox) {
          thoughtBox.checked = thoughtSelected.has(c.id);
          thoughtBox.addEventListener('click', (e) => e.stopPropagation());
          thoughtBox.addEventListener('change', () => {
            if (thoughtBox.checked) thoughtSelected.add(c.id);
            else thoughtSelected.delete(c.id);
            renderSelectedSummary();
            renderGraph();
          });
        }
        if (conflictBox) {
          conflictBox.checked = conflictSelectedClaims.has(c.id);
          conflictBox.addEventListener('click', (e) => e.stopPropagation());
          conflictBox.addEventListener('change', () => {
            if (conflictBox.checked) conflictSelectedClaims.add(c.id);
            else conflictSelectedClaims.delete(c.id);
            renderSelectedSummary();
            renderGraph();
          });
        }
        els.claimsTable.appendChild(tr);
      });
    }

    function syncRowCheckboxes(id) {
      const row = els.claimsTable.querySelector(`tr[data-id="${id}"]`);
      if (!row) return;
      const thoughtBox = row.querySelector('input[data-role="thought"]');
      const conflictBox = row.querySelector('input[data-role="conflict"]');
      if (thoughtBox) thoughtBox.checked = thoughtSelected.has(id);
      if (conflictBox) conflictBox.checked = conflictSelectedClaims.has(id);
    }

    function relativeLink(location) {
      return repoRelativePath(location);
    }

    const metaPrefixes = [
      '**Subject:**', '**Polarity:**', '**Claim:**', '**Source:**', '**Violation:**',
      'Source:', 'Sources:', 'Related Claims', 'Open Questions', 'References / Source Fragments'
    ];

    const idPattern = /\b(INV|ARC|MECH|IMPL|Q)-\d{3}\b/;

    function cleanClaimLine(line, anchorLine) {
      if (!line) return '';
      let s = line.replace(anchorLine, '').trim();
      s = s.replace(/`([^`]+)`/g, '$1');
      s = s.replace(/\*\*([^*]+)\*\*/g, '$1');
      s = s.replace(/\[(.*?)\]\([^)]*\)/g, '$1');
      if (s.toLowerCase().startsWith('claim:')) s = s.split(':', 2)[1].trim();
      if (s.startsWith('### ')) s = s.slice(4).trim();
      if (s.startsWith('## ')) s = s.slice(3).trim();
      return s;
    }

    function extractSection(text, anchorId) {
      const lines = text.split(/\r?\n/);
      const anchorLine = `<a id="${anchorId}"></a>`;
      let start = -1;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes(anchorLine)) { start = i; break; }
      }
      if (start === -1) return { claimLine: '', excerpt: '' };

      let end = lines.length;
      for (let j = start + 1; j < lines.length; j++) {
        if (lines[j].includes('<a id="')) { end = j; break; }
      }

      let section = lines.slice(start, end);
      while (section.length && section[0].trim() === '') section.shift();
      while (section.length && section[section.length - 1].trim() === '') section.pop();
      const excerpt = section.join('\\n');

      let claimLine = '';
      for (const l of section) {
        if (l.includes('**Claim:**')) { claimLine = l; break; }
      }
      if (!claimLine) {
        for (const l of section) {
          const t = l.trim();
          if (!t.startsWith('#')) continue;
          if (t.startsWith('### Q-') || idPattern.test(t) || t.includes('(MECH-') || t.includes('(ARC-') || t.includes('(INV-')) {
            claimLine = l; break;
          }
        }
      }
      if (!claimLine) {
        for (const l of section) {
          const t = l.trim();
          if (!t) continue;
          if (t.startsWith('<a id=')) continue;
          if (t.startsWith('#')) continue;
          if (t.startsWith('---')) continue;
          if (t.startsWith('>')) continue;
          if (metaPrefixes.some(p => t.startsWith(p))) continue;
          claimLine = l; break;
        }
      }

      return { claimLine: cleanClaimLine(claimLine, anchorLine), excerpt };
    }

    function normalizeSectionExcerpt(excerpt) {
      if (!excerpt) return '';
      const lines = String(excerpt)
        .split(/\r?\n/)
        .filter(line => !line.includes('<a id='));
      return lines.join('\n').trim();
    }

    function parseMarkdownHeadingSections(text) {
      const lines = String(text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
      let title = '';
      let currentHeading = '';
      let buffer = [];
      const sections = [];

      function flush() {
        const content = buffer.join('\n').trim();
        sections.push({ heading: currentHeading, content });
        buffer = [];
      }

      lines.forEach((line, idx) => {
        const trimmed = line.trim();
        const headingMatch = trimmed.match(/^(#{1,6})\s+(.+)$/);
        if (headingMatch) {
          const heading = headingMatch[2].trim();
          if (!title && headingMatch[1].length === 1) title = heading;
          if (currentHeading || buffer.length) flush();
          currentHeading = heading;
          return;
        }
        if (!currentHeading && !title && idx === 0 && trimmed.startsWith('#')) {
          title = trimmed.replace(/^#+\s*/, '').trim();
          return;
        }
        buffer.push(line);
      });
      if (currentHeading || buffer.length) flush();

      const map = new Map();
      sections.forEach(section => {
        map.set(String(section.heading || '').toLowerCase(), section.content || '');
      });
      return { title, sections, map };
    }

    function getSectionByHeadingPrefix(parsed, prefixes) {
      if (!parsed || !Array.isArray(parsed.sections)) return '';
      const tokens = (prefixes || []).map(p => String(p).toLowerCase());
      for (const section of parsed.sections) {
        const heading = String(section.heading || '').toLowerCase();
        if (tokens.some(token => heading.startsWith(token))) {
          return String(section.content || '').trim();
        }
      }
      return '';
    }

    function toFirstParagraph(text) {
      const blocks = String(text || '')
        .split(/\n\s*\n/)
        .map(s => s.trim())
        .filter(Boolean);
      return blocks.length ? blocks[0] : '';
    }

    function parseConflictDetail(filePath, content) {
      const parsed = parseMarkdownHeadingSections(content);
      const title = parsed.title || filePath;
      const why = getSectionByHeadingPrefix(parsed, ['why they conflict']);
      const question = getSectionByHeadingPrefix(parsed, ['reconciliation question']);
      const statusBlock = getSectionByHeadingPrefix(parsed, ['status', 'resolution']);
      const idsBlock = getSectionByHeadingPrefix(parsed, ['conflicting claim ids']);
      const conflictingIds = (idsBlock.match(/\b(?:INV|ARC|MECH|IMPL|Q)-\d{3}\b/g) || []).filter(Boolean);

      let statusLabel = 'status unspecified';
      const lowered = String(statusBlock || '').toLowerCase();
      if (lowered.includes('resolved')) statusLabel = 'resolved';
      else if (lowered.includes('open')) statusLabel = 'open';

      const summary = toFirstParagraph(why) || toFirstParagraph(statusBlock);
      const resolutionNoteMatch = String(statusBlock || '').match(/Resolution note:\s*`([^`]+)`/i);
      const resolutionNote = resolutionNoteMatch ? resolutionNoteMatch[1].trim() : '';

      return {
        filePath,
        title,
        statusLabel,
        conflictingIds,
        whyBlock: String(why || '').trim(),
        summary,
        questionBlock: String(question || '').trim(),
        question: toFirstParagraph(question),
        statusBlock: String(statusBlock || '').trim(),
        resolutionNote,
      };
    }

    async function loadConflictDetailsForClaim(claimId, files) {
      const out = [];
      for (const file of files || []) {
        const key = `${claimId}:${file}`;
        if (conflictDetailCache.has(key)) {
          out.push(conflictDetailCache.get(key));
          continue;
        }
        try {
          const rel = relativeLink(file);
          const content = await fetchText(rel);
          const parsed = parseConflictDetail(file, content);
          conflictDetailCache.set(key, parsed);
          out.push(parsed);
        } catch (_) {
          const fallback = {
            filePath: file,
            title: file,
            statusLabel: 'unreadable',
            conflictingIds: [],
            whyBlock: '',
            summary: '',
            questionBlock: '',
            question: '',
            statusBlock: '',
            resolutionNote: '',
          };
          conflictDetailCache.set(key, fallback);
          out.push(fallback);
        }
      }
      return out;
    }

    function renderConflictDetailHtml(claimId, details) {
      if (!details || !details.length) {
        return '<div class="meta">No linked conflict files.</div>';
      }
      return details.map((detail, idx) => {
        const link = relativeLink(detail.filePath);
        const ids = (detail.conflictingIds || []).filter(Boolean);
        const idsHtml = ids.length
          ? ids.map(item => {
            if (item === claimId) return `<code>${escapeHtml(item)}</code>`;
            if (!claimMap.has(item)) return `<code>${escapeHtml(item)}</code>`;
            return `<a href="#" data-id="${escapeHtml(item)}">${escapeHtml(item)}</a>`;
          }).join(', ')
          : '-';
        const summaryHtml = detail.summary
          ? `<div class="conflict-block"><strong>Summary:</strong> ${escapeHtml(detail.summary)}</div>`
          : '';
        const whyHtml = detail.whyBlock
          ? `<div class="conflict-block"><strong>Why they conflict:</strong><div class="excerpt-content">${renderMarkdown(detail.whyBlock)}</div></div>`
          : '';
        const questionHtml = detail.questionBlock
          ? `<div class="conflict-block"><strong>Reconciliation question:</strong><div class="excerpt-content">${renderMarkdown(detail.questionBlock)}</div></div>`
          : '';
        const statusHtml = detail.statusBlock
          ? `<div class="conflict-block"><strong>Status detail:</strong><div class="excerpt-content">${renderMarkdown(detail.statusBlock)}</div></div>`
          : '';
        const noteHtml = detail.resolutionNote
          ? `<div class="conflict-block"><strong>Resolution note:</strong> <a href="${escapeHtml(repoRelativePath(detail.resolutionNote))}" target="_blank" rel="noopener">${escapeHtml(detail.resolutionNote)}</a></div>`
          : '';
        return `
          <details class="conflict-detail"${idx === 0 ? ' open' : ''}>
            <summary>${escapeHtml(detail.title)} <span class="conflict-meta">(${escapeHtml(detail.statusLabel)})</span></summary>
            <div class="conflict-meta">Source: <a href="${escapeHtml(link)}" target="_blank" rel="noopener">${escapeHtml(detail.filePath)}</a></div>
            <div class="conflict-meta">Conflicting IDs: ${idsHtml}</div>
            <div class="conflict-body">
              ${summaryHtml}
              ${whyHtml}
              ${questionHtml}
              ${statusHtml}
              ${noteHtml}
            </div>
          </details>
        `;
      }).join('');
    }

    async function loadClaimText(claim) {
      if (claimTextCache.has(claim.id)) return claimTextCache.get(claim.id);
      if (!claim.location || !claim.location.includes('#')) {
        const res = { claimLine: '', excerpt: '' };
        claimTextCache.set(claim.id, res);
        return res;
      }

      const [filePath, anchor] = claim.location.split('#', 2);
      const relPath = relativeLink(filePath);

      let text = fileCache.get(relPath);
      if (!text) {
        text = await fetchText(relPath);
        fileCache.set(relPath, text);
      }
      const extracted = extractSection(text, anchor);
      claimTextCache.set(claim.id, extracted);
      return extracted;
    }

    function wireDetailToggles(id) {
      const thoughtToggle = els.detailContent.querySelector('#toggleThought');
      const conflictToggle = els.detailContent.querySelector('#toggleConflict');
      if (thoughtToggle) {
        thoughtToggle.addEventListener('change', () => {
          if (thoughtToggle.checked) thoughtSelected.add(id);
          else thoughtSelected.delete(id);
          renderSelectedSummary();
          syncRowCheckboxes(id);
          renderGraph();
        });
      }
      if (conflictToggle) {
        conflictToggle.addEventListener('change', () => {
          if (conflictToggle.checked) conflictSelectedClaims.add(id);
          else conflictSelectedClaims.delete(id);
          renderSelectedSummary();
          syncRowCheckboxes(id);
          renderGraph();
        });
      }
    }

    async function selectClaim(id) {
      selectedId = id;
      renderTable();
      const c = claimMap.get(id);
      if (!c) return;

      const conflicts = conflictsMap[c.id] || [];
      const dependents = allClaims.filter(x => (x.depends_on || []).includes(c.id)).map(x => x.id);
      const loc = relativeLink(c.location);
      const thoughtChecked = thoughtSelected.has(c.id) ? 'checked' : '';
      const conflictChecked = conflictSelectedClaims.has(c.id) ? 'checked' : '';
      const toggleBlock = `
        <div class="claim-toggles">
          <label><input type="checkbox" id="toggleThought" ${thoughtChecked} /> Use in Thought</label>
          <label><input type="checkbox" id="toggleConflict" ${conflictChecked} /> Use in Conflict</label>
        </div>
      `;

      els.detailContent.innerHTML = `
        <h2>${c.id}</h2>
        <div class="meta">${c.type} | ${c.status}</div>
        <div class="meta">Loading claim text...</div>
        ${toggleBlock}
        <ul>
          <li><strong>Subject:</strong> ${c.subject || '-'}</li>
          <li><strong>Polarity:</strong> ${c.polarity || '-'}</li>
          <li><strong>Location:</strong> ${loc ? `<a href="${loc}" target="_blank">${loc}</a> <button class="doc-open" data-doc="${loc}">Open in Docs</button>` : '-'}</li>
          <li><strong>Depends On:</strong> ${c.depends_on.length ? c.depends_on.map(d => `<a href="#" data-id="${d}">${d}</a>`).join(', ') : '-'}</li>
          <li><strong>Dependents:</strong> ${dependents.length ? dependents.map(d => `<a href="#" data-id="${d}">${d}</a>`).join(', ') : '-'}</li>
          <li><strong>Conflicts:</strong> ${conflicts.length ? conflicts.map(f => {
            const link = relativeLink(f);
            return `<a href="${link}" target="_blank">${f}</a>`;
          }).join(', ') : '-'}</li>
        </ul>
      `;
      els.detailContent.querySelectorAll('a[data-id]').forEach(a => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          selectClaim(a.getAttribute('data-id'));
        });
      });
      els.detailContent.querySelectorAll('button[data-doc]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          openDocFromLocation(btn.getAttribute('data-doc'));
        });
      });
      wireDetailToggles(c.id);

      try {
        const [{ claimLine, excerpt }, conflictDetails] = await Promise.all([
          loadClaimText(c),
          loadConflictDetailsForClaim(c.id, conflicts),
        ]);
        if (selectedId !== id) return;
        const claimLineText = claimLine ? escapeHtml(claimLine) : '-';
        const sectionExcerpt = normalizeSectionExcerpt(excerpt);
        const sectionBlock = sectionExcerpt ? `
          <details open>
            <summary>Full section description</summary>
            <div class="excerpt-content">${renderMarkdown(sectionExcerpt)}</div>
          </details>
        ` : '<div class="meta">No section text found.</div>';
        const conflictDetailsBlock = `
          <details ${conflicts.length ? 'open' : ''}>
            <summary>Conflict context</summary>
            <div class="conflict-body">
              ${renderConflictDetailHtml(c.id, conflictDetails)}
            </div>
          </details>
        `;

        els.detailContent.innerHTML = `
          <h2>${c.id}</h2>
          <div class="meta">${c.type} | ${c.status}</div>
          ${toggleBlock}
          <ul>
            <li><strong>Claim:</strong> ${claimLineText}</li>
            <li><strong>Subject:</strong> ${c.subject || '-'}</li>
            <li><strong>Polarity:</strong> ${c.polarity || '-'}</li>
          <li><strong>Location:</strong> ${loc ? `<a href="${loc}" target="_blank">${loc}</a> <button class="doc-open" data-doc="${loc}">Open in Docs</button>` : '-'}</li>
            <li><strong>Depends On:</strong> ${c.depends_on.length ? c.depends_on.map(d => `<a href="#" data-id="${d}">${d}</a>`).join(', ') : '-'}</li>
            <li><strong>Dependents:</strong> ${dependents.length ? dependents.map(d => `<a href="#" data-id="${d}">${d}</a>`).join(', ') : '-'}</li>
            <li><strong>Conflict files:</strong> ${conflicts.length ? conflicts.map(f => {
              const link = relativeLink(f);
              return `<a href="${link}" target="_blank">${f}</a>`;
            }).join(', ') : '-'}</li>
          </ul>
          ${sectionBlock}
          ${conflictDetailsBlock}
        `;
        els.detailContent.querySelectorAll('a[data-id]').forEach(a => {
          a.addEventListener('click', (e) => {
            e.preventDefault();
            selectClaim(a.getAttribute('data-id'));
          });
        });
        els.detailContent.querySelectorAll('button[data-doc]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            openDocFromLocation(btn.getAttribute('data-doc'));
          });
        });
        wireDetailToggles(c.id);
      } catch (err) {
        if (selectedId !== id) return;
        els.detailContent.innerHTML += `<div class="meta">Failed to load claim text: ${escapeHtml(String(err))}</div>`;
      }

      renderGraph();
    }

    function updateHoverPoint(evt) {
      hoverPoint = { x: evt.clientX, y: evt.clientY };
    }

    function positionGraphTooltip() {
      if (!els.graphTooltip || !els.graphPanel || !hoverPoint) return;
      const panelRect = els.graphPanel.getBoundingClientRect();
      const tip = els.graphTooltip;
      const pad = 12;
      let x = hoverPoint.x - panelRect.left + pad;
      let y = hoverPoint.y - panelRect.top + pad;
      const maxX = panelRect.width - tip.offsetWidth - pad;
      const maxY = panelRect.height - tip.offsetHeight - pad;
      if (!Number.isNaN(maxX)) x = Math.min(x, maxX);
      if (!Number.isNaN(maxY)) y = Math.min(y, maxY);
      x = Math.max(pad, x);
      y = Math.max(pad, y);
      tip.style.left = `${x}px`;
      tip.style.top = `${y}px`;
    }

    function showGraphTooltip(evt, id) {
      const tip = els.graphTooltip;
      const c = claimMap.get(id);
      if (!tip || !c) return;
      hoverId = id;
      updateHoverPoint(evt);
      const cached = claimTextCache.get(id);
      const claimLine = cached && cached.claimLine ? cached.claimLine : '';
      tip.innerHTML = `
        <div class="title">${c.id}</div>
        <div class="meta">${c.type} | ${c.status}</div>
        <div class="meta">Subject: ${escapeHtml(c.subject || '-')}</div>
        ${claimLine ? `<div>${escapeHtml(claimLine)}</div>` : '<div class="meta">Loading claim...</div>'}
      `;
      tip.style.display = 'block';
      positionGraphTooltip();

      if (!claimLine) {
        loadClaimText(c).then(res => {
          if (hoverId !== id) return;
          const line = res.claimLine ? escapeHtml(res.claimLine) : '-';
          tip.innerHTML = `
            <div class="title">${c.id}</div>
            <div class="meta">${c.type} | ${c.status}</div>
            <div class="meta">Subject: ${escapeHtml(c.subject || '-')}</div>
            <div>${line}</div>
          `;
          positionGraphTooltip();
        }).catch(() => {});
      }
    }

    function moveGraphTooltip(evt) {
      if (!hoverId) return;
      updateHoverPoint(evt);
      positionGraphTooltip();
    }

    function hideGraphTooltip() {
      hoverId = null;
      hoverPoint = null;
      if (els.graphTooltip) els.graphTooltip.style.display = 'none';
    }

    function renderGraph() {
      const filtered = applyFilters();
      const includeDeps = els.includeDeps.checked;
      const nodes = new Map(filtered.map(c => [c.id, {...c, ghost: false}]));
      const focusMode = getFocusMode();
      const worksetScope = getWorksetScope();

      if (includeDeps) {
        filtered.forEach(c => {
          c.depends_on.forEach(dep => {
            if (!nodes.has(dep) && claimMap.has(dep)) {
              nodes.set(dep, {...claimMap.get(dep), ghost: true});
            }
          });
        });
      }

      const nodeList = Array.from(nodes.values());
      const nodeMap = new Map(nodeList.map(n => [n.id, n]));
      const forward = new Map();
      nodeList.forEach(n => {
        (n.depends_on || []).forEach(dep => {
          if (!nodeMap.has(dep)) return;
          if (!forward.has(dep)) forward.set(dep, []);
          forward.get(dep).push(n.id);
        });
      });
      const upstream = new Set();
      const downstream = new Set();
      let selected = null;
      let focusSet = null;
      let worksetIds = [];
      const selectedWorkset = new Set();

      function collectUpstream(id) {
        const stack = [id];
        const seen = new Set([id]);
        const out = new Set();
        while (stack.length) {
          const cur = stack.pop();
          const n = nodeMap.get(cur);
          if (!n) continue;
          (n.depends_on || []).forEach(dep => {
            if (!nodeMap.has(dep) || seen.has(dep)) return;
            seen.add(dep);
            out.add(dep);
            stack.push(dep);
          });
        }
        return out;
      }

      function collectDownstream(id) {
        const stack = [id];
        const seen = new Set([id]);
        const out = new Set();
        while (stack.length) {
          const cur = stack.pop();
          const children = forward.get(cur) || [];
          children.forEach(child => {
            if (seen.has(child)) return;
            seen.add(child);
            out.add(child);
            stack.push(child);
          });
        }
        return out;
      }

      function neighborhood(id) {
        const up = collectUpstream(id);
        const down = collectDownstream(id);
        const set = new Set([id]);
        up.forEach(x => set.add(x));
        down.forEach(x => set.add(x));
        return set;
      }

      function intersectSets(a, b) {
        const out = new Set();
        a.forEach(x => { if (b.has(x)) out.add(x); });
        return out;
      }

      function buildAdjacency() {
        const adj = new Map();
        nodeList.forEach(n => {
          if (!adj.has(n.id)) adj.set(n.id, new Set());
          (n.depends_on || []).forEach(dep => {
            if (!nodeMap.has(dep)) return;
            if (!adj.has(dep)) adj.set(dep, new Set());
            adj.get(n.id).add(dep);
            adj.get(dep).add(n.id);
          });
        });
        return adj;
      }

      function shortestPath(adj, start, goal) {
        if (start === goal) return [start];
        const queue = [start];
        const prev = new Map();
        const seen = new Set([start]);
        while (queue.length) {
          const cur = queue.shift();
          const neighbors = adj.get(cur) || [];
          for (const next of neighbors) {
            if (seen.has(next)) continue;
            seen.add(next);
            prev.set(next, cur);
            if (next === goal) {
              const path = [goal];
              let p = goal;
              while (prev.has(p)) {
                p = prev.get(p);
                path.push(p);
              }
              return path.reverse();
            }
            queue.push(next);
          }
        }
        return [];
      }

      selected = selectedId && nodeMap.has(selectedId) ? selectedId : null;
      if (focusMode === 'anchor' && selected) {
        const up = collectUpstream(selected);
        const down = collectDownstream(selected);
        up.forEach(x => upstream.add(x));
        down.forEach(x => downstream.add(x));
        focusSet = new Set([selected, ...upstream, ...downstream]);
      }

      if (focusMode === 'workset') {
        worksetIds = getWorksetIds().filter(id => nodeMap.has(id));
        worksetIds.forEach(id => selectedWorkset.add(id));
        if (selectedWorkset.size) {
          if (worksetScope === 'intersection') {
            let acc = null;
            worksetIds.forEach(id => {
              const set = neighborhood(id);
              acc = acc ? intersectSets(acc, set) : set;
            });
            focusSet = acc || new Set();
          } else if (worksetScope === 'connect') {
            if (selectedWorkset.size === 1) {
              focusSet = neighborhood(worksetIds[0]);
            } else {
              const adj = buildAdjacency();
              focusSet = new Set(worksetIds);
              for (let i = 0; i < worksetIds.length; i++) {
                for (let j = i + 1; j < worksetIds.length; j++) {
                  const path = shortestPath(adj, worksetIds[i], worksetIds[j]);
                  path.forEach(p => focusSet.add(p));
                }
              }
            }
          } else {
            focusSet = new Set();
            worksetIds.forEach(id => {
              neighborhood(id).forEach(x => focusSet.add(x));
            });
          }
        }
      }

      const depthMemo = new Map();
      const visiting = new Set();

      function depth(id) {
        if (depthMemo.has(id)) return depthMemo.get(id);
        if (visiting.has(id)) return 0;
        visiting.add(id);
        const n = nodeMap.get(id);
        if (!n || !n.depends_on || n.depends_on.length === 0) {
          depthMemo.set(id, 0);
          visiting.delete(id);
          return 0;
        }
        let d = 0;
        n.depends_on.forEach(dep => {
          if (nodeMap.has(dep)) d = Math.max(d, depth(dep) + 1);
        });
        depthMemo.set(id, d);
        visiting.delete(id);
        return d;
      }

      nodeList.forEach(n => depth(n.id));

      const groups = {};
      nodeList.forEach(n => {
        const d = depthMemo.get(n.id) || 0;
        groups[d] = groups[d] || [];
        groups[d].push(n);
      });

      Object.values(groups).forEach(g => g.sort((a,b) => a.id.localeCompare(b.id)));

      const maxDepth = Math.max(...Object.keys(groups).map(n => parseInt(n,10)), 0);
      const colWidth = 240;
      const rowHeight = 64;
      const margin = 20;

      const width = (maxDepth + 1) * colWidth + margin * 2;
      const maxRows = Math.max(...Object.values(groups).map(g => g.length), 1);
      const height = maxRows * rowHeight + margin * 2;

      const positions = {};
      Object.entries(groups).forEach(([d, arr]) => {
        arr.forEach((n, idx) => {
          positions[n.id] = {
            x: margin + parseInt(d,10) * colWidth,
            y: margin + idx * rowHeight,
          };
        });
      });

      const edges = [];
      nodeList.forEach(n => {
        n.depends_on.forEach(dep => {
          if (nodeMap.has(dep)) edges.push([dep, n.id]);
        });
      });
      const focus = focusSet;

      if (els.graphMeta) {
        let focusLabel = 'focus: none';
        if (focusMode === 'anchor') {
          focusLabel = selected ? `focus: ${selected}` : 'focus: anchor (none)';
        } else if (focusMode === 'workset') {
          focusLabel = selectedWorkset.size ? `focus: workset ${selectedWorkset.size} (${worksetScope})` : 'focus: workset (none)';
        }
        els.graphMeta.textContent = `Dependency graph (filtered set)  nodes: ${nodeList.length}, edges: ${edges.length}  ${focusLabel}`;
      }

      const svgParts = [];
      svgParts.push(`<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`);
      svgParts.push(`
        <defs>
          <marker id="arrow" markerWidth="8" markerHeight="8" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L6,3 L0,6 Z" fill="#777" />
          </marker>
        </defs>
      `);

      edges.forEach(([from, to]) => {
        const p1 = positions[from];
        const p2 = positions[to];
        if (!p1 || !p2) return;
        const x1 = p1.x + 180;
        const y1 = p1.y + 16;
        const x2 = p2.x;
        const y2 = p2.y + 16;
        let edgeClass = 'edge';
        if (focusMode === 'anchor' && selected) {
          if (!(focus && focus.has(from) && focus.has(to))) {
            edgeClass = 'edge dim';
          } else if ((from === selected || downstream.has(from)) && (downstream.has(to) || to === selected)) {
            edgeClass = 'edge downstream';
          } else if ((upstream.has(from) || from === selected) && (upstream.has(to) || to === selected)) {
            edgeClass = 'edge upstream';
          }
        } else if (focusMode === 'workset' && focus) {
          if (!(focus.has(from) && focus.has(to))) edgeClass = 'edge dim';
        }
        svgParts.push(`<line class="${edgeClass}" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" marker-end="url(#arrow)" />`);
      });

      nodeList.forEach(n => {
        const p = positions[n.id];
        if (!p) return;
        const fill = getTypeColor(n.type);
        const stroke = getTypeStroke(n.type);
        const dash = getStatusDash(n.status);
        const opacity = n.ghost ? 0.5 : 1;
        const conflict = (conflictsMap[n.id] || []).length > 0;
        let nodeClass = '';
        if (focusMode === 'anchor' && selected) {
          if (n.id === selected) nodeClass = ' selected';
          else if (downstream.has(n.id)) nodeClass = ' downstream';
          else if (upstream.has(n.id)) nodeClass = ' upstream';
          else nodeClass = ' dim';
        } else if (focusMode === 'workset' && focus) {
          if (selectedWorkset.has(n.id)) nodeClass = ' selected';
          else if (!focus.has(n.id)) nodeClass = ' dim';
        }
        svgParts.push(`
          <g class="node${nodeClass}" data-id="${n.id}" opacity="${opacity}">
            <rect x="${p.x}" y="${p.y}" rx="8" ry="8" width="180" height="32" fill="${fill}" stroke="${stroke}" stroke-width="1" stroke-dasharray="${dash}"></rect>
            <text x="${p.x + 8}" y="${p.y + 20}" fill="#1f2328">${n.id}${conflict ? ' *' : ''}</text>
          </g>
        `);
      });

      svgParts.push('</svg>');
      hideGraphTooltip();
      const tooltipNode = els.graphTooltip;
      els.graphPanel.innerHTML = '';
      if (tooltipNode) {
        tooltipNode.style.display = 'none';
        els.graphPanel.appendChild(tooltipNode);
      }
      els.graphPanel.insertAdjacentHTML('beforeend', svgParts.join('\\n'));

      els.graphPanel.querySelectorAll('.node').forEach(node => {
        node.addEventListener('click', () => {
          const id = node.getAttribute('data-id');
          if (id) selectClaim(id);
        });
        node.addEventListener('mouseenter', (e) => {
          const id = node.getAttribute('data-id');
          if (id) showGraphTooltip(e, id);
        });
        node.addEventListener('mousemove', (e) => moveGraphTooltip(e));
        node.addEventListener('mouseleave', () => hideGraphTooltip());
      });
    }

    function getTypeColor(type) {
      switch (type) {
        case 'invariant': return '#f7ecd0';
        case 'architectural_commitment': return '#e5efff';
        case 'mechanism_hypothesis': return '#e3f2ee';
        case 'open_question': return '#fdebd8';
        case 'implementation_note': return '#efeff2';
        default: return '#ffffff';
      }
    }

    function getTypeStroke(type) {
      switch (type) {
        case 'invariant': return '#dfc17a';
        case 'architectural_commitment': return '#9bb6e8';
        case 'mechanism_hypothesis': return '#92c9b7';
        case 'open_question': return '#e5b37d';
        case 'implementation_note': return '#c0c4ce';
        default: return '#c0c4ce';
      }
    }

    function getStatusDash(status) {
      switch (status) {
        case 'stable': return '0';
        case 'active': return '0';
        case 'provisional': return '6 4';
        case 'candidate': return '2 3';
        case 'legacy': return '4 2';
        default: return '0';
      }
    }

    function setPrimaryViewButton(activeButton) {
      [
        els.listViewBtn,
        els.graphViewBtn,
        els.docsViewBtn,
        els.mapViewBtn,
        els.tripleViewBtn,
        els.governanceViewBtn,
      ].forEach(btn => {
        if (!btn) return;
        if (btn === activeButton) btn.classList.add('primary');
        else btn.classList.remove('primary');
      });
    }

    function hideAllPrimaryViews() {
      if (els.listWrap) els.listWrap.style.display = 'none';
      if (els.graphWrap) els.graphWrap.style.display = 'none';
      if (els.docsWrap) els.docsWrap.style.display = 'none';
      if (els.mapWrap) els.mapWrap.style.display = 'none';
      if (els.tripleViewWrap) els.tripleViewWrap.style.display = 'none';
      if (els.governanceWrap) els.governanceWrap.style.display = 'none';
      hideTripleTooltip();
    }

    function setView(view) {
      currentView = view;
      hideAllPrimaryViews();

      if (view === 'graph') {
        if (els.graphWrap) els.graphWrap.style.display = 'block';
        setPrimaryViewButton(els.graphViewBtn);
        renderGraph();
        return;
      }

      if (view === 'docs') {
        if (els.docsWrap) els.docsWrap.style.display = 'block';
        setPrimaryViewButton(els.docsViewBtn);
        initDocs();
        return;
      }

      if (view === 'map') {
        if (els.mapWrap) els.mapWrap.style.display = 'block';
        setPrimaryViewButton(els.mapViewBtn);
        renderMap();
        return;
      }

      if (view === 'triple') {
        if (els.tripleViewWrap) els.tripleViewWrap.style.display = 'block';
        setPrimaryViewButton(els.tripleViewBtn);
        renderTripleView(false);
        return;
      }

      if (view === 'governance') {
        if (els.governanceWrap) els.governanceWrap.style.display = 'block';
        setPrimaryViewButton(els.governanceViewBtn);
        renderGovernance();
        refreshGovernanceData();
        return;
      }

      if (els.listWrap) els.listWrap.style.display = 'block';
      setPrimaryViewButton(els.listViewBtn);
    }

    function initDraftTabs() {
      const tabs = document.querySelectorAll('.draft-tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          const id = tab.getAttribute('data-tab');
          document.querySelectorAll('.draft-pane').forEach(p => p.classList.remove('active'));
          if (id === 'thought') document.getElementById('thoughtPane').classList.add('active');
          if (id === 'conflict') document.getElementById('conflictPane').classList.add('active');
        });
      });
    }

    let thoughtPrompt = FALLBACK_THOUGHT_PROMPT;
    let conflictPrompt = FALLBACK_CONFLICT_PROMPT;

    async function loadPrompts() {
      try {
        const readme = await fetchText(README_URL);
        const thought = extractPrompt(readme, 'THOUGHT INTAKE PROMPT');
        const conflict = extractPrompt(readme, 'CONFLICT RESOLUTION PROMPT');
        if (thought) thoughtPrompt = thought;
        if (conflict) conflictPrompt = conflict;
      } catch (_) {
        // fallback to embedded prompts
      }
    }

    function extractPrompt(text, heading) {
      const idx = text.indexOf(`## ${heading}`);
      if (idx < 0) return null;
      const slice = text.slice(idx);
      const match = slice.match(/```text\n([\s\S]*?)```/);
      return match ? match[1].trim() : null;
    }

    function buildThoughtDraft(text) {
      const related = Array.from(thoughtSelected).sort();
      const prefix = related.length ? `Related claims: ${related.join(', ')}\\n\\n` : '';
      return thoughtPrompt.replace('<PASTE YOUR THOUGHT HERE>', prefix + (text || ''));
    }

    function buildConflictDraft(refs, decision) {
      const refSet = new Set();
      if (refs) {
        refs.split(/[\\n,]/).map(r => r.trim()).filter(Boolean).forEach(r => refSet.add(r));
      }
      conflictSelectedFiles.forEach(f => refSet.add(f));
      conflictSelectedClaims.forEach(c => refSet.add(c));
      const refText = Array.from(refSet).join(', ');
      return conflictPrompt
        .replace('- <PASTE docs/conflicts/*.md PATHS OR CLAIM IDs>', `- ${refText}`)
        .replace('<DESCRIBE THE RESOLUTION IN YOUR OWN WORDS>', decision || '');
    }

    function setupDraftActions() {
      els.generateThought.addEventListener('click', () => {
        els.thoughtOutput.value = buildThoughtDraft(els.thoughtInput.value.trim());
      });
      els.copyThought.addEventListener('click', () => {
        els.thoughtOutput.select();
        document.execCommand('copy');
      });
      els.downloadThought.addEventListener('click', () => {
        downloadFile('thought_intake.md', els.thoughtOutput.value || buildThoughtDraft(els.thoughtInput.value.trim()));
      });

      els.generateConflict.addEventListener('click', () => {
        els.conflictOutput.value = buildConflictDraft(els.conflictRefs.value.trim(), els.conflictDecision.value.trim());
      });
      els.copyConflict.addEventListener('click', () => {
        els.conflictOutput.select();
        document.execCommand('copy');
      });
      els.downloadConflict.addEventListener('click', () => {
        downloadFile('conflict_resolution.md', els.conflictOutput.value || buildConflictDraft(els.conflictRefs.value.trim(), els.conflictDecision.value.trim()));
      });
    }

    function downloadFile(name, content) {
      const blob = new Blob([content], {type: 'text/markdown'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function wireEvents() {
      ['input', 'change'].forEach(evt => {
        els.search.addEventListener(evt, () => { renderTable(); renderGraph(); renderMap(); refreshTripleAnnotationsFromCurrentFilters(); });
        els.typeFilter.addEventListener(evt, () => { renderTable(); renderGraph(); renderMap(); refreshTripleAnnotationsFromCurrentFilters(); });
        els.statusFilter.addEventListener(evt, () => { renderTable(); renderGraph(); renderMap(); refreshTripleAnnotationsFromCurrentFilters(); });
        els.subjectFilter.addEventListener(evt, () => { renderTable(); renderGraph(); renderMap(); refreshTripleAnnotationsFromCurrentFilters(); });
        els.includeDeps.addEventListener(evt, () => renderGraph());
      });


      els.clearFilters.addEventListener('click', () => {
        els.search.value = '';
        els.typeFilter.value = '';
        els.statusFilter.value = '';
        els.subjectFilter.value = '';
        renderTable();
        renderGraph();
        renderMap();
        refreshTripleAnnotationsFromCurrentFilters();
      });

      els.listViewBtn.addEventListener('click', () => setView('list'));
      els.graphViewBtn.addEventListener('click', () => setView('graph'));
      if (els.docsViewBtn) {
        els.docsViewBtn.addEventListener('click', () => setView('docs'));
      }
      if (els.mapViewBtn) {
        els.mapViewBtn.addEventListener('click', () => setView('map'));
      }
      if (els.tripleViewBtn) {
        els.tripleViewBtn.addEventListener('click', () => setView('triple'));
      }
      if (els.governanceViewBtn) {
        els.governanceViewBtn.addEventListener('click', () => setView('governance'));
      }
      if (els.tripleReloadBtn) {
        els.tripleReloadBtn.addEventListener('click', () => {
          tripleViewLoaded = false;
          renderTripleView(true);
        });
      }
      if (els.mapEpochOnly) {
        els.mapEpochOnly.addEventListener('change', () => {
          renderMap();
          refreshTripleAnnotationsFromCurrentFilters();
        });
      }
      if (els.mapGovernanceOnly) {
        els.mapGovernanceOnly.addEventListener('change', () => {
          renderMap();
          refreshTripleAnnotationsFromCurrentFilters();
        });
      }
      if (els.mapLens) {
        els.mapLens.addEventListener('change', () => renderMap());
      }
      if (els.govEpochOnly) {
        els.govEpochOnly.addEventListener('change', () => {
          renderGovernance();
          renderMap();
          refreshTripleAnnotationsFromCurrentFilters();
        });
      }

      els.graphFocusRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          updateWorksetUI();
          renderGraph();
        });
      });
      els.worksetScopeRadios.forEach(radio => {
        radio.addEventListener('change', () => renderGraph());
      });
      if (els.worksetThought) {
        els.worksetThought.addEventListener('change', () => renderGraph());
      }
      if (els.worksetConflict) {
        els.worksetConflict.addEventListener('change', () => renderGraph());
      }

      if (els.docSelect) {
        els.docSelect.addEventListener('change', () => {
          if (els.docSelect.value) openDoc(els.docSelect.value);
        });
      }
      if (els.docSearch) {
        els.docSearch.addEventListener('input', () => {
          populateDocSelect(els.docSearch.value);
        });
      }
      document.addEventListener('keydown', (event) => {
        if (event.key !== 'Escape') return;
        hideTripleTooltip();
        closeTripleInspector();
      });
    }

    async function loadConflicts() {
      const conflicts = {};
      conflictFiles = [];
      try {
        const indexText = await fetchText(CONFLICT_INDEX_URL);
        const fileMatches = Array.from(indexText.matchAll(/docs\/conflicts\/[^\s`]+\.md/g));
        const files = Array.from(new Set(fileMatches.map(m => m[0])));
        conflictFiles = files;
        for (const file of files) {
          const rel = relativeLink(file);
          try {
            const content = await fetchText(rel);
            const ids = content.match(/\b[A-Z]{2,5}-\d{3}\b/g) || [];
            ids.forEach(id => {
              if (!conflicts[id]) conflicts[id] = [];
              conflicts[id].push(file);
            });
          } catch (_) {
            // skip unreadable conflict file
          }
        }
      } catch (_) {
        // no conflicts index or fetch failed
      }
      return conflicts;
    }

    async function refreshData() {
      const filterState = readFilterState();
      const previousView = currentView;
      const previousSelection = selectedId;

      const claimsText = await fetchText(CLAIMS_URL);
      const normalizedClaims = claimsText
        .replace(/\uFEFF/g, '')
        .replace(/\u200B/g, '')
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n');
      if (/^\s*</.test(normalizedClaims)) {
        throw new Error('claims.yaml returned HTML (not YAML). Start the server from repo root and reload.');
      }
      if (!/id:\s*(INV|ARC|MECH|IMPL|Q)-\d{3}/i.test(normalizedClaims)) {
        throw new Error('claims.yaml did not include any "id:" entries. Check the claims.yaml URL in your browser.');
      }
      await loadSubsystemMap();
      const parsed = parseClaimsYaml(normalizedClaims);
      if (!parsed.length) {
        const lines = normalizedClaims.split('\n');
        const preview = lines.slice(0, 6).join(' | ').slice(0, 300);
        throw new Error(`Parsed 0 claims from claims.yaml (lines: ${lines.length}). Preview: ${preview}`);
      }
      allClaims = parsed.map(normalizeClaim);
      claimMap = new Map(allClaims.map(c => [c.id, c]));
      conflictsMap = await loadConflicts();
      claimTextCache.clear();
      fileCache.clear();
      for (const id of Array.from(thoughtSelected)) {
        if (!claimMap.has(id)) thoughtSelected.delete(id);
      }
      for (const id of Array.from(conflictSelectedClaims)) {
        if (!claimMap.has(id)) conflictSelectedClaims.delete(id);
      }
      for (const file of Array.from(conflictSelectedFiles)) {
        if (!conflictFiles.includes(file)) conflictSelectedFiles.delete(file);
      }

      buildStats();
      populateFilters();
      renderPickers();
      restoreFilterState(filterState);
      renderTable();
      setView(previousView || 'list');
      renderMap();

      if (previousSelection && claimMap.has(previousSelection)) {
        selectClaim(previousSelection);
      } else if (previousSelection) {
        selectedId = null;
        if (els.detailContent) {
          els.detailContent.innerHTML = '<div class="meta">Select a claim to see details.</div>';
        }
      }

      await loadPrompts();
      await refreshGovernanceData();
      updateRefreshStatus();
    }

    async function init() {
      const isFile = window.location.protocol === 'file:';
      if (isFile) {
        showErrorHtml(
          'Opened via <code>file://</code>. This page needs a local server to read repo files.<br><br>' +
          'Steps:<br>' +
          '<pre>cd /Users/dgolden/Documents/GitHub/REE_assembly\npython3 -m http.server</pre>' +
          'Then open:<br>' +
          '<pre>http://localhost:8000/docs/claims/explorer.html</pre>'
        );
        return;
      } else {
        hideError();
      }

      if (!initialized) {
        initDraftTabs();
        setupDraftActions();
        wireEvents();
        bindTripleControls();
        initLegendToggles();
        updateWorksetUI();
        initialized = true;
      }

      try {
        await refreshData();
        if (!refreshTimer) {
          refreshTimer = setInterval(() => {
            refreshData().catch(err => showError(`Failed to refresh claims: ${String(err)}`));
          }, REFRESH_MS);
        }
      } catch (err) {
        showError(`Failed to load claims: ${String(err)}`);
      }
    }

    init();
  </script>
</body>
</html>
